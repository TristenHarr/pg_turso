// This file is test_decoding.c from PostgreSQL, translated to Zig with `zig translate-c`.
// It serves as reference to implement all the required C functions in Zig.

pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const Oid = c_uint;
pub const pg_int64 = c_long;
pub const struct___va_list_tag = extern struct {
    gp_offset: c_uint,
    fp_offset: c_uint,
    overflow_arg_area: ?*anyopaque,
    reg_save_area: ?*anyopaque,
};
pub const __builtin_va_list = [1]struct___va_list_tag;
pub const va_list = __builtin_va_list;
pub const __gnuc_va_list = __builtin_va_list;
pub const __u_char = u8;
pub const __u_short = c_ushort;
pub const __u_int = c_uint;
pub const __u_long = c_ulong;
pub const __int8_t = i8;
pub const __uint8_t = u8;
pub const __int16_t = c_short;
pub const __uint16_t = c_ushort;
pub const __int32_t = c_int;
pub const __uint32_t = c_uint;
pub const __int64_t = c_long;
pub const __uint64_t = c_ulong;
pub const __int_least8_t = __int8_t;
pub const __uint_least8_t = __uint8_t;
pub const __int_least16_t = __int16_t;
pub const __uint_least16_t = __uint16_t;
pub const __int_least32_t = __int32_t;
pub const __uint_least32_t = __uint32_t;
pub const __int_least64_t = __int64_t;
pub const __uint_least64_t = __uint64_t;
pub const __quad_t = c_long;
pub const __u_quad_t = c_ulong;
pub const __intmax_t = c_long;
pub const __uintmax_t = c_ulong;
pub const __dev_t = c_ulong;
pub const __uid_t = c_uint;
pub const __gid_t = c_uint;
pub const __ino_t = c_ulong;
pub const __ino64_t = c_ulong;
pub const __mode_t = c_uint;
pub const __nlink_t = c_ulong;
pub const __off_t = c_long;
pub const __off64_t = c_long;
pub const __pid_t = c_int;
pub const __fsid_t = extern struct {
    __val: [2]c_int,
};
pub const __clock_t = c_long;
pub const __rlim_t = c_ulong;
pub const __rlim64_t = c_ulong;
pub const __id_t = c_uint;
pub const __time_t = c_long;
pub const __useconds_t = c_uint;
pub const __suseconds_t = c_long;
pub const __suseconds64_t = c_long;
pub const __daddr_t = c_int;
pub const __key_t = c_int;
pub const __clockid_t = c_int;
pub const __timer_t = ?*anyopaque;
pub const __blksize_t = c_long;
pub const __blkcnt_t = c_long;
pub const __blkcnt64_t = c_long;
pub const __fsblkcnt_t = c_ulong;
pub const __fsblkcnt64_t = c_ulong;
pub const __fsfilcnt_t = c_ulong;
pub const __fsfilcnt64_t = c_ulong;
pub const __fsword_t = c_long;
pub const __ssize_t = c_long;
pub const __syscall_slong_t = c_long;
pub const __syscall_ulong_t = c_ulong;
pub const __loff_t = __off64_t;
pub const __caddr_t = [*c]u8;
pub const __intptr_t = c_long;
pub const __socklen_t = c_uint;
pub const __sig_atomic_t = c_int;
const union_unnamed_1 = extern union {
    __wch: c_uint,
    __wchb: [4]u8,
};
pub const __mbstate_t = extern struct {
    __count: c_int,
    __value: union_unnamed_1,
};
pub const struct__G_fpos_t = extern struct {
    __pos: __off_t,
    __state: __mbstate_t,
};
pub const __fpos_t = struct__G_fpos_t;
pub const struct__G_fpos64_t = extern struct {
    __pos: __off64_t,
    __state: __mbstate_t,
};
pub const __fpos64_t = struct__G_fpos64_t;
pub const struct__IO_marker = opaque {};
pub const _IO_lock_t = anyopaque;
pub const struct__IO_codecvt = opaque {};
pub const struct__IO_wide_data = opaque {};
pub const struct__IO_FILE = extern struct {
    _flags: c_int,
    _IO_read_ptr: [*c]u8,
    _IO_read_end: [*c]u8,
    _IO_read_base: [*c]u8,
    _IO_write_base: [*c]u8,
    _IO_write_ptr: [*c]u8,
    _IO_write_end: [*c]u8,
    _IO_buf_base: [*c]u8,
    _IO_buf_end: [*c]u8,
    _IO_save_base: [*c]u8,
    _IO_backup_base: [*c]u8,
    _IO_save_end: [*c]u8,
    _markers: ?*struct__IO_marker,
    _chain: [*c]struct__IO_FILE,
    _fileno: c_int,
    _flags2: c_int,
    _old_offset: __off_t,
    _cur_column: c_ushort,
    _vtable_offset: i8,
    _shortbuf: [1]u8,
    _lock: ?*_IO_lock_t,
    _offset: __off64_t,
    _codecvt: ?*struct__IO_codecvt,
    _wide_data: ?*struct__IO_wide_data,
    _freeres_list: [*c]struct__IO_FILE,
    _freeres_buf: ?*anyopaque,
    __pad5: usize,
    _mode: c_int,
    _unused2: [20]u8,
};
pub const __FILE = struct__IO_FILE;
pub const FILE = struct__IO_FILE;
pub const off_t = __off_t;
pub const fpos_t = __fpos_t;
pub extern var stdin: [*c]FILE;
pub extern var stdout: [*c]FILE;
pub extern var stderr: [*c]FILE;
pub extern fn remove(__filename: [*c]const u8) c_int;
pub extern fn rename(__old: [*c]const u8, __new: [*c]const u8) c_int;
pub extern fn renameat(__oldfd: c_int, __old: [*c]const u8, __newfd: c_int, __new: [*c]const u8) c_int;
pub extern fn fclose(__stream: [*c]FILE) c_int;
pub extern fn tmpfile() [*c]FILE;
pub extern fn tmpnam([*c]u8) [*c]u8;
pub extern fn tmpnam_r(__s: [*c]u8) [*c]u8;
pub extern fn tempnam(__dir: [*c]const u8, __pfx: [*c]const u8) [*c]u8;
pub extern fn fflush(__stream: [*c]FILE) c_int;
pub extern fn fflush_unlocked(__stream: [*c]FILE) c_int;
pub extern fn fopen(__filename: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn freopen(noalias __filename: [*c]const u8, noalias __modes: [*c]const u8, noalias __stream: [*c]FILE) [*c]FILE;
pub extern fn fdopen(__fd: c_int, __modes: [*c]const u8) [*c]FILE;
pub extern fn fmemopen(__s: ?*anyopaque, __len: usize, __modes: [*c]const u8) [*c]FILE;
pub extern fn open_memstream(__bufloc: [*c][*c]u8, __sizeloc: [*c]usize) [*c]FILE;
pub extern fn setbuf(noalias __stream: [*c]FILE, noalias __buf: [*c]u8) void;
pub extern fn setvbuf(noalias __stream: [*c]FILE, noalias __buf: [*c]u8, __modes: c_int, __n: usize) c_int;
pub extern fn setbuffer(noalias __stream: [*c]FILE, noalias __buf: [*c]u8, __size: usize) void;
pub extern fn setlinebuf(__stream: [*c]FILE) void;
pub extern fn fprintf(__stream: [*c]FILE, __format: [*c]const u8, ...) c_int;
pub extern fn printf(__format: [*c]const u8, ...) c_int;
pub extern fn sprintf(__s: [*c]u8, __format: [*c]const u8, ...) c_int;
pub extern fn vfprintf(__s: [*c]FILE, __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vprintf(__format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vsprintf(__s: [*c]u8, __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn snprintf(__s: [*c]u8, __maxlen: c_ulong, __format: [*c]const u8, ...) c_int;
pub extern fn vsnprintf(__s: [*c]u8, __maxlen: c_ulong, __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vdprintf(__fd: c_int, noalias __fmt: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn dprintf(__fd: c_int, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn fscanf(noalias __stream: [*c]FILE, noalias __format: [*c]const u8, ...) c_int;
pub extern fn scanf(noalias __format: [*c]const u8, ...) c_int;
pub extern fn sscanf(noalias __s: [*c]const u8, noalias __format: [*c]const u8, ...) c_int;
pub const _Float32 = f32;
pub const _Float64 = f64;
pub const _Float32x = f64;
pub const _Float64x = c_longdouble;
pub extern fn vfscanf(noalias __s: [*c]FILE, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vscanf(noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn vsscanf(noalias __s: [*c]const u8, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag) c_int;
pub extern fn fgetc(__stream: [*c]FILE) c_int;
pub extern fn getc(__stream: [*c]FILE) c_int;
pub extern fn getchar() c_int;
pub extern fn getc_unlocked(__stream: [*c]FILE) c_int;
pub extern fn getchar_unlocked() c_int;
pub extern fn fgetc_unlocked(__stream: [*c]FILE) c_int;
pub extern fn fputc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putchar(__c: c_int) c_int;
pub extern fn fputc_unlocked(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putc_unlocked(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putchar_unlocked(__c: c_int) c_int;
pub extern fn getw(__stream: [*c]FILE) c_int;
pub extern fn putw(__w: c_int, __stream: [*c]FILE) c_int;
pub extern fn fgets(noalias __s: [*c]u8, __n: c_int, noalias __stream: [*c]FILE) [*c]u8;
pub extern fn __getdelim(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn getdelim(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn getline(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn fputs(noalias __s: [*c]const u8, noalias __stream: [*c]FILE) c_int;
pub extern fn puts(__s: [*c]const u8) c_int;
pub extern fn ungetc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn fread(__ptr: ?*anyopaque, __size: c_ulong, __n: c_ulong, __stream: [*c]FILE) c_ulong;
pub extern fn fwrite(__ptr: ?*const anyopaque, __size: c_ulong, __n: c_ulong, __s: [*c]FILE) c_ulong;
pub extern fn fread_unlocked(noalias __ptr: ?*anyopaque, __size: usize, __n: usize, noalias __stream: [*c]FILE) usize;
pub extern fn fwrite_unlocked(noalias __ptr: ?*const anyopaque, __size: usize, __n: usize, noalias __stream: [*c]FILE) usize;
pub extern fn fseek(__stream: [*c]FILE, __off: c_long, __whence: c_int) c_int;
pub extern fn ftell(__stream: [*c]FILE) c_long;
pub extern fn rewind(__stream: [*c]FILE) void;
pub extern fn fseeko(__stream: [*c]FILE, __off: __off_t, __whence: c_int) c_int;
pub extern fn ftello(__stream: [*c]FILE) __off_t;
pub extern fn fgetpos(noalias __stream: [*c]FILE, noalias __pos: [*c]fpos_t) c_int;
pub extern fn fsetpos(__stream: [*c]FILE, __pos: [*c]const fpos_t) c_int;
pub extern fn clearerr(__stream: [*c]FILE) void;
pub extern fn feof(__stream: [*c]FILE) c_int;
pub extern fn ferror(__stream: [*c]FILE) c_int;
pub extern fn clearerr_unlocked(__stream: [*c]FILE) void;
pub extern fn feof_unlocked(__stream: [*c]FILE) c_int;
pub extern fn ferror_unlocked(__stream: [*c]FILE) c_int;
pub extern fn perror(__s: [*c]const u8) void;
pub extern fn fileno(__stream: [*c]FILE) c_int;
pub extern fn fileno_unlocked(__stream: [*c]FILE) c_int;
pub extern fn pclose(__stream: [*c]FILE) c_int;
pub extern fn popen(__command: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn ctermid(__s: [*c]u8) [*c]u8;
pub extern fn flockfile(__stream: [*c]FILE) void;
pub extern fn ftrylockfile(__stream: [*c]FILE) c_int;
pub extern fn funlockfile(__stream: [*c]FILE) void;
pub extern fn __uflow([*c]FILE) c_int;
pub extern fn __overflow([*c]FILE, c_int) c_int;
pub const wchar_t = c_int;
pub const div_t = extern struct {
    quot: c_int,
    rem: c_int,
};
pub const ldiv_t = extern struct {
    quot: c_long,
    rem: c_long,
};
pub const lldiv_t = extern struct {
    quot: c_longlong,
    rem: c_longlong,
};
pub extern fn __ctype_get_mb_cur_max() usize;
pub extern fn atof(__nptr: [*c]const u8) f64;
pub extern fn atoi(__nptr: [*c]const u8) c_int;
pub extern fn atol(__nptr: [*c]const u8) c_long;
pub extern fn atoll(__nptr: [*c]const u8) c_longlong;
pub extern fn strtod(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f64;
pub extern fn strtof(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f32;
pub extern fn strtold(__nptr: [*c]const u8, __endptr: [*c][*c]u8) c_longdouble;
pub extern fn strtol(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_long;
pub extern fn strtoul(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulong;
pub extern fn strtoq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtouq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn strtoll(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtoull(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn l64a(__n: c_long) [*c]u8;
pub extern fn a64l(__s: [*c]const u8) c_long;
pub const u_char = __u_char;
pub const u_short = __u_short;
pub const u_int = __u_int;
pub const u_long = __u_long;
pub const quad_t = __quad_t;
pub const u_quad_t = __u_quad_t;
pub const fsid_t = __fsid_t;
pub const loff_t = __loff_t;
pub const ino_t = __ino_t;
pub const dev_t = __dev_t;
pub const gid_t = __gid_t;
pub const mode_t = __mode_t;
pub const nlink_t = __nlink_t;
pub const uid_t = __uid_t;
pub const pid_t = __pid_t;
pub const id_t = __id_t;
pub const daddr_t = __daddr_t;
pub const caddr_t = __caddr_t;
pub const key_t = __key_t;
pub const clock_t = __clock_t;
pub const clockid_t = __clockid_t;
pub const time_t = __time_t;
pub const timer_t = __timer_t;
pub const ulong = c_ulong;
pub const ushort = c_ushort;
pub const uint = c_uint;
pub const u_int8_t = __uint8_t;
pub const u_int16_t = __uint16_t;
pub const u_int32_t = __uint32_t;
pub const u_int64_t = __uint64_t;
pub const register_t = c_long;
pub fn __bswap_16(arg___bsx: __uint16_t) callconv(.C) __uint16_t {
    var __bsx = arg___bsx;
    return @bitCast(__uint16_t, @truncate(c_short, ((@bitCast(c_int, @as(c_uint, __bsx)) >> @intCast(@import("std").math.Log2Int(c_int), 8)) & @as(c_int, 255)) | ((@bitCast(c_int, @as(c_uint, __bsx)) & @as(c_int, 255)) << @intCast(@import("std").math.Log2Int(c_int), 8))));
}
pub fn __bswap_32(arg___bsx: __uint32_t) callconv(.C) __uint32_t {
    var __bsx = arg___bsx;
    return ((((__bsx & @as(c_uint, 4278190080)) >> @intCast(@import("std").math.Log2Int(c_uint), 24)) | ((__bsx & @as(c_uint, 16711680)) >> @intCast(@import("std").math.Log2Int(c_uint), 8))) | ((__bsx & @as(c_uint, 65280)) << @intCast(@import("std").math.Log2Int(c_uint), 8))) | ((__bsx & @as(c_uint, 255)) << @intCast(@import("std").math.Log2Int(c_uint), 24));
}
pub fn __bswap_64(arg___bsx: __uint64_t) callconv(.C) __uint64_t {
    var __bsx = arg___bsx;
    return @bitCast(__uint64_t, @truncate(c_ulong, ((((((((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 18374686479671623680)) >> @intCast(@import("std").math.Log2Int(c_ulonglong), 56)) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 71776119061217280)) >> @intCast(@import("std").math.Log2Int(c_ulonglong), 40))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 280375465082880)) >> @intCast(@import("std").math.Log2Int(c_ulonglong), 24))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 1095216660480)) >> @intCast(@import("std").math.Log2Int(c_ulonglong), 8))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 4278190080)) << @intCast(@import("std").math.Log2Int(c_ulonglong), 8))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 16711680)) << @intCast(@import("std").math.Log2Int(c_ulonglong), 24))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 65280)) << @intCast(@import("std").math.Log2Int(c_ulonglong), 40))) | ((@bitCast(c_ulonglong, @as(c_ulonglong, __bsx)) & @as(c_ulonglong, 255)) << @intCast(@import("std").math.Log2Int(c_ulonglong), 56))));
}
pub fn __uint16_identity(arg___x: __uint16_t) callconv(.C) __uint16_t {
    var __x = arg___x;
    return __x;
}
pub fn __uint32_identity(arg___x: __uint32_t) callconv(.C) __uint32_t {
    var __x = arg___x;
    return __x;
}
pub fn __uint64_identity(arg___x: __uint64_t) callconv(.C) __uint64_t {
    var __x = arg___x;
    return __x;
}
pub const __sigset_t = extern struct {
    __val: [16]c_ulong,
};
pub const sigset_t = __sigset_t;
pub const struct_timeval = extern struct {
    tv_sec: __time_t,
    tv_usec: __suseconds_t,
};
pub const struct_timespec = extern struct {
    tv_sec: __time_t,
    tv_nsec: __syscall_slong_t,
};
pub const suseconds_t = __suseconds_t;
pub const __fd_mask = c_long;
pub const fd_set = extern struct {
    __fds_bits: [16]__fd_mask,
};
pub const fd_mask = __fd_mask;
pub extern fn select(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]struct_timeval) c_int;
pub extern fn pselect(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]const struct_timespec, noalias __sigmask: [*c]const __sigset_t) c_int;
pub const blksize_t = __blksize_t;
pub const blkcnt_t = __blkcnt_t;
pub const fsblkcnt_t = __fsblkcnt_t;
pub const fsfilcnt_t = __fsfilcnt_t;
const struct_unnamed_2 = extern struct {
    __low: c_uint,
    __high: c_uint,
};
pub const __atomic_wide_counter = extern union {
    __value64: c_ulonglong,
    __value32: struct_unnamed_2,
};
pub const struct___pthread_internal_list = extern struct {
    __prev: [*c]struct___pthread_internal_list,
    __next: [*c]struct___pthread_internal_list,
};
pub const __pthread_list_t = struct___pthread_internal_list;
pub const struct___pthread_internal_slist = extern struct {
    __next: [*c]struct___pthread_internal_slist,
};
pub const __pthread_slist_t = struct___pthread_internal_slist;
pub const struct___pthread_mutex_s = extern struct {
    __lock: c_int,
    __count: c_uint,
    __owner: c_int,
    __nusers: c_uint,
    __kind: c_int,
    __spins: c_short,
    __elision: c_short,
    __list: __pthread_list_t,
};
pub const struct___pthread_rwlock_arch_t = extern struct {
    __readers: c_uint,
    __writers: c_uint,
    __wrphase_futex: c_uint,
    __writers_futex: c_uint,
    __pad3: c_uint,
    __pad4: c_uint,
    __cur_writer: c_int,
    __shared: c_int,
    __rwelision: i8,
    __pad1: [7]u8,
    __pad2: c_ulong,
    __flags: c_uint,
};
pub const struct___pthread_cond_s = extern struct {
    __wseq: __atomic_wide_counter,
    __g1_start: __atomic_wide_counter,
    __g_refs: [2]c_uint,
    __g_size: [2]c_uint,
    __g1_orig_size: c_uint,
    __wrefs: c_uint,
    __g_signals: [2]c_uint,
};
pub const __tss_t = c_uint;
pub const __thrd_t = c_ulong;
pub const __once_flag = extern struct {
    __data: c_int,
};
pub const pthread_t = c_ulong;
pub const pthread_mutexattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const pthread_condattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const pthread_key_t = c_uint;
pub const pthread_once_t = c_int;
pub const union_pthread_attr_t = extern union {
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_attr_t = union_pthread_attr_t;
pub const pthread_mutex_t = extern union {
    __data: struct___pthread_mutex_s,
    __size: [40]u8,
    __align: c_long,
};
pub const pthread_cond_t = extern union {
    __data: struct___pthread_cond_s,
    __size: [48]u8,
    __align: c_longlong,
};
pub const pthread_rwlock_t = extern union {
    __data: struct___pthread_rwlock_arch_t,
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_rwlockattr_t = extern union {
    __size: [8]u8,
    __align: c_long,
};
pub const pthread_spinlock_t = c_int;
pub const pthread_barrier_t = extern union {
    __size: [32]u8,
    __align: c_long,
};
pub const pthread_barrierattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub extern fn random() c_long;
pub extern fn srandom(__seed: c_uint) void;
pub extern fn initstate(__seed: c_uint, __statebuf: [*c]u8, __statelen: usize) [*c]u8;
pub extern fn setstate(__statebuf: [*c]u8) [*c]u8;
pub const struct_random_data = extern struct {
    fptr: [*c]i32,
    rptr: [*c]i32,
    state: [*c]i32,
    rand_type: c_int,
    rand_deg: c_int,
    rand_sep: c_int,
    end_ptr: [*c]i32,
};
pub extern fn random_r(noalias __buf: [*c]struct_random_data, noalias __result: [*c]i32) c_int;
pub extern fn srandom_r(__seed: c_uint, __buf: [*c]struct_random_data) c_int;
pub extern fn initstate_r(__seed: c_uint, noalias __statebuf: [*c]u8, __statelen: usize, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn setstate_r(noalias __statebuf: [*c]u8, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn rand() c_int;
pub extern fn srand(__seed: c_uint) void;
pub extern fn rand_r(__seed: [*c]c_uint) c_int;
pub extern fn drand48() f64;
pub extern fn erand48(__xsubi: [*c]c_ushort) f64;
pub extern fn lrand48() c_long;
pub extern fn nrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn mrand48() c_long;
pub extern fn jrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn srand48(__seedval: c_long) void;
pub extern fn seed48(__seed16v: [*c]c_ushort) [*c]c_ushort;
pub extern fn lcong48(__param: [*c]c_ushort) void;
pub const struct_drand48_data = extern struct {
    __x: [3]c_ushort,
    __old_x: [3]c_ushort,
    __c: c_ushort,
    __init: c_ushort,
    __a: c_ulonglong,
};
pub extern fn drand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn erand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn lrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn nrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn mrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn jrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn srand48_r(__seedval: c_long, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn seed48_r(__seed16v: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn lcong48_r(__param: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn arc4random() __uint32_t;
pub extern fn arc4random_buf(__buf: ?*anyopaque, __size: usize) void;
pub extern fn arc4random_uniform(__upper_bound: __uint32_t) __uint32_t;
pub extern fn malloc(__size: c_ulong) ?*anyopaque;
pub extern fn calloc(__nmemb: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn realloc(__ptr: ?*anyopaque, __size: c_ulong) ?*anyopaque;
pub extern fn free(__ptr: ?*anyopaque) void;
pub extern fn reallocarray(__ptr: ?*anyopaque, __nmemb: usize, __size: usize) ?*anyopaque;
pub extern fn alloca(__size: c_ulong) ?*anyopaque;
pub extern fn valloc(__size: usize) ?*anyopaque;
pub extern fn posix_memalign(__memptr: [*c]?*anyopaque, __alignment: usize, __size: usize) c_int;
pub extern fn aligned_alloc(__alignment: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn abort() noreturn;
pub extern fn atexit(__func: ?*const fn () callconv(.C) void) c_int;
pub extern fn at_quick_exit(__func: ?*const fn () callconv(.C) void) c_int;
pub extern fn on_exit(__func: ?*const fn (c_int, ?*anyopaque) callconv(.C) void, __arg: ?*anyopaque) c_int;
pub extern fn exit(__status: c_int) noreturn;
pub extern fn quick_exit(__status: c_int) noreturn;
pub extern fn _Exit(__status: c_int) noreturn;
pub extern fn getenv(__name: [*c]const u8) [*c]u8;
pub extern fn putenv(__string: [*c]u8) c_int;
pub extern fn setenv(__name: [*c]const u8, __value: [*c]const u8, __replace: c_int) c_int;
pub extern fn unsetenv(__name: [*c]const u8) c_int;
pub extern fn clearenv() c_int;
pub extern fn mktemp(__template: [*c]u8) [*c]u8;
pub extern fn mkstemp(__template: [*c]u8) c_int;
pub extern fn mkstemps(__template: [*c]u8, __suffixlen: c_int) c_int;
pub extern fn mkdtemp(__template: [*c]u8) [*c]u8;
pub extern fn system(__command: [*c]const u8) c_int;
pub extern fn realpath(noalias __name: [*c]const u8, noalias __resolved: [*c]u8) [*c]u8;
pub const __compar_fn_t = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int;
pub extern fn bsearch(__key: ?*const anyopaque, __base: ?*const anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) ?*anyopaque;
pub extern fn qsort(__base: ?*anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) void;
pub extern fn abs(__x: c_int) c_int;
pub extern fn labs(__x: c_long) c_long;
pub extern fn llabs(__x: c_longlong) c_longlong;
pub extern fn div(__numer: c_int, __denom: c_int) div_t;
pub extern fn ldiv(__numer: c_long, __denom: c_long) ldiv_t;
pub extern fn lldiv(__numer: c_longlong, __denom: c_longlong) lldiv_t;
pub extern fn ecvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn fcvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn gcvt(__value: f64, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn qecvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qfcvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qgcvt(__value: c_longdouble, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn ecvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn fcvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qecvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qfcvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn mblen(__s: [*c]const u8, __n: usize) c_int;
pub extern fn mbtowc(noalias __pwc: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) c_int;
pub extern fn wctomb(__s: [*c]u8, __wchar: wchar_t) c_int;
pub extern fn mbstowcs(noalias __pwcs: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) usize;
pub extern fn wcstombs(noalias __s: [*c]u8, noalias __pwcs: [*c]const wchar_t, __n: usize) usize;
pub extern fn rpmatch(__response: [*c]const u8) c_int;
pub extern fn getsubopt(noalias __optionp: [*c][*c]u8, noalias __tokens: [*c]const [*c]u8, noalias __valuep: [*c][*c]u8) c_int;
pub extern fn getloadavg(__loadavg: [*c]f64, __nelem: c_int) c_int;
pub extern fn memcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memmove(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memccpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memset(__s: ?*anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn __memcmpeq(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: usize) c_int;
pub extern fn memchr(__s: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn strcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcat(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncat(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcoll(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strxfrm(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub const struct___locale_data = opaque {};
pub const struct___locale_struct = extern struct {
    __locales: [13]?*struct___locale_data,
    __ctype_b: [*c]const c_ushort,
    __ctype_tolower: [*c]const c_int,
    __ctype_toupper: [*c]const c_int,
    __names: [13][*c]const u8,
};
pub const __locale_t = [*c]struct___locale_struct;
pub const locale_t = __locale_t;
pub extern fn strcoll_l(__s1: [*c]const u8, __s2: [*c]const u8, __l: locale_t) c_int;
pub extern fn strxfrm_l(__dest: [*c]u8, __src: [*c]const u8, __n: usize, __l: locale_t) usize;
pub extern fn strdup(__s: [*c]const u8) [*c]u8;
pub extern fn strndup(__string: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strrchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strcspn(__s: [*c]const u8, __reject: [*c]const u8) c_ulong;
pub extern fn strspn(__s: [*c]const u8, __accept: [*c]const u8) c_ulong;
pub extern fn strpbrk(__s: [*c]const u8, __accept: [*c]const u8) [*c]u8;
pub extern fn strstr(__haystack: [*c]const u8, __needle: [*c]const u8) [*c]u8;
pub extern fn strtok(__s: [*c]u8, __delim: [*c]const u8) [*c]u8;
pub extern fn __strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strlen(__s: [*c]const u8) c_ulong;
pub extern fn strnlen(__string: [*c]const u8, __maxlen: usize) usize;
pub extern fn strerror(__errnum: c_int) [*c]u8;
pub extern fn strerror_r(__errnum: c_int, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn strerror_l(__errnum: c_int, __l: locale_t) [*c]u8;
pub extern fn bcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn bcopy(__src: ?*const anyopaque, __dest: ?*anyopaque, __n: usize) void;
pub extern fn bzero(__s: ?*anyopaque, __n: c_ulong) void;
pub extern fn index(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn rindex(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn ffs(__i: c_int) c_int;
pub extern fn ffsl(__l: c_long) c_int;
pub extern fn ffsll(__ll: c_longlong) c_int;
pub extern fn strcasecmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncasecmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __loc: locale_t) c_int;
pub extern fn strncasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __n: usize, __loc: locale_t) c_int;
pub extern fn explicit_bzero(__s: ?*anyopaque, __n: usize) void;
pub extern fn strsep(noalias __stringp: [*c][*c]u8, noalias __delim: [*c]const u8) [*c]u8;
pub extern fn strsignal(__sig: c_int) [*c]u8;
pub extern fn __stpcpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8) [*c]u8;
pub extern fn stpcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn __stpncpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8, __n: usize) [*c]u8;
pub extern fn stpncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub const ptrdiff_t = c_long;
pub const max_align_t = extern struct {
    __clang_max_align_nonce1: c_longlong align(8),
    __clang_max_align_nonce2: c_longdouble align(16),
};
pub const int_least8_t = __int_least8_t;
pub const int_least16_t = __int_least16_t;
pub const int_least32_t = __int_least32_t;
pub const int_least64_t = __int_least64_t;
pub const uint_least8_t = __uint_least8_t;
pub const uint_least16_t = __uint_least16_t;
pub const uint_least32_t = __uint_least32_t;
pub const uint_least64_t = __uint_least64_t;
pub const int_fast8_t = i8;
pub const int_fast16_t = c_long;
pub const int_fast32_t = c_long;
pub const int_fast64_t = c_long;
pub const uint_fast8_t = u8;
pub const uint_fast16_t = c_ulong;
pub const uint_fast32_t = c_ulong;
pub const uint_fast64_t = c_ulong;
pub const intmax_t = __intmax_t;
pub const uintmax_t = __uintmax_t;
pub extern fn __errno_location() [*c]c_int;
pub const struct_lconv = extern struct {
    decimal_point: [*c]u8,
    thousands_sep: [*c]u8,
    grouping: [*c]u8,
    int_curr_symbol: [*c]u8,
    currency_symbol: [*c]u8,
    mon_decimal_point: [*c]u8,
    mon_thousands_sep: [*c]u8,
    mon_grouping: [*c]u8,
    positive_sign: [*c]u8,
    negative_sign: [*c]u8,
    int_frac_digits: u8,
    frac_digits: u8,
    p_cs_precedes: u8,
    p_sep_by_space: u8,
    n_cs_precedes: u8,
    n_sep_by_space: u8,
    p_sign_posn: u8,
    n_sign_posn: u8,
    int_p_cs_precedes: u8,
    int_p_sep_by_space: u8,
    int_n_cs_precedes: u8,
    int_n_sep_by_space: u8,
    int_p_sign_posn: u8,
    int_n_sign_posn: u8,
};
pub extern fn setlocale(__category: c_int, __locale: [*c]const u8) [*c]u8;
pub extern fn localeconv() [*c]struct_lconv;
pub extern fn newlocale(__category_mask: c_int, __locale: [*c]const u8, __base: locale_t) locale_t;
pub extern fn duplocale(__dataset: locale_t) locale_t;
pub extern fn freelocale(__dataset: locale_t) void;
pub extern fn uselocale(__dataset: locale_t) locale_t;
pub const pg_funcptr_t = ?*const fn () callconv(.C) void;
pub const Pointer = [*c]u8;
pub const int8 = i8;
pub const int16 = c_short;
pub const int32 = c_int;
pub const uint8 = u8;
pub const uint16 = c_ushort;
pub const uint32 = c_uint;
pub const bits8 = uint8;
pub const bits16 = uint16;
pub const bits32 = uint32;
pub const int64 = c_long;
pub const uint64 = c_ulong;
pub const int128 = i128;
pub const uint128 = u128;
pub const Size = usize;
pub const Index = c_uint;
pub const Offset = c_int;
pub const float4 = f32;
pub const float8 = f64;
pub const regproc = Oid;
pub const RegProcedure = regproc;
pub const TransactionId = uint32;
pub const LocalTransactionId = uint32;
pub const SubTransactionId = uint32;
pub const MultiXactId = TransactionId;
pub const MultiXactOffset = uint32;
pub const CommandId = uint32;
pub const struct_varlena = extern struct {
    vl_len_: [4]u8 align(1),
    pub fn vl_dat(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @ptrCast(ReturnType, @alignCast(@alignOf(u8), @ptrCast(Intermediate, self) + 4));
    }
};
pub const bytea = struct_varlena;
pub const text = struct_varlena;
pub const BpChar = struct_varlena;
pub const VarChar = struct_varlena;
pub const int2vector = extern struct {
    vl_len_: int32 align(4),
    ndim: c_int,
    dataoffset: int32,
    elemtype: Oid,
    dim1: c_int,
    lbound1: c_int,
    pub fn values(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), int16) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), int16);
        return @ptrCast(ReturnType, @alignCast(@alignOf(int16), @ptrCast(Intermediate, self) + 24));
    }
};
pub const oidvector = extern struct {
    vl_len_: int32 align(4),
    ndim: c_int,
    dataoffset: int32,
    elemtype: Oid,
    dim1: c_int,
    lbound1: c_int,
    pub fn values(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), Oid) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), Oid);
        return @ptrCast(ReturnType, @alignCast(@alignOf(Oid), @ptrCast(Intermediate, self) + 24));
    }
};
pub const struct_nameData = extern struct {
    data: [64]u8,
};
pub const NameData = struct_nameData;
pub const Name = [*c]NameData;
pub extern fn ExceptionalCondition(conditionName: [*c]const u8, fileName: [*c]const u8, lineNumber: c_int) noreturn;
pub const union_PGAlignedBlock = extern union {
    data: [8192]u8,
    force_align_d: f64,
    force_align_i64: int64,
};
pub const PGAlignedBlock = union_PGAlignedBlock;
pub const union_PGIOAlignedBlock = extern union {
    data: [8192]u8 align(4096),
    force_align_d: f64,
    force_align_i64: int64,
};
pub const PGIOAlignedBlock = union_PGIOAlignedBlock;
pub const union_PGAlignedXLogBlock = extern union {
    data: [8192]u8 align(4096),
    force_align_d: f64,
    force_align_i64: int64,
};
pub const PGAlignedXLogBlock = union_PGAlignedXLogBlock;
pub const _ISupper: c_int = 256;
pub const _ISlower: c_int = 512;
pub const _ISalpha: c_int = 1024;
pub const _ISdigit: c_int = 2048;
pub const _ISxdigit: c_int = 4096;
pub const _ISspace: c_int = 8192;
pub const _ISprint: c_int = 16384;
pub const _ISgraph: c_int = 32768;
pub const _ISblank: c_int = 1;
pub const _IScntrl: c_int = 2;
pub const _ISpunct: c_int = 4;
pub const _ISalnum: c_int = 8;
const enum_unnamed_3 = c_uint;
pub extern fn __ctype_b_loc() [*c][*c]const c_ushort;
pub extern fn __ctype_tolower_loc() [*c][*c]const __int32_t;
pub extern fn __ctype_toupper_loc() [*c][*c]const __int32_t;
pub extern fn isalnum(c_int) c_int;
pub extern fn isalpha(c_int) c_int;
pub extern fn iscntrl(c_int) c_int;
pub extern fn isdigit(c_int) c_int;
pub extern fn islower(c_int) c_int;
pub extern fn isgraph(c_int) c_int;
pub extern fn isprint(c_int) c_int;
pub extern fn ispunct(c_int) c_int;
pub extern fn isspace(c_int) c_int;
pub extern fn isupper(c_int) c_int;
pub extern fn isxdigit(c_int) c_int;
pub extern fn tolower(__c: c_int) c_int;
pub extern fn toupper(__c: c_int) c_int;
pub extern fn isblank(c_int) c_int;
pub extern fn isascii(__c: c_int) c_int;
pub extern fn toascii(__c: c_int) c_int;
pub extern fn _toupper(c_int) c_int;
pub extern fn _tolower(c_int) c_int;
pub extern fn isalnum_l(c_int, locale_t) c_int;
pub extern fn isalpha_l(c_int, locale_t) c_int;
pub extern fn iscntrl_l(c_int, locale_t) c_int;
pub extern fn isdigit_l(c_int, locale_t) c_int;
pub extern fn islower_l(c_int, locale_t) c_int;
pub extern fn isgraph_l(c_int, locale_t) c_int;
pub extern fn isprint_l(c_int, locale_t) c_int;
pub extern fn ispunct_l(c_int, locale_t) c_int;
pub extern fn isspace_l(c_int, locale_t) c_int;
pub extern fn isupper_l(c_int, locale_t) c_int;
pub extern fn isxdigit_l(c_int, locale_t) c_int;
pub extern fn isblank_l(c_int, locale_t) c_int;
pub extern fn __tolower_l(__c: c_int, __l: locale_t) c_int;
pub extern fn tolower_l(__c: c_int, __l: locale_t) c_int;
pub extern fn __toupper_l(__c: c_int, __l: locale_t) c_int;
pub extern fn toupper_l(__c: c_int, __l: locale_t) c_int;
pub const pgsocket = c_int;
pub extern fn pg_set_noblock(sock: pgsocket) bool;
pub extern fn pg_set_block(sock: pgsocket) bool;
pub extern fn has_drive_prefix(path: [*c]const u8) bool;
pub extern fn first_dir_separator(filename: [*c]const u8) [*c]u8;
pub extern fn last_dir_separator(filename: [*c]const u8) [*c]u8;
pub extern fn first_path_var_separator(pathlist: [*c]const u8) [*c]u8;
pub extern fn join_path_components(ret_path: [*c]u8, head: [*c]const u8, tail: [*c]const u8) void;
pub extern fn canonicalize_path(path: [*c]u8) void;
pub extern fn make_native_path(filename: [*c]u8) void;
pub extern fn cleanup_path(path: [*c]u8) void;
pub extern fn path_contains_parent_reference(path: [*c]const u8) bool;
pub extern fn path_is_relative_and_below_cwd(path: [*c]const u8) bool;
pub extern fn path_is_prefix_of_path(path1: [*c]const u8, path2: [*c]const u8) bool;
pub extern fn make_absolute_path(path: [*c]const u8) [*c]u8;
pub extern fn get_progname(argv0: [*c]const u8) [*c]const u8;
pub extern fn get_share_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_etc_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_include_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_pkginclude_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_includeserver_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_lib_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_pkglib_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_locale_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_doc_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_html_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_man_path(my_exec_path: [*c]const u8, ret_path: [*c]u8) void;
pub extern fn get_home_path(ret_path: [*c]u8) bool;
pub extern fn get_parent_directory(path: [*c]u8) void;
pub extern fn pgfnames(path: [*c]const u8) [*c][*c]u8;
pub extern fn pgfnames_cleanup(filenames: [*c][*c]u8) void;
pub extern fn set_pglocale_pgservice(argv0: [*c]const u8, app: [*c]const u8) void;
pub extern fn validate_exec(path: [*c]const u8) c_int;
pub extern fn find_my_exec(argv0: [*c]const u8, retpath: [*c]u8) c_int;
pub extern fn find_other_exec(argv0: [*c]const u8, target: [*c]const u8, versionstr: [*c]const u8, retpath: [*c]u8) c_int;
pub extern fn pipe_read_line(cmd: [*c]u8, line: [*c]u8, maxsize: c_int) [*c]u8;
pub extern fn pg_usleep(microsec: c_long) void;
pub extern fn pg_strcasecmp(s1: [*c]const u8, s2: [*c]const u8) c_int;
pub extern fn pg_strncasecmp(s1: [*c]const u8, s2: [*c]const u8, n: usize) c_int;
pub extern fn pg_toupper(ch: u8) u8;
pub extern fn pg_tolower(ch: u8) u8;
pub extern fn pg_ascii_toupper(ch: u8) u8;
pub extern fn pg_ascii_tolower(ch: u8) u8;
pub extern fn pg_vsnprintf(str: [*c]u8, count: usize, fmt: [*c]const u8, args: [*c]struct___va_list_tag) c_int;
pub extern fn pg_snprintf(str: [*c]u8, count: usize, fmt: [*c]const u8, ...) c_int;
pub extern fn pg_vsprintf(str: [*c]u8, fmt: [*c]const u8, args: [*c]struct___va_list_tag) c_int;
pub extern fn pg_sprintf(str: [*c]u8, fmt: [*c]const u8, ...) c_int;
pub extern fn pg_vfprintf(stream: [*c]FILE, fmt: [*c]const u8, args: [*c]struct___va_list_tag) c_int;
pub extern fn pg_fprintf(stream: [*c]FILE, fmt: [*c]const u8, ...) c_int;
pub extern fn pg_vprintf(fmt: [*c]const u8, args: [*c]struct___va_list_tag) c_int;
pub extern fn pg_printf(fmt: [*c]const u8, ...) c_int;
pub extern fn pg_strfromd(str: [*c]u8, count: usize, precision: c_int, value: f64) c_int;
pub extern fn pg_strerror(errnum: c_int) [*c]u8;
pub extern fn pg_strerror_r(errnum: c_int, buf: [*c]u8, buflen: usize) [*c]u8;
pub extern fn pg_strsignal(signum: c_int) [*c]const u8;
pub extern fn pclose_check(stream: [*c]FILE) c_int;
pub extern fn rmtree(path: [*c]const u8, rmtopdir: bool) bool;
pub extern fn getpeereid(sock: c_int, uid: [*c]uid_t, gid: [*c]gid_t) c_int;
pub const float_t = f32;
pub const double_t = f64;
pub extern fn __fpclassify(__value: f64) c_int;
pub extern fn __signbit(__value: f64) c_int;
pub extern fn __isinf(__value: f64) c_int;
pub extern fn __finite(__value: f64) c_int;
pub extern fn __isnan(__value: f64) c_int;
pub extern fn __iseqsig(__x: f64, __y: f64) c_int;
pub extern fn __issignaling(__value: f64) c_int;
pub extern fn acos(__x: f64) f64;
pub extern fn __acos(__x: f64) f64;
pub extern fn asin(__x: f64) f64;
pub extern fn __asin(__x: f64) f64;
pub extern fn atan(__x: f64) f64;
pub extern fn __atan(__x: f64) f64;
pub extern fn atan2(__y: f64, __x: f64) f64;
pub extern fn __atan2(__y: f64, __x: f64) f64;
pub extern fn cos(__x: f64) f64;
pub extern fn __cos(__x: f64) f64;
pub extern fn sin(__x: f64) f64;
pub extern fn __sin(__x: f64) f64;
pub extern fn tan(__x: f64) f64;
pub extern fn __tan(__x: f64) f64;
pub extern fn cosh(__x: f64) f64;
pub extern fn __cosh(__x: f64) f64;
pub extern fn sinh(__x: f64) f64;
pub extern fn __sinh(__x: f64) f64;
pub extern fn tanh(__x: f64) f64;
pub extern fn __tanh(__x: f64) f64;
pub extern fn acosh(__x: f64) f64;
pub extern fn __acosh(__x: f64) f64;
pub extern fn asinh(__x: f64) f64;
pub extern fn __asinh(__x: f64) f64;
pub extern fn atanh(__x: f64) f64;
pub extern fn __atanh(__x: f64) f64;
pub extern fn exp(__x: f64) f64;
pub extern fn __exp(__x: f64) f64;
pub extern fn frexp(__x: f64, __exponent: [*c]c_int) f64;
pub extern fn __frexp(__x: f64, __exponent: [*c]c_int) f64;
pub extern fn ldexp(__x: f64, __exponent: c_int) f64;
pub extern fn __ldexp(__x: f64, __exponent: c_int) f64;
pub extern fn log(__x: f64) f64;
pub extern fn __log(__x: f64) f64;
pub extern fn log10(__x: f64) f64;
pub extern fn __log10(__x: f64) f64;
pub extern fn modf(__x: f64, __iptr: [*c]f64) f64;
pub extern fn __modf(__x: f64, __iptr: [*c]f64) f64;
pub extern fn expm1(__x: f64) f64;
pub extern fn __expm1(__x: f64) f64;
pub extern fn log1p(__x: f64) f64;
pub extern fn __log1p(__x: f64) f64;
pub extern fn logb(__x: f64) f64;
pub extern fn __logb(__x: f64) f64;
pub extern fn exp2(__x: f64) f64;
pub extern fn __exp2(__x: f64) f64;
pub extern fn log2(__x: f64) f64;
pub extern fn __log2(__x: f64) f64;
pub extern fn pow(__x: f64, __y: f64) f64;
pub extern fn __pow(__x: f64, __y: f64) f64;
pub extern fn sqrt(__x: f64) f64;
pub extern fn __sqrt(__x: f64) f64;
pub extern fn hypot(__x: f64, __y: f64) f64;
pub extern fn __hypot(__x: f64, __y: f64) f64;
pub extern fn cbrt(__x: f64) f64;
pub extern fn __cbrt(__x: f64) f64;
pub extern fn ceil(__x: f64) f64;
pub extern fn __ceil(__x: f64) f64;
pub extern fn fabs(__x: f64) f64;
pub extern fn __fabs(__x: f64) f64;
pub extern fn floor(__x: f64) f64;
pub extern fn __floor(__x: f64) f64;
pub extern fn fmod(__x: f64, __y: f64) f64;
pub extern fn __fmod(__x: f64, __y: f64) f64;
pub extern fn isinf(__value: f64) c_int;
pub extern fn finite(__value: f64) c_int;
pub extern fn drem(__x: f64, __y: f64) f64;
pub extern fn __drem(__x: f64, __y: f64) f64;
pub extern fn significand(__x: f64) f64;
pub extern fn __significand(__x: f64) f64;
pub extern fn copysign(__x: f64, __y: f64) f64;
pub extern fn __copysign(__x: f64, __y: f64) f64;
pub extern fn nan(__tagb: [*c]const u8) f64;
pub extern fn __nan(__tagb: [*c]const u8) f64;
pub extern fn isnan(__value: f64) c_int;
pub extern fn j0(f64) f64;
pub extern fn __j0(f64) f64;
pub extern fn j1(f64) f64;
pub extern fn __j1(f64) f64;
pub extern fn jn(c_int, f64) f64;
pub extern fn __jn(c_int, f64) f64;
pub extern fn y0(f64) f64;
pub extern fn __y0(f64) f64;
pub extern fn y1(f64) f64;
pub extern fn __y1(f64) f64;
pub extern fn yn(c_int, f64) f64;
pub extern fn __yn(c_int, f64) f64;
pub extern fn erf(f64) f64;
pub extern fn __erf(f64) f64;
pub extern fn erfc(f64) f64;
pub extern fn __erfc(f64) f64;
pub extern fn lgamma(f64) f64;
pub extern fn __lgamma(f64) f64;
pub extern fn tgamma(f64) f64;
pub extern fn __tgamma(f64) f64;
pub extern fn gamma(f64) f64;
pub extern fn __gamma(f64) f64;
pub extern fn lgamma_r(f64, __signgamp: [*c]c_int) f64;
pub extern fn __lgamma_r(f64, __signgamp: [*c]c_int) f64;
pub extern fn rint(__x: f64) f64;
pub extern fn __rint(__x: f64) f64;
pub extern fn nextafter(__x: f64, __y: f64) f64;
pub extern fn __nextafter(__x: f64, __y: f64) f64;
pub extern fn nexttoward(__x: f64, __y: c_longdouble) f64;
pub extern fn __nexttoward(__x: f64, __y: c_longdouble) f64;
pub extern fn remainder(__x: f64, __y: f64) f64;
pub extern fn __remainder(__x: f64, __y: f64) f64;
pub extern fn scalbn(__x: f64, __n: c_int) f64;
pub extern fn __scalbn(__x: f64, __n: c_int) f64;
pub extern fn ilogb(__x: f64) c_int;
pub extern fn __ilogb(__x: f64) c_int;
pub extern fn scalbln(__x: f64, __n: c_long) f64;
pub extern fn __scalbln(__x: f64, __n: c_long) f64;
pub extern fn nearbyint(__x: f64) f64;
pub extern fn __nearbyint(__x: f64) f64;
pub extern fn round(__x: f64) f64;
pub extern fn __round(__x: f64) f64;
pub extern fn trunc(__x: f64) f64;
pub extern fn __trunc(__x: f64) f64;
pub extern fn remquo(__x: f64, __y: f64, __quo: [*c]c_int) f64;
pub extern fn __remquo(__x: f64, __y: f64, __quo: [*c]c_int) f64;
pub extern fn lrint(__x: f64) c_long;
pub extern fn __lrint(__x: f64) c_long;
pub extern fn llrint(__x: f64) c_longlong;
pub extern fn __llrint(__x: f64) c_longlong;
pub extern fn lround(__x: f64) c_long;
pub extern fn __lround(__x: f64) c_long;
pub extern fn llround(__x: f64) c_longlong;
pub extern fn __llround(__x: f64) c_longlong;
pub extern fn fdim(__x: f64, __y: f64) f64;
pub extern fn __fdim(__x: f64, __y: f64) f64;
pub extern fn fmax(__x: f64, __y: f64) f64;
pub extern fn __fmax(__x: f64, __y: f64) f64;
pub extern fn fmin(__x: f64, __y: f64) f64;
pub extern fn __fmin(__x: f64, __y: f64) f64;
pub extern fn fma(__x: f64, __y: f64, __z: f64) f64;
pub extern fn __fma(__x: f64, __y: f64, __z: f64) f64;
pub extern fn scalb(__x: f64, __n: f64) f64;
pub extern fn __scalb(__x: f64, __n: f64) f64;
pub extern fn __fpclassifyf(__value: f32) c_int;
pub extern fn __signbitf(__value: f32) c_int;
pub extern fn __isinff(__value: f32) c_int;
pub extern fn __finitef(__value: f32) c_int;
pub extern fn __isnanf(__value: f32) c_int;
pub extern fn __iseqsigf(__x: f32, __y: f32) c_int;
pub extern fn __issignalingf(__value: f32) c_int;
pub extern fn acosf(__x: f32) f32;
pub extern fn __acosf(__x: f32) f32;
pub extern fn asinf(__x: f32) f32;
pub extern fn __asinf(__x: f32) f32;
pub extern fn atanf(__x: f32) f32;
pub extern fn __atanf(__x: f32) f32;
pub extern fn atan2f(__y: f32, __x: f32) f32;
pub extern fn __atan2f(__y: f32, __x: f32) f32;
pub extern fn cosf(__x: f32) f32;
pub extern fn __cosf(__x: f32) f32;
pub extern fn sinf(__x: f32) f32;
pub extern fn __sinf(__x: f32) f32;
pub extern fn tanf(__x: f32) f32;
pub extern fn __tanf(__x: f32) f32;
pub extern fn coshf(__x: f32) f32;
pub extern fn __coshf(__x: f32) f32;
pub extern fn sinhf(__x: f32) f32;
pub extern fn __sinhf(__x: f32) f32;
pub extern fn tanhf(__x: f32) f32;
pub extern fn __tanhf(__x: f32) f32;
pub extern fn acoshf(__x: f32) f32;
pub extern fn __acoshf(__x: f32) f32;
pub extern fn asinhf(__x: f32) f32;
pub extern fn __asinhf(__x: f32) f32;
pub extern fn atanhf(__x: f32) f32;
pub extern fn __atanhf(__x: f32) f32;
pub extern fn expf(__x: f32) f32;
pub extern fn __expf(__x: f32) f32;
pub extern fn frexpf(__x: f32, __exponent: [*c]c_int) f32;
pub extern fn __frexpf(__x: f32, __exponent: [*c]c_int) f32;
pub extern fn ldexpf(__x: f32, __exponent: c_int) f32;
pub extern fn __ldexpf(__x: f32, __exponent: c_int) f32;
pub extern fn logf(__x: f32) f32;
pub extern fn __logf(__x: f32) f32;
pub extern fn log10f(__x: f32) f32;
pub extern fn __log10f(__x: f32) f32;
pub extern fn modff(__x: f32, __iptr: [*c]f32) f32;
pub extern fn __modff(__x: f32, __iptr: [*c]f32) f32;
pub extern fn expm1f(__x: f32) f32;
pub extern fn __expm1f(__x: f32) f32;
pub extern fn log1pf(__x: f32) f32;
pub extern fn __log1pf(__x: f32) f32;
pub extern fn logbf(__x: f32) f32;
pub extern fn __logbf(__x: f32) f32;
pub extern fn exp2f(__x: f32) f32;
pub extern fn __exp2f(__x: f32) f32;
pub extern fn log2f(__x: f32) f32;
pub extern fn __log2f(__x: f32) f32;
pub extern fn powf(__x: f32, __y: f32) f32;
pub extern fn __powf(__x: f32, __y: f32) f32;
pub extern fn sqrtf(__x: f32) f32;
pub extern fn __sqrtf(__x: f32) f32;
pub extern fn hypotf(__x: f32, __y: f32) f32;
pub extern fn __hypotf(__x: f32, __y: f32) f32;
pub extern fn cbrtf(__x: f32) f32;
pub extern fn __cbrtf(__x: f32) f32;
pub extern fn ceilf(__x: f32) f32;
pub extern fn __ceilf(__x: f32) f32;
pub extern fn fabsf(__x: f32) f32;
pub extern fn __fabsf(__x: f32) f32;
pub extern fn floorf(__x: f32) f32;
pub extern fn __floorf(__x: f32) f32;
pub extern fn fmodf(__x: f32, __y: f32) f32;
pub extern fn __fmodf(__x: f32, __y: f32) f32;
pub extern fn isinff(__value: f32) c_int;
pub extern fn finitef(__value: f32) c_int;
pub extern fn dremf(__x: f32, __y: f32) f32;
pub extern fn __dremf(__x: f32, __y: f32) f32;
pub extern fn significandf(__x: f32) f32;
pub extern fn __significandf(__x: f32) f32;
pub extern fn copysignf(__x: f32, __y: f32) f32;
pub extern fn __copysignf(__x: f32, __y: f32) f32;
pub extern fn nanf(__tagb: [*c]const u8) f32;
pub extern fn __nanf(__tagb: [*c]const u8) f32;
pub extern fn isnanf(__value: f32) c_int;
pub extern fn j0f(f32) f32;
pub extern fn __j0f(f32) f32;
pub extern fn j1f(f32) f32;
pub extern fn __j1f(f32) f32;
pub extern fn jnf(c_int, f32) f32;
pub extern fn __jnf(c_int, f32) f32;
pub extern fn y0f(f32) f32;
pub extern fn __y0f(f32) f32;
pub extern fn y1f(f32) f32;
pub extern fn __y1f(f32) f32;
pub extern fn ynf(c_int, f32) f32;
pub extern fn __ynf(c_int, f32) f32;
pub extern fn erff(f32) f32;
pub extern fn __erff(f32) f32;
pub extern fn erfcf(f32) f32;
pub extern fn __erfcf(f32) f32;
pub extern fn lgammaf(f32) f32;
pub extern fn __lgammaf(f32) f32;
pub extern fn tgammaf(f32) f32;
pub extern fn __tgammaf(f32) f32;
pub extern fn gammaf(f32) f32;
pub extern fn __gammaf(f32) f32;
pub extern fn lgammaf_r(f32, __signgamp: [*c]c_int) f32;
pub extern fn __lgammaf_r(f32, __signgamp: [*c]c_int) f32;
pub extern fn rintf(__x: f32) f32;
pub extern fn __rintf(__x: f32) f32;
pub extern fn nextafterf(__x: f32, __y: f32) f32;
pub extern fn __nextafterf(__x: f32, __y: f32) f32;
pub extern fn nexttowardf(__x: f32, __y: c_longdouble) f32;
pub extern fn __nexttowardf(__x: f32, __y: c_longdouble) f32;
pub extern fn remainderf(__x: f32, __y: f32) f32;
pub extern fn __remainderf(__x: f32, __y: f32) f32;
pub extern fn scalbnf(__x: f32, __n: c_int) f32;
pub extern fn __scalbnf(__x: f32, __n: c_int) f32;
pub extern fn ilogbf(__x: f32) c_int;
pub extern fn __ilogbf(__x: f32) c_int;
pub extern fn scalblnf(__x: f32, __n: c_long) f32;
pub extern fn __scalblnf(__x: f32, __n: c_long) f32;
pub extern fn nearbyintf(__x: f32) f32;
pub extern fn __nearbyintf(__x: f32) f32;
pub extern fn roundf(__x: f32) f32;
pub extern fn __roundf(__x: f32) f32;
pub extern fn truncf(__x: f32) f32;
pub extern fn __truncf(__x: f32) f32;
pub extern fn remquof(__x: f32, __y: f32, __quo: [*c]c_int) f32;
pub extern fn __remquof(__x: f32, __y: f32, __quo: [*c]c_int) f32;
pub extern fn lrintf(__x: f32) c_long;
pub extern fn __lrintf(__x: f32) c_long;
pub extern fn llrintf(__x: f32) c_longlong;
pub extern fn __llrintf(__x: f32) c_longlong;
pub extern fn lroundf(__x: f32) c_long;
pub extern fn __lroundf(__x: f32) c_long;
pub extern fn llroundf(__x: f32) c_longlong;
pub extern fn __llroundf(__x: f32) c_longlong;
pub extern fn fdimf(__x: f32, __y: f32) f32;
pub extern fn __fdimf(__x: f32, __y: f32) f32;
pub extern fn fmaxf(__x: f32, __y: f32) f32;
pub extern fn __fmaxf(__x: f32, __y: f32) f32;
pub extern fn fminf(__x: f32, __y: f32) f32;
pub extern fn __fminf(__x: f32, __y: f32) f32;
pub extern fn fmaf(__x: f32, __y: f32, __z: f32) f32;
pub extern fn __fmaf(__x: f32, __y: f32, __z: f32) f32;
pub extern fn scalbf(__x: f32, __n: f32) f32;
pub extern fn __scalbf(__x: f32, __n: f32) f32;
pub extern fn __fpclassifyl(__value: c_longdouble) c_int;
pub extern fn __signbitl(__value: c_longdouble) c_int;
pub extern fn __isinfl(__value: c_longdouble) c_int;
pub extern fn __finitel(__value: c_longdouble) c_int;
pub extern fn __isnanl(__value: c_longdouble) c_int;
pub extern fn __iseqsigl(__x: c_longdouble, __y: c_longdouble) c_int;
pub extern fn __issignalingl(__value: c_longdouble) c_int;
pub extern fn acosl(__x: c_longdouble) c_longdouble;
pub extern fn __acosl(__x: c_longdouble) c_longdouble;
pub extern fn asinl(__x: c_longdouble) c_longdouble;
pub extern fn __asinl(__x: c_longdouble) c_longdouble;
pub extern fn atanl(__x: c_longdouble) c_longdouble;
pub extern fn __atanl(__x: c_longdouble) c_longdouble;
pub extern fn atan2l(__y: c_longdouble, __x: c_longdouble) c_longdouble;
pub extern fn __atan2l(__y: c_longdouble, __x: c_longdouble) c_longdouble;
pub extern fn cosl(__x: c_longdouble) c_longdouble;
pub extern fn __cosl(__x: c_longdouble) c_longdouble;
pub extern fn sinl(__x: c_longdouble) c_longdouble;
pub extern fn __sinl(__x: c_longdouble) c_longdouble;
pub extern fn tanl(__x: c_longdouble) c_longdouble;
pub extern fn __tanl(__x: c_longdouble) c_longdouble;
pub extern fn coshl(__x: c_longdouble) c_longdouble;
pub extern fn __coshl(__x: c_longdouble) c_longdouble;
pub extern fn sinhl(__x: c_longdouble) c_longdouble;
pub extern fn __sinhl(__x: c_longdouble) c_longdouble;
pub extern fn tanhl(__x: c_longdouble) c_longdouble;
pub extern fn __tanhl(__x: c_longdouble) c_longdouble;
pub extern fn acoshl(__x: c_longdouble) c_longdouble;
pub extern fn __acoshl(__x: c_longdouble) c_longdouble;
pub extern fn asinhl(__x: c_longdouble) c_longdouble;
pub extern fn __asinhl(__x: c_longdouble) c_longdouble;
pub extern fn atanhl(__x: c_longdouble) c_longdouble;
pub extern fn __atanhl(__x: c_longdouble) c_longdouble;
pub extern fn expl(__x: c_longdouble) c_longdouble;
pub extern fn __expl(__x: c_longdouble) c_longdouble;
pub extern fn frexpl(__x: c_longdouble, __exponent: [*c]c_int) c_longdouble;
pub extern fn __frexpl(__x: c_longdouble, __exponent: [*c]c_int) c_longdouble;
pub extern fn ldexpl(__x: c_longdouble, __exponent: c_int) c_longdouble;
pub extern fn __ldexpl(__x: c_longdouble, __exponent: c_int) c_longdouble;
pub extern fn logl(__x: c_longdouble) c_longdouble;
pub extern fn __logl(__x: c_longdouble) c_longdouble;
pub extern fn log10l(__x: c_longdouble) c_longdouble;
pub extern fn __log10l(__x: c_longdouble) c_longdouble;
pub extern fn modfl(__x: c_longdouble, __iptr: [*c]c_longdouble) c_longdouble;
pub extern fn __modfl(__x: c_longdouble, __iptr: [*c]c_longdouble) c_longdouble;
pub extern fn expm1l(__x: c_longdouble) c_longdouble;
pub extern fn __expm1l(__x: c_longdouble) c_longdouble;
pub extern fn log1pl(__x: c_longdouble) c_longdouble;
pub extern fn __log1pl(__x: c_longdouble) c_longdouble;
pub extern fn logbl(__x: c_longdouble) c_longdouble;
pub extern fn __logbl(__x: c_longdouble) c_longdouble;
pub extern fn exp2l(__x: c_longdouble) c_longdouble;
pub extern fn __exp2l(__x: c_longdouble) c_longdouble;
pub extern fn log2l(__x: c_longdouble) c_longdouble;
pub extern fn __log2l(__x: c_longdouble) c_longdouble;
pub extern fn powl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __powl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn sqrtl(__x: c_longdouble) c_longdouble;
pub extern fn __sqrtl(__x: c_longdouble) c_longdouble;
pub extern fn hypotl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __hypotl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn cbrtl(__x: c_longdouble) c_longdouble;
pub extern fn __cbrtl(__x: c_longdouble) c_longdouble;
pub extern fn ceill(__x: c_longdouble) c_longdouble;
pub extern fn __ceill(__x: c_longdouble) c_longdouble;
pub extern fn fabsl(__x: c_longdouble) c_longdouble;
pub extern fn __fabsl(__x: c_longdouble) c_longdouble;
pub extern fn floorl(__x: c_longdouble) c_longdouble;
pub extern fn __floorl(__x: c_longdouble) c_longdouble;
pub extern fn fmodl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __fmodl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn isinfl(__value: c_longdouble) c_int;
pub extern fn finitel(__value: c_longdouble) c_int;
pub extern fn dreml(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __dreml(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn significandl(__x: c_longdouble) c_longdouble;
pub extern fn __significandl(__x: c_longdouble) c_longdouble;
pub extern fn copysignl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __copysignl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn nanl(__tagb: [*c]const u8) c_longdouble;
pub extern fn __nanl(__tagb: [*c]const u8) c_longdouble;
pub extern fn isnanl(__value: c_longdouble) c_int;
pub extern fn j0l(c_longdouble) c_longdouble;
pub extern fn __j0l(c_longdouble) c_longdouble;
pub extern fn j1l(c_longdouble) c_longdouble;
pub extern fn __j1l(c_longdouble) c_longdouble;
pub extern fn jnl(c_int, c_longdouble) c_longdouble;
pub extern fn __jnl(c_int, c_longdouble) c_longdouble;
pub extern fn y0l(c_longdouble) c_longdouble;
pub extern fn __y0l(c_longdouble) c_longdouble;
pub extern fn y1l(c_longdouble) c_longdouble;
pub extern fn __y1l(c_longdouble) c_longdouble;
pub extern fn ynl(c_int, c_longdouble) c_longdouble;
pub extern fn __ynl(c_int, c_longdouble) c_longdouble;
pub extern fn erfl(c_longdouble) c_longdouble;
pub extern fn __erfl(c_longdouble) c_longdouble;
pub extern fn erfcl(c_longdouble) c_longdouble;
pub extern fn __erfcl(c_longdouble) c_longdouble;
pub extern fn lgammal(c_longdouble) c_longdouble;
pub extern fn __lgammal(c_longdouble) c_longdouble;
pub extern fn tgammal(c_longdouble) c_longdouble;
pub extern fn __tgammal(c_longdouble) c_longdouble;
pub extern fn gammal(c_longdouble) c_longdouble;
pub extern fn __gammal(c_longdouble) c_longdouble;
pub extern fn lgammal_r(c_longdouble, __signgamp: [*c]c_int) c_longdouble;
pub extern fn __lgammal_r(c_longdouble, __signgamp: [*c]c_int) c_longdouble;
pub extern fn rintl(__x: c_longdouble) c_longdouble;
pub extern fn __rintl(__x: c_longdouble) c_longdouble;
pub extern fn nextafterl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __nextafterl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn nexttowardl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __nexttowardl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn remainderl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __remainderl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn scalbnl(__x: c_longdouble, __n: c_int) c_longdouble;
pub extern fn __scalbnl(__x: c_longdouble, __n: c_int) c_longdouble;
pub extern fn ilogbl(__x: c_longdouble) c_int;
pub extern fn __ilogbl(__x: c_longdouble) c_int;
pub extern fn scalblnl(__x: c_longdouble, __n: c_long) c_longdouble;
pub extern fn __scalblnl(__x: c_longdouble, __n: c_long) c_longdouble;
pub extern fn nearbyintl(__x: c_longdouble) c_longdouble;
pub extern fn __nearbyintl(__x: c_longdouble) c_longdouble;
pub extern fn roundl(__x: c_longdouble) c_longdouble;
pub extern fn __roundl(__x: c_longdouble) c_longdouble;
pub extern fn truncl(__x: c_longdouble) c_longdouble;
pub extern fn __truncl(__x: c_longdouble) c_longdouble;
pub extern fn remquol(__x: c_longdouble, __y: c_longdouble, __quo: [*c]c_int) c_longdouble;
pub extern fn __remquol(__x: c_longdouble, __y: c_longdouble, __quo: [*c]c_int) c_longdouble;
pub extern fn lrintl(__x: c_longdouble) c_long;
pub extern fn __lrintl(__x: c_longdouble) c_long;
pub extern fn llrintl(__x: c_longdouble) c_longlong;
pub extern fn __llrintl(__x: c_longdouble) c_longlong;
pub extern fn lroundl(__x: c_longdouble) c_long;
pub extern fn __lroundl(__x: c_longdouble) c_long;
pub extern fn llroundl(__x: c_longdouble) c_longlong;
pub extern fn __llroundl(__x: c_longdouble) c_longlong;
pub extern fn fdiml(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __fdiml(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn fmaxl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __fmaxl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn fminl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn __fminl(__x: c_longdouble, __y: c_longdouble) c_longdouble;
pub extern fn fmal(__x: c_longdouble, __y: c_longdouble, __z: c_longdouble) c_longdouble;
pub extern fn __fmal(__x: c_longdouble, __y: c_longdouble, __z: c_longdouble) c_longdouble;
pub extern fn scalbl(__x: c_longdouble, __n: c_longdouble) c_longdouble;
pub extern fn __scalbl(__x: c_longdouble, __n: c_longdouble) c_longdouble;
pub extern var signgam: c_int;
pub const FP_NAN: c_int = 0;
pub const FP_INFINITE: c_int = 1;
pub const FP_ZERO: c_int = 2;
pub const FP_SUBNORMAL: c_int = 3;
pub const FP_NORMAL: c_int = 4;
const enum_unnamed_4 = c_uint;
pub extern fn strlcat(dst: [*c]u8, src: [*c]const u8, siz: c_ulong) c_ulong;
pub extern fn strlcpy(dst: [*c]u8, src: [*c]const u8, siz: c_ulong) c_ulong;
pub extern fn pg_get_user_name(user_id: uid_t, buffer: [*c]u8, buflen: usize) bool;
pub extern fn pg_get_user_home_dir(user_id: uid_t, buffer: [*c]u8, buflen: usize) bool;
pub extern fn pg_qsort(base: ?*anyopaque, nel: usize, elsize: usize, cmp: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.C) c_int) void;
pub extern fn pg_qsort_strcmp(a: ?*const anyopaque, b: ?*const anyopaque) c_int;
pub const qsort_arg_comparator = ?*const fn (?*const anyopaque, ?*const anyopaque, ?*anyopaque) callconv(.C) c_int;
pub extern fn qsort_arg(base: ?*anyopaque, nel: usize, elsize: usize, cmp: qsort_arg_comparator, arg: ?*anyopaque) void;
pub extern fn qsort_interruptible(base: ?*anyopaque, nel: usize, elsize: usize, cmp: qsort_arg_comparator, arg: ?*anyopaque) void;
pub extern fn bsearch_arg(key: ?*const anyopaque, base0: ?*const anyopaque, nmemb: usize, size: usize, compar: ?*const fn (?*const anyopaque, ?*const anyopaque, ?*anyopaque) callconv(.C) c_int, arg: ?*anyopaque) ?*anyopaque;
pub extern fn pg_get_encoding_from_locale(ctype: [*c]const u8, write_message: bool) c_int;
pub extern fn pg_inet_net_ntop(af: c_int, src: ?*const anyopaque, bits: c_int, dst: [*c]u8, size: usize) [*c]u8;
pub extern fn pg_strong_random_init() void;
pub extern fn pg_strong_random(buf: ?*anyopaque, len: usize) bool;
pub extern fn pg_check_dir(dir: [*c]const u8) c_int;
pub extern fn pg_mkdir_p(path: [*c]u8, omode: c_int) c_int;
pub const pqsigfunc = ?*const fn (c_int) callconv(.C) void;
pub extern fn pqsignal(signo: c_int, func: pqsigfunc) pqsigfunc;
pub extern fn escape_single_quotes_ascii(src: [*c]const u8) [*c]u8;
pub extern fn wait_result_to_str(exitstatus: c_int) [*c]u8;
pub extern fn wait_result_is_signal(exit_status: c_int, signum: c_int) bool;
pub extern fn wait_result_is_any_signal(exit_status: c_int, include_command_not_found: bool) bool;
pub extern fn wait_result_to_exit_code(exit_status: c_int) c_int;
pub const __jmp_buf = [8]c_long;
pub const struct___jmp_buf_tag = extern struct {
    __jmpbuf: __jmp_buf,
    __mask_was_saved: c_int,
    __saved_mask: __sigset_t,
};
pub const jmp_buf = [1]struct___jmp_buf_tag;
pub extern fn setjmp(__env: [*c]struct___jmp_buf_tag) c_int;
pub extern fn __sigsetjmp(__env: [*c]struct___jmp_buf_tag, __savemask: c_int) c_int;
pub extern fn _setjmp(__env: [*c]struct___jmp_buf_tag) c_int;
pub extern fn longjmp(__env: [*c]struct___jmp_buf_tag, __val: c_int) noreturn;
pub extern fn _longjmp(__env: [*c]struct___jmp_buf_tag, __val: c_int) noreturn;
pub const sigjmp_buf = [1]struct___jmp_buf_tag;
pub extern fn siglongjmp(__env: [*c]struct___jmp_buf_tag, __val: c_int) noreturn;
pub const struct_StringInfoData = extern struct {
    data: [*c]u8,
    len: c_int,
    maxlen: c_int,
    cursor: c_int,
};
pub const StringInfoData = struct_StringInfoData;
pub const StringInfo = [*c]StringInfoData;
pub extern fn makeStringInfo() StringInfo;
pub extern fn initStringInfo(str: StringInfo) void;
pub extern fn resetStringInfo(str: StringInfo) void;
pub extern fn appendStringInfo(str: StringInfo, fmt: [*c]const u8, ...) void;
pub extern fn appendStringInfoVA(str: StringInfo, fmt: [*c]const u8, args: [*c]struct___va_list_tag) c_int;
pub extern fn appendStringInfoString(str: StringInfo, s: [*c]const u8) void;
pub extern fn appendStringInfoChar(str: StringInfo, ch: u8) void;
pub extern fn appendStringInfoSpaces(str: StringInfo, count: c_int) void;
pub extern fn appendBinaryStringInfo(str: StringInfo, data: ?*const anyopaque, datalen: c_int) void;
pub extern fn appendBinaryStringInfoNT(str: StringInfo, data: ?*const anyopaque, datalen: c_int) void;
pub extern fn enlargeStringInfo(str: StringInfo, needed: c_int) void;
pub const T_Invalid: c_int = 0;
pub const T_List: c_int = 1;
pub const T_Alias: c_int = 2;
pub const T_RangeVar: c_int = 3;
pub const T_TableFunc: c_int = 4;
pub const T_IntoClause: c_int = 5;
pub const T_Var: c_int = 6;
pub const T_Const: c_int = 7;
pub const T_Param: c_int = 8;
pub const T_Aggref: c_int = 9;
pub const T_GroupingFunc: c_int = 10;
pub const T_WindowFunc: c_int = 11;
pub const T_SubscriptingRef: c_int = 12;
pub const T_FuncExpr: c_int = 13;
pub const T_NamedArgExpr: c_int = 14;
pub const T_OpExpr: c_int = 15;
pub const T_DistinctExpr: c_int = 16;
pub const T_NullIfExpr: c_int = 17;
pub const T_ScalarArrayOpExpr: c_int = 18;
pub const T_BoolExpr: c_int = 19;
pub const T_SubLink: c_int = 20;
pub const T_SubPlan: c_int = 21;
pub const T_AlternativeSubPlan: c_int = 22;
pub const T_FieldSelect: c_int = 23;
pub const T_FieldStore: c_int = 24;
pub const T_RelabelType: c_int = 25;
pub const T_CoerceViaIO: c_int = 26;
pub const T_ArrayCoerceExpr: c_int = 27;
pub const T_ConvertRowtypeExpr: c_int = 28;
pub const T_CollateExpr: c_int = 29;
pub const T_CaseExpr: c_int = 30;
pub const T_CaseWhen: c_int = 31;
pub const T_CaseTestExpr: c_int = 32;
pub const T_ArrayExpr: c_int = 33;
pub const T_RowExpr: c_int = 34;
pub const T_RowCompareExpr: c_int = 35;
pub const T_CoalesceExpr: c_int = 36;
pub const T_MinMaxExpr: c_int = 37;
pub const T_SQLValueFunction: c_int = 38;
pub const T_XmlExpr: c_int = 39;
pub const T_JsonFormat: c_int = 40;
pub const T_JsonReturning: c_int = 41;
pub const T_JsonValueExpr: c_int = 42;
pub const T_JsonConstructorExpr: c_int = 43;
pub const T_JsonIsPredicate: c_int = 44;
pub const T_NullTest: c_int = 45;
pub const T_BooleanTest: c_int = 46;
pub const T_CoerceToDomain: c_int = 47;
pub const T_CoerceToDomainValue: c_int = 48;
pub const T_SetToDefault: c_int = 49;
pub const T_CurrentOfExpr: c_int = 50;
pub const T_NextValueExpr: c_int = 51;
pub const T_InferenceElem: c_int = 52;
pub const T_TargetEntry: c_int = 53;
pub const T_RangeTblRef: c_int = 54;
pub const T_JoinExpr: c_int = 55;
pub const T_FromExpr: c_int = 56;
pub const T_OnConflictExpr: c_int = 57;
pub const T_Query: c_int = 58;
pub const T_TypeName: c_int = 59;
pub const T_ColumnRef: c_int = 60;
pub const T_ParamRef: c_int = 61;
pub const T_A_Expr: c_int = 62;
pub const T_A_Const: c_int = 63;
pub const T_TypeCast: c_int = 64;
pub const T_CollateClause: c_int = 65;
pub const T_RoleSpec: c_int = 66;
pub const T_FuncCall: c_int = 67;
pub const T_A_Star: c_int = 68;
pub const T_A_Indices: c_int = 69;
pub const T_A_Indirection: c_int = 70;
pub const T_A_ArrayExpr: c_int = 71;
pub const T_ResTarget: c_int = 72;
pub const T_MultiAssignRef: c_int = 73;
pub const T_SortBy: c_int = 74;
pub const T_WindowDef: c_int = 75;
pub const T_RangeSubselect: c_int = 76;
pub const T_RangeFunction: c_int = 77;
pub const T_RangeTableFunc: c_int = 78;
pub const T_RangeTableFuncCol: c_int = 79;
pub const T_RangeTableSample: c_int = 80;
pub const T_ColumnDef: c_int = 81;
pub const T_TableLikeClause: c_int = 82;
pub const T_IndexElem: c_int = 83;
pub const T_DefElem: c_int = 84;
pub const T_LockingClause: c_int = 85;
pub const T_XmlSerialize: c_int = 86;
pub const T_PartitionElem: c_int = 87;
pub const T_PartitionSpec: c_int = 88;
pub const T_PartitionBoundSpec: c_int = 89;
pub const T_PartitionRangeDatum: c_int = 90;
pub const T_PartitionCmd: c_int = 91;
pub const T_RangeTblEntry: c_int = 92;
pub const T_RTEPermissionInfo: c_int = 93;
pub const T_RangeTblFunction: c_int = 94;
pub const T_TableSampleClause: c_int = 95;
pub const T_WithCheckOption: c_int = 96;
pub const T_SortGroupClause: c_int = 97;
pub const T_GroupingSet: c_int = 98;
pub const T_WindowClause: c_int = 99;
pub const T_RowMarkClause: c_int = 100;
pub const T_WithClause: c_int = 101;
pub const T_InferClause: c_int = 102;
pub const T_OnConflictClause: c_int = 103;
pub const T_CTESearchClause: c_int = 104;
pub const T_CTECycleClause: c_int = 105;
pub const T_CommonTableExpr: c_int = 106;
pub const T_MergeWhenClause: c_int = 107;
pub const T_MergeAction: c_int = 108;
pub const T_TriggerTransition: c_int = 109;
pub const T_JsonOutput: c_int = 110;
pub const T_JsonKeyValue: c_int = 111;
pub const T_JsonObjectConstructor: c_int = 112;
pub const T_JsonArrayConstructor: c_int = 113;
pub const T_JsonArrayQueryConstructor: c_int = 114;
pub const T_JsonAggConstructor: c_int = 115;
pub const T_JsonObjectAgg: c_int = 116;
pub const T_JsonArrayAgg: c_int = 117;
pub const T_RawStmt: c_int = 118;
pub const T_InsertStmt: c_int = 119;
pub const T_DeleteStmt: c_int = 120;
pub const T_UpdateStmt: c_int = 121;
pub const T_MergeStmt: c_int = 122;
pub const T_SelectStmt: c_int = 123;
pub const T_SetOperationStmt: c_int = 124;
pub const T_ReturnStmt: c_int = 125;
pub const T_PLAssignStmt: c_int = 126;
pub const T_CreateSchemaStmt: c_int = 127;
pub const T_AlterTableStmt: c_int = 128;
pub const T_ReplicaIdentityStmt: c_int = 129;
pub const T_AlterTableCmd: c_int = 130;
pub const T_AlterCollationStmt: c_int = 131;
pub const T_AlterDomainStmt: c_int = 132;
pub const T_GrantStmt: c_int = 133;
pub const T_ObjectWithArgs: c_int = 134;
pub const T_AccessPriv: c_int = 135;
pub const T_GrantRoleStmt: c_int = 136;
pub const T_AlterDefaultPrivilegesStmt: c_int = 137;
pub const T_CopyStmt: c_int = 138;
pub const T_VariableSetStmt: c_int = 139;
pub const T_VariableShowStmt: c_int = 140;
pub const T_CreateStmt: c_int = 141;
pub const T_Constraint: c_int = 142;
pub const T_CreateTableSpaceStmt: c_int = 143;
pub const T_DropTableSpaceStmt: c_int = 144;
pub const T_AlterTableSpaceOptionsStmt: c_int = 145;
pub const T_AlterTableMoveAllStmt: c_int = 146;
pub const T_CreateExtensionStmt: c_int = 147;
pub const T_AlterExtensionStmt: c_int = 148;
pub const T_AlterExtensionContentsStmt: c_int = 149;
pub const T_CreateFdwStmt: c_int = 150;
pub const T_AlterFdwStmt: c_int = 151;
pub const T_CreateForeignServerStmt: c_int = 152;
pub const T_AlterForeignServerStmt: c_int = 153;
pub const T_CreateForeignTableStmt: c_int = 154;
pub const T_CreateUserMappingStmt: c_int = 155;
pub const T_AlterUserMappingStmt: c_int = 156;
pub const T_DropUserMappingStmt: c_int = 157;
pub const T_ImportForeignSchemaStmt: c_int = 158;
pub const T_CreatePolicyStmt: c_int = 159;
pub const T_AlterPolicyStmt: c_int = 160;
pub const T_CreateAmStmt: c_int = 161;
pub const T_CreateTrigStmt: c_int = 162;
pub const T_CreateEventTrigStmt: c_int = 163;
pub const T_AlterEventTrigStmt: c_int = 164;
pub const T_CreatePLangStmt: c_int = 165;
pub const T_CreateRoleStmt: c_int = 166;
pub const T_AlterRoleStmt: c_int = 167;
pub const T_AlterRoleSetStmt: c_int = 168;
pub const T_DropRoleStmt: c_int = 169;
pub const T_CreateSeqStmt: c_int = 170;
pub const T_AlterSeqStmt: c_int = 171;
pub const T_DefineStmt: c_int = 172;
pub const T_CreateDomainStmt: c_int = 173;
pub const T_CreateOpClassStmt: c_int = 174;
pub const T_CreateOpClassItem: c_int = 175;
pub const T_CreateOpFamilyStmt: c_int = 176;
pub const T_AlterOpFamilyStmt: c_int = 177;
pub const T_DropStmt: c_int = 178;
pub const T_TruncateStmt: c_int = 179;
pub const T_CommentStmt: c_int = 180;
pub const T_SecLabelStmt: c_int = 181;
pub const T_DeclareCursorStmt: c_int = 182;
pub const T_ClosePortalStmt: c_int = 183;
pub const T_FetchStmt: c_int = 184;
pub const T_IndexStmt: c_int = 185;
pub const T_CreateStatsStmt: c_int = 186;
pub const T_StatsElem: c_int = 187;
pub const T_AlterStatsStmt: c_int = 188;
pub const T_CreateFunctionStmt: c_int = 189;
pub const T_FunctionParameter: c_int = 190;
pub const T_AlterFunctionStmt: c_int = 191;
pub const T_DoStmt: c_int = 192;
pub const T_InlineCodeBlock: c_int = 193;
pub const T_CallStmt: c_int = 194;
pub const T_CallContext: c_int = 195;
pub const T_RenameStmt: c_int = 196;
pub const T_AlterObjectDependsStmt: c_int = 197;
pub const T_AlterObjectSchemaStmt: c_int = 198;
pub const T_AlterOwnerStmt: c_int = 199;
pub const T_AlterOperatorStmt: c_int = 200;
pub const T_AlterTypeStmt: c_int = 201;
pub const T_RuleStmt: c_int = 202;
pub const T_NotifyStmt: c_int = 203;
pub const T_ListenStmt: c_int = 204;
pub const T_UnlistenStmt: c_int = 205;
pub const T_TransactionStmt: c_int = 206;
pub const T_CompositeTypeStmt: c_int = 207;
pub const T_CreateEnumStmt: c_int = 208;
pub const T_CreateRangeStmt: c_int = 209;
pub const T_AlterEnumStmt: c_int = 210;
pub const T_ViewStmt: c_int = 211;
pub const T_LoadStmt: c_int = 212;
pub const T_CreatedbStmt: c_int = 213;
pub const T_AlterDatabaseStmt: c_int = 214;
pub const T_AlterDatabaseRefreshCollStmt: c_int = 215;
pub const T_AlterDatabaseSetStmt: c_int = 216;
pub const T_DropdbStmt: c_int = 217;
pub const T_AlterSystemStmt: c_int = 218;
pub const T_ClusterStmt: c_int = 219;
pub const T_VacuumStmt: c_int = 220;
pub const T_VacuumRelation: c_int = 221;
pub const T_ExplainStmt: c_int = 222;
pub const T_CreateTableAsStmt: c_int = 223;
pub const T_RefreshMatViewStmt: c_int = 224;
pub const T_CheckPointStmt: c_int = 225;
pub const T_DiscardStmt: c_int = 226;
pub const T_LockStmt: c_int = 227;
pub const T_ConstraintsSetStmt: c_int = 228;
pub const T_ReindexStmt: c_int = 229;
pub const T_CreateConversionStmt: c_int = 230;
pub const T_CreateCastStmt: c_int = 231;
pub const T_CreateTransformStmt: c_int = 232;
pub const T_PrepareStmt: c_int = 233;
pub const T_ExecuteStmt: c_int = 234;
pub const T_DeallocateStmt: c_int = 235;
pub const T_DropOwnedStmt: c_int = 236;
pub const T_ReassignOwnedStmt: c_int = 237;
pub const T_AlterTSDictionaryStmt: c_int = 238;
pub const T_AlterTSConfigurationStmt: c_int = 239;
pub const T_PublicationTable: c_int = 240;
pub const T_PublicationObjSpec: c_int = 241;
pub const T_CreatePublicationStmt: c_int = 242;
pub const T_AlterPublicationStmt: c_int = 243;
pub const T_CreateSubscriptionStmt: c_int = 244;
pub const T_AlterSubscriptionStmt: c_int = 245;
pub const T_DropSubscriptionStmt: c_int = 246;
pub const T_PlannerGlobal: c_int = 247;
pub const T_PlannerInfo: c_int = 248;
pub const T_RelOptInfo: c_int = 249;
pub const T_IndexOptInfo: c_int = 250;
pub const T_ForeignKeyOptInfo: c_int = 251;
pub const T_StatisticExtInfo: c_int = 252;
pub const T_JoinDomain: c_int = 253;
pub const T_EquivalenceClass: c_int = 254;
pub const T_EquivalenceMember: c_int = 255;
pub const T_PathKey: c_int = 256;
pub const T_PathTarget: c_int = 257;
pub const T_ParamPathInfo: c_int = 258;
pub const T_Path: c_int = 259;
pub const T_IndexPath: c_int = 260;
pub const T_IndexClause: c_int = 261;
pub const T_BitmapHeapPath: c_int = 262;
pub const T_BitmapAndPath: c_int = 263;
pub const T_BitmapOrPath: c_int = 264;
pub const T_TidPath: c_int = 265;
pub const T_TidRangePath: c_int = 266;
pub const T_SubqueryScanPath: c_int = 267;
pub const T_ForeignPath: c_int = 268;
pub const T_CustomPath: c_int = 269;
pub const T_AppendPath: c_int = 270;
pub const T_MergeAppendPath: c_int = 271;
pub const T_GroupResultPath: c_int = 272;
pub const T_MaterialPath: c_int = 273;
pub const T_MemoizePath: c_int = 274;
pub const T_UniquePath: c_int = 275;
pub const T_GatherPath: c_int = 276;
pub const T_GatherMergePath: c_int = 277;
pub const T_NestPath: c_int = 278;
pub const T_MergePath: c_int = 279;
pub const T_HashPath: c_int = 280;
pub const T_ProjectionPath: c_int = 281;
pub const T_ProjectSetPath: c_int = 282;
pub const T_SortPath: c_int = 283;
pub const T_IncrementalSortPath: c_int = 284;
pub const T_GroupPath: c_int = 285;
pub const T_UpperUniquePath: c_int = 286;
pub const T_AggPath: c_int = 287;
pub const T_GroupingSetData: c_int = 288;
pub const T_RollupData: c_int = 289;
pub const T_GroupingSetsPath: c_int = 290;
pub const T_MinMaxAggPath: c_int = 291;
pub const T_WindowAggPath: c_int = 292;
pub const T_SetOpPath: c_int = 293;
pub const T_RecursiveUnionPath: c_int = 294;
pub const T_LockRowsPath: c_int = 295;
pub const T_ModifyTablePath: c_int = 296;
pub const T_LimitPath: c_int = 297;
pub const T_RestrictInfo: c_int = 298;
pub const T_PlaceHolderVar: c_int = 299;
pub const T_SpecialJoinInfo: c_int = 300;
pub const T_OuterJoinClauseInfo: c_int = 301;
pub const T_AppendRelInfo: c_int = 302;
pub const T_RowIdentityVarInfo: c_int = 303;
pub const T_PlaceHolderInfo: c_int = 304;
pub const T_MinMaxAggInfo: c_int = 305;
pub const T_PlannerParamItem: c_int = 306;
pub const T_AggInfo: c_int = 307;
pub const T_AggTransInfo: c_int = 308;
pub const T_PlannedStmt: c_int = 309;
pub const T_Result: c_int = 310;
pub const T_ProjectSet: c_int = 311;
pub const T_ModifyTable: c_int = 312;
pub const T_Append: c_int = 313;
pub const T_MergeAppend: c_int = 314;
pub const T_RecursiveUnion: c_int = 315;
pub const T_BitmapAnd: c_int = 316;
pub const T_BitmapOr: c_int = 317;
pub const T_SeqScan: c_int = 318;
pub const T_SampleScan: c_int = 319;
pub const T_IndexScan: c_int = 320;
pub const T_IndexOnlyScan: c_int = 321;
pub const T_BitmapIndexScan: c_int = 322;
pub const T_BitmapHeapScan: c_int = 323;
pub const T_TidScan: c_int = 324;
pub const T_TidRangeScan: c_int = 325;
pub const T_SubqueryScan: c_int = 326;
pub const T_FunctionScan: c_int = 327;
pub const T_ValuesScan: c_int = 328;
pub const T_TableFuncScan: c_int = 329;
pub const T_CteScan: c_int = 330;
pub const T_NamedTuplestoreScan: c_int = 331;
pub const T_WorkTableScan: c_int = 332;
pub const T_ForeignScan: c_int = 333;
pub const T_CustomScan: c_int = 334;
pub const T_NestLoop: c_int = 335;
pub const T_NestLoopParam: c_int = 336;
pub const T_MergeJoin: c_int = 337;
pub const T_HashJoin: c_int = 338;
pub const T_Material: c_int = 339;
pub const T_Memoize: c_int = 340;
pub const T_Sort: c_int = 341;
pub const T_IncrementalSort: c_int = 342;
pub const T_Group: c_int = 343;
pub const T_Agg: c_int = 344;
pub const T_WindowAgg: c_int = 345;
pub const T_Unique: c_int = 346;
pub const T_Gather: c_int = 347;
pub const T_GatherMerge: c_int = 348;
pub const T_Hash: c_int = 349;
pub const T_SetOp: c_int = 350;
pub const T_LockRows: c_int = 351;
pub const T_Limit: c_int = 352;
pub const T_PlanRowMark: c_int = 353;
pub const T_PartitionPruneInfo: c_int = 354;
pub const T_PartitionedRelPruneInfo: c_int = 355;
pub const T_PartitionPruneStepOp: c_int = 356;
pub const T_PartitionPruneStepCombine: c_int = 357;
pub const T_PlanInvalItem: c_int = 358;
pub const T_ExprState: c_int = 359;
pub const T_IndexInfo: c_int = 360;
pub const T_ExprContext: c_int = 361;
pub const T_ReturnSetInfo: c_int = 362;
pub const T_ProjectionInfo: c_int = 363;
pub const T_JunkFilter: c_int = 364;
pub const T_OnConflictSetState: c_int = 365;
pub const T_MergeActionState: c_int = 366;
pub const T_ResultRelInfo: c_int = 367;
pub const T_EState: c_int = 368;
pub const T_WindowFuncExprState: c_int = 369;
pub const T_SetExprState: c_int = 370;
pub const T_SubPlanState: c_int = 371;
pub const T_DomainConstraintState: c_int = 372;
pub const T_ResultState: c_int = 373;
pub const T_ProjectSetState: c_int = 374;
pub const T_ModifyTableState: c_int = 375;
pub const T_AppendState: c_int = 376;
pub const T_MergeAppendState: c_int = 377;
pub const T_RecursiveUnionState: c_int = 378;
pub const T_BitmapAndState: c_int = 379;
pub const T_BitmapOrState: c_int = 380;
pub const T_ScanState: c_int = 381;
pub const T_SeqScanState: c_int = 382;
pub const T_SampleScanState: c_int = 383;
pub const T_IndexScanState: c_int = 384;
pub const T_IndexOnlyScanState: c_int = 385;
pub const T_BitmapIndexScanState: c_int = 386;
pub const T_BitmapHeapScanState: c_int = 387;
pub const T_TidScanState: c_int = 388;
pub const T_TidRangeScanState: c_int = 389;
pub const T_SubqueryScanState: c_int = 390;
pub const T_FunctionScanState: c_int = 391;
pub const T_ValuesScanState: c_int = 392;
pub const T_TableFuncScanState: c_int = 393;
pub const T_CteScanState: c_int = 394;
pub const T_NamedTuplestoreScanState: c_int = 395;
pub const T_WorkTableScanState: c_int = 396;
pub const T_ForeignScanState: c_int = 397;
pub const T_CustomScanState: c_int = 398;
pub const T_JoinState: c_int = 399;
pub const T_NestLoopState: c_int = 400;
pub const T_MergeJoinState: c_int = 401;
pub const T_HashJoinState: c_int = 402;
pub const T_MaterialState: c_int = 403;
pub const T_MemoizeState: c_int = 404;
pub const T_SortState: c_int = 405;
pub const T_IncrementalSortState: c_int = 406;
pub const T_GroupState: c_int = 407;
pub const T_AggState: c_int = 408;
pub const T_WindowAggState: c_int = 409;
pub const T_UniqueState: c_int = 410;
pub const T_GatherState: c_int = 411;
pub const T_GatherMergeState: c_int = 412;
pub const T_HashState: c_int = 413;
pub const T_SetOpState: c_int = 414;
pub const T_LockRowsState: c_int = 415;
pub const T_LimitState: c_int = 416;
pub const T_IndexAmRoutine: c_int = 417;
pub const T_TableAmRoutine: c_int = 418;
pub const T_TsmRoutine: c_int = 419;
pub const T_EventTriggerData: c_int = 420;
pub const T_TriggerData: c_int = 421;
pub const T_TupleTableSlot: c_int = 422;
pub const T_FdwRoutine: c_int = 423;
pub const T_Bitmapset: c_int = 424;
pub const T_ExtensibleNode: c_int = 425;
pub const T_ErrorSaveContext: c_int = 426;
pub const T_IdentifySystemCmd: c_int = 427;
pub const T_BaseBackupCmd: c_int = 428;
pub const T_CreateReplicationSlotCmd: c_int = 429;
pub const T_DropReplicationSlotCmd: c_int = 430;
pub const T_StartReplicationCmd: c_int = 431;
pub const T_ReadReplicationSlotCmd: c_int = 432;
pub const T_TimeLineHistoryCmd: c_int = 433;
pub const T_SupportRequestSimplify: c_int = 434;
pub const T_SupportRequestSelectivity: c_int = 435;
pub const T_SupportRequestCost: c_int = 436;
pub const T_SupportRequestRows: c_int = 437;
pub const T_SupportRequestIndexCondition: c_int = 438;
pub const T_SupportRequestWFuncMonotonic: c_int = 439;
pub const T_SupportRequestOptimizeWindowClause: c_int = 440;
pub const T_Integer: c_int = 441;
pub const T_Float: c_int = 442;
pub const T_Boolean: c_int = 443;
pub const T_String: c_int = 444;
pub const T_BitString: c_int = 445;
pub const T_ForeignKeyCacheInfo: c_int = 446;
pub const T_IntList: c_int = 447;
pub const T_OidList: c_int = 448;
pub const T_XidList: c_int = 449;
pub const T_AllocSetContext: c_int = 450;
pub const T_GenerationContext: c_int = 451;
pub const T_SlabContext: c_int = 452;
pub const T_TIDBitmap: c_int = 453;
pub const T_WindowObjectData: c_int = 454;
pub const enum_NodeTag = c_uint;
pub const NodeTag = enum_NodeTag;
pub const struct_Node = extern struct {
    type: NodeTag,
};
pub extern fn message_level_is_interesting(elevel: c_int) bool;
pub extern fn errstart(elevel: c_int, domain: [*c]const u8) bool;
pub extern fn errstart_cold(elevel: c_int, domain: [*c]const u8) bool;
pub extern fn errfinish(filename: [*c]const u8, lineno: c_int, funcname: [*c]const u8) void;
pub extern fn errcode(sqlerrcode: c_int) c_int;
pub extern fn errcode_for_file_access() c_int;
pub extern fn errcode_for_socket_access() c_int;
pub extern fn errmsg(fmt: [*c]const u8, ...) c_int;
pub extern fn errmsg_internal(fmt: [*c]const u8, ...) c_int;
pub extern fn errmsg_plural(fmt_singular: [*c]const u8, fmt_plural: [*c]const u8, n: c_ulong, ...) c_int;
pub extern fn errdetail(fmt: [*c]const u8, ...) c_int;
pub extern fn errdetail_internal(fmt: [*c]const u8, ...) c_int;
pub extern fn errdetail_log(fmt: [*c]const u8, ...) c_int;
pub extern fn errdetail_log_plural(fmt_singular: [*c]const u8, fmt_plural: [*c]const u8, n: c_ulong, ...) c_int;
pub extern fn errdetail_plural(fmt_singular: [*c]const u8, fmt_plural: [*c]const u8, n: c_ulong, ...) c_int;
pub extern fn errhint(fmt: [*c]const u8, ...) c_int;
pub extern fn errhint_plural(fmt_singular: [*c]const u8, fmt_plural: [*c]const u8, n: c_ulong, ...) c_int;
pub extern fn set_errcontext_domain(domain: [*c]const u8) c_int;
pub extern fn errcontext_msg(fmt: [*c]const u8, ...) c_int;
pub extern fn errhidestmt(hide_stmt: bool) c_int;
pub extern fn errhidecontext(hide_ctx: bool) c_int;
pub extern fn errbacktrace() c_int;
pub extern fn errposition(cursorpos: c_int) c_int;
pub extern fn internalerrposition(cursorpos: c_int) c_int;
pub extern fn internalerrquery(query: [*c]const u8) c_int;
pub extern fn err_generic_string(field: c_int, str: [*c]const u8) c_int;
pub extern fn geterrcode() c_int;
pub extern fn geterrposition() c_int;
pub extern fn getinternalerrposition() c_int;
pub extern fn errsave_start(context: [*c]struct_Node, domain: [*c]const u8) bool;
pub extern fn errsave_finish(context: [*c]struct_Node, filename: [*c]const u8, lineno: c_int, funcname: [*c]const u8) void;
pub extern fn pre_format_elog_string(errnumber: c_int, domain: [*c]const u8) void;
pub extern fn format_elog_string(fmt: [*c]const u8, ...) [*c]u8;
pub const struct_ErrorContextCallback = extern struct {
    previous: [*c]struct_ErrorContextCallback,
    callback: ?*const fn (?*anyopaque) callconv(.C) void,
    arg: ?*anyopaque,
};
pub const ErrorContextCallback = struct_ErrorContextCallback;
pub extern var error_context_stack: [*c]ErrorContextCallback;
pub extern var PG_exception_stack: [*c]sigjmp_buf;
pub const MemoryContext = [*c]struct_MemoryContextData;
pub const MemoryStatsPrintFunc = ?*const fn (MemoryContext, ?*anyopaque, [*c]const u8, bool) callconv(.C) void;
pub const struct_MemoryContextCounters = extern struct {
    nblocks: Size,
    freechunks: Size,
    totalspace: Size,
    freespace: Size,
};
pub const MemoryContextCounters = struct_MemoryContextCounters;
pub const struct_MemoryContextMethods = extern struct {
    alloc: ?*const fn (MemoryContext, Size) callconv(.C) ?*anyopaque,
    free_p: ?*const fn (?*anyopaque) callconv(.C) void,
    realloc: ?*const fn (?*anyopaque, Size) callconv(.C) ?*anyopaque,
    reset: ?*const fn (MemoryContext) callconv(.C) void,
    delete_context: ?*const fn (MemoryContext) callconv(.C) void,
    get_chunk_context: ?*const fn (?*anyopaque) callconv(.C) MemoryContext,
    get_chunk_space: ?*const fn (?*anyopaque) callconv(.C) Size,
    is_empty: ?*const fn (MemoryContext) callconv(.C) bool,
    stats: ?*const fn (MemoryContext, MemoryStatsPrintFunc, ?*anyopaque, [*c]MemoryContextCounters, bool) callconv(.C) void,
};
pub const MemoryContextMethods = struct_MemoryContextMethods;
pub const MemoryContextCallbackFunction = ?*const fn (?*anyopaque) callconv(.C) void;
pub const struct_MemoryContextCallback = extern struct {
    func: MemoryContextCallbackFunction,
    arg: ?*anyopaque,
    next: [*c]struct_MemoryContextCallback,
};
pub const MemoryContextCallback = struct_MemoryContextCallback;
pub const struct_MemoryContextData = extern struct {
    type: NodeTag,
    isReset: bool,
    allowInCritSection: bool,
    mem_allocated: Size,
    methods: [*c]const MemoryContextMethods,
    parent: MemoryContext,
    firstchild: MemoryContext,
    prevchild: MemoryContext,
    nextchild: MemoryContext,
    name: [*c]const u8,
    ident: [*c]const u8,
    reset_cbs: [*c]MemoryContextCallback,
};
pub const struct_ErrorData = extern struct {
    elevel: c_int,
    output_to_server: bool,
    output_to_client: bool,
    hide_stmt: bool,
    hide_ctx: bool,
    filename: [*c]const u8,
    lineno: c_int,
    funcname: [*c]const u8,
    domain: [*c]const u8,
    context_domain: [*c]const u8,
    sqlerrcode: c_int,
    message: [*c]u8,
    detail: [*c]u8,
    detail_log: [*c]u8,
    hint: [*c]u8,
    context: [*c]u8,
    backtrace: [*c]u8,
    message_id: [*c]const u8,
    schema_name: [*c]u8,
    table_name: [*c]u8,
    column_name: [*c]u8,
    datatype_name: [*c]u8,
    constraint_name: [*c]u8,
    cursorpos: c_int,
    internalpos: c_int,
    internalquery: [*c]u8,
    saved_errno: c_int,
    assoc_context: [*c]struct_MemoryContextData,
};
pub const ErrorData = struct_ErrorData;
pub extern fn EmitErrorReport() void;
pub extern fn CopyErrorData() [*c]ErrorData;
pub extern fn FreeErrorData(edata: [*c]ErrorData) void;
pub extern fn FlushErrorState() void;
pub extern fn ReThrowError(edata: [*c]ErrorData) noreturn;
pub extern fn ThrowErrorData(edata: [*c]ErrorData) void;
pub extern fn pg_re_throw() noreturn;
pub extern fn GetErrorContextStack() [*c]u8;
pub const emit_log_hook_type = ?*const fn ([*c]ErrorData) callconv(.C) void;
pub extern var emit_log_hook: emit_log_hook_type;
pub const PGERROR_TERSE: c_int = 0;
pub const PGERROR_DEFAULT: c_int = 1;
pub const PGERROR_VERBOSE: c_int = 2;
pub const PGErrorVerbosity = c_uint;
pub extern var Log_error_verbosity: c_int;
pub extern var Log_line_prefix: [*c]u8;
pub extern var Log_destination: c_int;
pub extern var Log_destination_string: [*c]u8;
pub extern var syslog_sequence_numbers: bool;
pub extern var syslog_split_messages: bool;
pub extern fn log_status_format(buf: StringInfo, format: [*c]const u8, edata: [*c]ErrorData) void;
pub extern fn DebugFileOpen() void;
pub extern fn unpack_sql_state(sql_state: c_int) [*c]u8;
pub extern fn in_error_recursion_trouble() bool;
pub extern fn reset_formatted_start_time() void;
pub extern fn get_formatted_start_time() [*c]u8;
pub extern fn get_formatted_log_time() [*c]u8;
pub extern fn get_backend_type_for_log() [*c]const u8;
pub extern fn check_log_of_query(edata: [*c]ErrorData) bool;
pub extern fn error_severity(elevel: c_int) [*c]const u8;
pub extern fn write_pipe_chunks(data: [*c]u8, len: c_int, dest: c_int) void;
pub extern fn write_csvlog(edata: [*c]ErrorData) void;
pub extern fn write_jsonlog(edata: [*c]ErrorData) void;
pub extern fn write_stderr(fmt: [*c]const u8, ...) void;
pub extern var CurrentMemoryContext: MemoryContext;
pub extern fn MemoryContextAlloc(context: MemoryContext, size: Size) ?*anyopaque;
pub extern fn MemoryContextAllocZero(context: MemoryContext, size: Size) ?*anyopaque;
pub extern fn MemoryContextAllocZeroAligned(context: MemoryContext, size: Size) ?*anyopaque;
pub extern fn MemoryContextAllocExtended(context: MemoryContext, size: Size, flags: c_int) ?*anyopaque;
pub extern fn MemoryContextAllocAligned(context: MemoryContext, size: Size, alignto: Size, flags: c_int) ?*anyopaque;
pub extern fn palloc(size: Size) ?*anyopaque;
pub extern fn palloc0(size: Size) ?*anyopaque;
pub extern fn palloc_extended(size: Size, flags: c_int) ?*anyopaque;
pub extern fn palloc_aligned(size: Size, alignto: Size, flags: c_int) ?*anyopaque;
pub extern fn repalloc(pointer: ?*anyopaque, size: Size) ?*anyopaque;
pub extern fn repalloc_extended(pointer: ?*anyopaque, size: Size, flags: c_int) ?*anyopaque;
pub extern fn repalloc0(pointer: ?*anyopaque, oldsize: Size, size: Size) ?*anyopaque;
pub extern fn pfree(pointer: ?*anyopaque) void;
pub extern fn MemoryContextAllocHuge(context: MemoryContext, size: Size) ?*anyopaque;
pub extern fn repalloc_huge(pointer: ?*anyopaque, size: Size) ?*anyopaque;
pub fn MemoryContextSwitchTo(arg_context: MemoryContext) callconv(.C) MemoryContext {
    var context = arg_context;
    var old: MemoryContext = CurrentMemoryContext;
    CurrentMemoryContext = context;
    return old;
}
pub extern fn MemoryContextRegisterResetCallback(context: MemoryContext, cb: [*c]MemoryContextCallback) void;
pub extern fn MemoryContextStrdup(context: MemoryContext, string: [*c]const u8) [*c]u8;
pub extern fn pstrdup(in: [*c]const u8) [*c]u8;
pub extern fn pnstrdup(in: [*c]const u8, len: Size) [*c]u8;
pub extern fn pchomp(in: [*c]const u8) [*c]u8;
pub extern fn psprintf(fmt: [*c]const u8, ...) [*c]u8;
pub extern fn pvsnprintf(buf: [*c]u8, len: usize, fmt: [*c]const u8, args: [*c]struct___va_list_tag) usize;
pub const Datum = usize;
pub const struct_NullableDatum = extern struct {
    value: Datum,
    isnull: bool,
};
pub const NullableDatum = struct_NullableDatum;
pub fn DatumGetBool(arg_X: Datum) callconv(.C) bool {
    var X = arg_X;
    return X != @bitCast(c_ulong, @as(c_long, @as(c_int, 0)));
}
pub fn BoolGetDatum(arg_X: bool) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_long, if (@as(c_int, @boolToInt(X)) != 0) @as(c_int, 1) else @as(c_int, 0)));
}
pub fn DatumGetChar(arg_X: Datum) callconv(.C) u8 {
    var X = arg_X;
    return @bitCast(u8, @truncate(u8, X));
}
pub fn CharGetDatum(arg_X: u8) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_ulong, X));
}
pub fn Int8GetDatum(arg_X: int8) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_long, X));
}
pub fn DatumGetUInt8(arg_X: Datum) callconv(.C) uint8 {
    var X = arg_X;
    return @bitCast(uint8, @truncate(u8, X));
}
pub fn UInt8GetDatum(arg_X: uint8) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_ulong, X));
}
pub fn DatumGetInt16(arg_X: Datum) callconv(.C) int16 {
    var X = arg_X;
    return @bitCast(int16, @truncate(c_ushort, X));
}
pub fn Int16GetDatum(arg_X: int16) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_long, X));
}
pub fn DatumGetUInt16(arg_X: Datum) callconv(.C) uint16 {
    var X = arg_X;
    return @bitCast(uint16, @truncate(c_ushort, X));
}
pub fn UInt16GetDatum(arg_X: uint16) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_ulong, X));
}
pub fn DatumGetInt32(arg_X: Datum) callconv(.C) int32 {
    var X = arg_X;
    return @bitCast(int32, @truncate(c_uint, X));
}
pub fn Int32GetDatum(arg_X: int32) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_long, X));
}
pub fn DatumGetUInt32(arg_X: Datum) callconv(.C) uint32 {
    var X = arg_X;
    return @bitCast(uint32, @truncate(c_uint, X));
}
pub fn UInt32GetDatum(arg_X: uint32) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_ulong, X));
}
pub fn DatumGetObjectId(arg_X: Datum) callconv(.C) Oid {
    var X = arg_X;
    return @bitCast(Oid, @truncate(c_uint, X));
}
pub fn ObjectIdGetDatum(arg_X: Oid) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_ulong, X));
}
pub fn DatumGetTransactionId(arg_X: Datum) callconv(.C) TransactionId {
    var X = arg_X;
    return @bitCast(TransactionId, @truncate(c_uint, X));
}
pub fn TransactionIdGetDatum(arg_X: TransactionId) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_ulong, X));
}
pub fn MultiXactIdGetDatum(arg_X: MultiXactId) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_ulong, X));
}
pub fn DatumGetCommandId(arg_X: Datum) callconv(.C) CommandId {
    var X = arg_X;
    return @bitCast(CommandId, @truncate(c_uint, X));
}
pub fn CommandIdGetDatum(arg_X: CommandId) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, @as(c_ulong, X));
}
pub fn DatumGetPointer(arg_X: Datum) callconv(.C) Pointer {
    var X = arg_X;
    return @intToPtr(Pointer, X);
}
pub fn PointerGetDatum(arg_X: ?*const anyopaque) callconv(.C) Datum {
    var X = arg_X;
    return @intCast(Datum, @ptrToInt(X));
}
pub fn DatumGetCString(arg_X: Datum) callconv(.C) [*c]u8 {
    var X = arg_X;
    return @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), DatumGetPointer(X)));
}
pub fn CStringGetDatum(arg_X: [*c]const u8) callconv(.C) Datum {
    var X = arg_X;
    return PointerGetDatum(@ptrCast(?*const anyopaque, X));
}
pub fn DatumGetName(arg_X: Datum) callconv(.C) Name {
    var X = arg_X;
    return @ptrCast(Name, @alignCast(@import("std").meta.alignment(Name), DatumGetPointer(X)));
}
pub fn NameGetDatum(arg_X: [*c]const NameData) callconv(.C) Datum {
    var X = arg_X;
    return CStringGetDatum(@ptrCast([*c]const u8, @alignCast(@import("std").meta.alignment([*c]const u8), &X.*.data)));
}
pub fn DatumGetInt64(arg_X: Datum) callconv(.C) int64 {
    var X = arg_X;
    return @bitCast(int64, X);
}
pub fn Int64GetDatum(arg_X: int64) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, X);
}
pub fn DatumGetUInt64(arg_X: Datum) callconv(.C) uint64 {
    var X = arg_X;
    return @bitCast(uint64, X);
}
pub fn UInt64GetDatum(arg_X: uint64) callconv(.C) Datum {
    var X = arg_X;
    return @bitCast(Datum, X);
}
pub fn DatumGetFloat4(arg_X: Datum) callconv(.C) float4 {
    var X = arg_X;
    const union_unnamed_5 = extern union {
        value: int32,
        retval: float4,
    };
    _ = @TypeOf(union_unnamed_5);
    var myunion: union_unnamed_5 = undefined;
    myunion.value = DatumGetInt32(X);
    return myunion.retval;
}
pub fn Float4GetDatum(arg_X: float4) callconv(.C) Datum {
    var X = arg_X;
    const union_unnamed_6 = extern union {
        value: float4,
        retval: int32,
    };
    _ = @TypeOf(union_unnamed_6);
    var myunion: union_unnamed_6 = undefined;
    myunion.value = X;
    return Int32GetDatum(myunion.retval);
}
pub fn DatumGetFloat8(arg_X: Datum) callconv(.C) float8 {
    var X = arg_X;
    const union_unnamed_7 = extern union {
        value: int64,
        retval: float8,
    };
    _ = @TypeOf(union_unnamed_7);
    var myunion: union_unnamed_7 = undefined;
    myunion.value = DatumGetInt64(X);
    return myunion.retval;
}
pub fn Float8GetDatum(arg_X: float8) callconv(.C) Datum {
    var X = arg_X;
    const union_unnamed_8 = extern union {
        value: float8,
        retval: int64,
    };
    _ = @TypeOf(union_unnamed_8);
    var myunion: union_unnamed_8 = undefined;
    myunion.value = X;
    return Int64GetDatum(myunion.retval);
}
pub const BlockNumber = uint32;
pub const struct_BlockIdData = extern struct {
    bi_hi: uint16,
    bi_lo: uint16,
};
pub const BlockIdData = struct_BlockIdData;
pub const BlockId = [*c]BlockIdData;
pub fn BlockNumberIsValid(arg_blockNumber: BlockNumber) callconv(.C) bool {
    var blockNumber = arg_blockNumber;
    return blockNumber != @bitCast(BlockNumber, @as(c_uint, 4294967295));
}
pub fn BlockIdSet(arg_blockId: [*c]BlockIdData, arg_blockNumber: BlockNumber) callconv(.C) void {
    var blockId = arg_blockId;
    var blockNumber = arg_blockNumber;
    blockId.*.bi_hi = @bitCast(uint16, @truncate(c_ushort, blockNumber >> @intCast(@import("std").math.Log2Int(BlockNumber), 16)));
    blockId.*.bi_lo = @bitCast(uint16, @truncate(c_ushort, blockNumber & @bitCast(c_uint, @as(c_int, 65535))));
}
pub fn BlockIdEquals(arg_blockId1: [*c]const BlockIdData, arg_blockId2: [*c]const BlockIdData) callconv(.C) bool {
    var blockId1 = arg_blockId1;
    var blockId2 = arg_blockId2;
    return (@bitCast(c_int, @as(c_uint, blockId1.*.bi_hi)) == @bitCast(c_int, @as(c_uint, blockId2.*.bi_hi))) and (@bitCast(c_int, @as(c_uint, blockId1.*.bi_lo)) == @bitCast(c_int, @as(c_uint, blockId2.*.bi_lo)));
}
pub fn BlockIdGetBlockNumber(arg_blockId: [*c]const BlockIdData) callconv(.C) BlockNumber {
    var blockId = arg_blockId;
    return (@bitCast(BlockNumber, @as(c_uint, blockId.*.bi_hi)) << @intCast(@import("std").math.Log2Int(BlockNumber), 16)) | @bitCast(BlockNumber, @as(c_uint, blockId.*.bi_lo));
} // ../../src/include/storage/itemid.h:27:11: warning: struct demoted to opaque type - has bitfield
pub const struct_ItemIdData = opaque {};
pub const ItemIdData = struct_ItemIdData;
pub const ItemId = ?*ItemIdData;
pub const ItemOffset = uint16;
pub const ItemLength = uint16;
pub const OffsetNumber = uint16;
pub const struct_ItemPointerData = extern struct {
    ip_blkid: BlockIdData align(1),
    ip_posid: OffsetNumber align(1),
};
pub const ItemPointerData = struct_ItemPointerData;
pub const ItemPointer = [*c]ItemPointerData;
pub fn ItemPointerIsValid(arg_pointer: [*c]const ItemPointerData) callconv(.C) bool {
    var pointer = arg_pointer;
    return (@ptrCast(?*const anyopaque, pointer) != @ptrCast(?*const anyopaque, @intToPtr(?*anyopaque, @as(c_int, 0)))) and (@bitCast(c_int, @as(c_uint, pointer.*.ip_posid)) != @as(c_int, 0));
}
pub fn ItemPointerGetBlockNumberNoCheck(arg_pointer: [*c]const ItemPointerData) callconv(.C) BlockNumber {
    var pointer = arg_pointer;
    return BlockIdGetBlockNumber(&pointer.*.ip_blkid);
}
pub fn ItemPointerGetBlockNumber(arg_pointer: [*c]const ItemPointerData) callconv(.C) BlockNumber {
    var pointer = arg_pointer;
    _ = @as(c_int, 1);
    return ItemPointerGetBlockNumberNoCheck(pointer);
}
pub fn ItemPointerGetOffsetNumberNoCheck(arg_pointer: [*c]const ItemPointerData) callconv(.C) OffsetNumber {
    var pointer = arg_pointer;
    return pointer.*.ip_posid;
}
pub fn ItemPointerGetOffsetNumber(arg_pointer: [*c]const ItemPointerData) callconv(.C) OffsetNumber {
    var pointer = arg_pointer;
    _ = @as(c_int, 1);
    return ItemPointerGetOffsetNumberNoCheck(pointer);
}
pub fn ItemPointerSet(arg_pointer: [*c]ItemPointerData, arg_blockNumber: BlockNumber, arg_offNum: OffsetNumber) callconv(.C) void {
    var pointer = arg_pointer;
    var blockNumber = arg_blockNumber;
    var offNum = arg_offNum;
    _ = @as(c_int, 1);
    BlockIdSet(&pointer.*.ip_blkid, blockNumber);
    pointer.*.ip_posid = offNum;
}
pub fn ItemPointerSetBlockNumber(arg_pointer: [*c]ItemPointerData, arg_blockNumber: BlockNumber) callconv(.C) void {
    var pointer = arg_pointer;
    var blockNumber = arg_blockNumber;
    _ = @as(c_int, 1);
    BlockIdSet(&pointer.*.ip_blkid, blockNumber);
}
pub fn ItemPointerSetOffsetNumber(arg_pointer: [*c]ItemPointerData, arg_offsetNumber: OffsetNumber) callconv(.C) void {
    var pointer = arg_pointer;
    var offsetNumber = arg_offsetNumber;
    _ = @as(c_int, 1);
    pointer.*.ip_posid = offsetNumber;
}
pub fn ItemPointerCopy(arg_fromPointer: [*c]const ItemPointerData, arg_toPointer: [*c]ItemPointerData) callconv(.C) void {
    var fromPointer = arg_fromPointer;
    var toPointer = arg_toPointer;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    toPointer.* = fromPointer.*;
}
pub fn ItemPointerSetInvalid(arg_pointer: [*c]ItemPointerData) callconv(.C) void {
    var pointer = arg_pointer;
    _ = @as(c_int, 1);
    BlockIdSet(&pointer.*.ip_blkid, @bitCast(BlockNumber, @as(c_uint, 4294967295)));
    pointer.*.ip_posid = @bitCast(OffsetNumber, @truncate(c_short, @as(c_int, 0)));
}
pub fn ItemPointerIndicatesMovedPartitions(arg_pointer: [*c]const ItemPointerData) callconv(.C) bool {
    var pointer = arg_pointer;
    return (@bitCast(c_int, @as(c_uint, ItemPointerGetOffsetNumber(pointer))) == @as(c_int, 65533)) and (ItemPointerGetBlockNumberNoCheck(pointer) == @bitCast(BlockNumber, @as(c_uint, 4294967295)));
}
pub fn ItemPointerSetMovedPartitions(arg_pointer: [*c]ItemPointerData) callconv(.C) void {
    var pointer = arg_pointer;
    ItemPointerSet(pointer, @bitCast(BlockNumber, @as(c_uint, 4294967295)), @bitCast(OffsetNumber, @truncate(c_short, @as(c_int, 65533))));
}
pub extern fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer) bool;
pub extern fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) int32;
pub extern fn ItemPointerInc(pointer: ItemPointer) void;
pub extern fn ItemPointerDec(pointer: ItemPointer) void;
pub fn DatumGetItemPointer(arg_X: Datum) callconv(.C) ItemPointer {
    var X = arg_X;
    return @ptrCast(ItemPointer, @alignCast(@import("std").meta.alignment(ItemPointer), DatumGetPointer(X)));
}
pub fn ItemPointerGetDatum(arg_X: [*c]const ItemPointerData) callconv(.C) Datum {
    var X = arg_X;
    return PointerGetDatum(@ptrCast(?*const anyopaque, X));
}
const union_unnamed_10 = extern union {
    t_cid: CommandId,
    t_xvac: TransactionId,
};
pub const struct_HeapTupleFields = extern struct {
    t_xmin: TransactionId,
    t_xmax: TransactionId,
    t_field3: union_unnamed_10,
};
pub const HeapTupleFields = struct_HeapTupleFields;
pub const struct_DatumTupleFields = extern struct {
    datum_len_: int32,
    datum_typmod: int32,
    datum_typeid: Oid,
};
pub const DatumTupleFields = struct_DatumTupleFields;
const union_unnamed_9 = extern union {
    t_heap: HeapTupleFields,
    t_datum: DatumTupleFields,
};
pub const struct_HeapTupleHeaderData = extern struct {
    t_choice: union_unnamed_9 align(4),
    t_ctid: ItemPointerData,
    t_infomask2: uint16,
    t_infomask: uint16,
    t_hoff: uint8,
    pub fn t_bits(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), bits8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), bits8);
        return @ptrCast(ReturnType, @alignCast(@alignOf(bits8), @ptrCast(Intermediate, self) + 23));
    }
};
pub const HeapTupleHeaderData = struct_HeapTupleHeaderData;
pub const HeapTupleHeader = [*c]HeapTupleHeaderData;
pub const struct_MinimalTupleData = extern struct {
    t_len: uint32 align(4),
    mt_padding: [6]u8,
    t_infomask2: uint16,
    t_infomask: uint16,
    t_hoff: uint8,
    pub fn t_bits(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), bits8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), bits8);
        return @ptrCast(ReturnType, @alignCast(@alignOf(bits8), @ptrCast(Intermediate, self) + 15));
    }
};
pub const MinimalTupleData = struct_MinimalTupleData;
pub const MinimalTuple = [*c]MinimalTupleData;
pub const struct_HeapTupleData = extern struct {
    t_len: uint32,
    t_self: ItemPointerData,
    t_tableOid: Oid,
    t_data: HeapTupleHeader,
};
pub const HeapTupleData = struct_HeapTupleData;
pub const HeapTuple = [*c]HeapTupleData;
pub extern fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) CommandId;
pub extern fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) CommandId;
pub extern fn HeapTupleHeaderAdjustCmax(tup: HeapTupleHeader, cmax: [*c]CommandId, iscombo: [*c]bool) void;
pub extern fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) TransactionId;
pub const RelFileNumber = Oid;
pub const InvalidForkNumber: c_int = -1;
pub const MAIN_FORKNUM: c_int = 0;
pub const FSM_FORKNUM: c_int = 1;
pub const VISIBILITYMAP_FORKNUM: c_int = 2;
pub const INIT_FORKNUM: c_int = 3;
pub const enum_ForkNumber = c_int;
pub const ForkNumber = enum_ForkNumber;
pub extern const forkNames: [*c]const [*c]const u8;
pub extern fn forkname_to_number(forkName: [*c]const u8) ForkNumber;
pub extern fn forkname_chars(str: [*c]const u8, fork: [*c]ForkNumber) c_int;
pub extern fn GetDatabasePath(dbOid: Oid, spcOid: Oid) [*c]u8;
pub extern fn GetRelationPath(dbOid: Oid, spcOid: Oid, relNumber: RelFileNumber, backendId: c_int, forkNumber: ForkNumber) [*c]u8;
pub const Node = struct_Node;
pub const bitmapword = uint64;
pub const struct_Bitmapset = extern struct {
    type: NodeTag align(8),
    nwords: c_int,
    pub fn words(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), bitmapword) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), bitmapword);
        return @ptrCast(ReturnType, @alignCast(@alignOf(bitmapword), @ptrCast(Intermediate, self) + 8));
    }
};
pub extern fn outNode(str: [*c]struct_StringInfoData, obj: ?*const anyopaque) void;
pub extern fn outToken(str: [*c]struct_StringInfoData, s: [*c]const u8) void;
pub extern fn outBitmapset(str: [*c]struct_StringInfoData, bms: [*c]const struct_Bitmapset) void;
pub extern fn outDatum(str: [*c]struct_StringInfoData, value: usize, typlen: c_int, typbyval: bool) void;
pub extern fn nodeToString(obj: ?*const anyopaque) [*c]u8;
pub extern fn bmsToString(bms: [*c]const struct_Bitmapset) [*c]u8;
pub extern fn stringToNode(str: [*c]const u8) ?*anyopaque;
pub extern fn readBitmapset() [*c]struct_Bitmapset;
pub extern fn readDatum(typbyval: bool) usize;
pub extern fn readBoolCols(numCols: c_int) [*c]bool;
pub extern fn readIntCols(numCols: c_int) [*c]c_int;
pub extern fn readOidCols(numCols: c_int) [*c]Oid;
pub extern fn readAttrNumberCols(numCols: c_int) [*c]int16;
pub extern fn copyObjectImpl(from: ?*const anyopaque) ?*anyopaque;
pub extern fn equal(a: ?*const anyopaque, b: ?*const anyopaque) bool;
pub const Selectivity = f64;
pub const Cost = f64;
pub const Cardinality = f64;
pub const CMD_UNKNOWN: c_int = 0;
pub const CMD_SELECT: c_int = 1;
pub const CMD_UPDATE: c_int = 2;
pub const CMD_INSERT: c_int = 3;
pub const CMD_DELETE: c_int = 4;
pub const CMD_MERGE: c_int = 5;
pub const CMD_UTILITY: c_int = 6;
pub const CMD_NOTHING: c_int = 7;
pub const enum_CmdType = c_uint;
pub const CmdType = enum_CmdType;
pub const JOIN_INNER: c_int = 0;
pub const JOIN_LEFT: c_int = 1;
pub const JOIN_FULL: c_int = 2;
pub const JOIN_RIGHT: c_int = 3;
pub const JOIN_SEMI: c_int = 4;
pub const JOIN_ANTI: c_int = 5;
pub const JOIN_RIGHT_ANTI: c_int = 6;
pub const JOIN_UNIQUE_OUTER: c_int = 7;
pub const JOIN_UNIQUE_INNER: c_int = 8;
pub const enum_JoinType = c_uint;
pub const JoinType = enum_JoinType;
pub const AGG_PLAIN: c_int = 0;
pub const AGG_SORTED: c_int = 1;
pub const AGG_HASHED: c_int = 2;
pub const AGG_MIXED: c_int = 3;
pub const enum_AggStrategy = c_uint;
pub const AggStrategy = enum_AggStrategy;
pub const AGGSPLIT_SIMPLE: c_int = 0;
pub const AGGSPLIT_INITIAL_SERIAL: c_int = 6;
pub const AGGSPLIT_FINAL_DESERIAL: c_int = 9;
pub const enum_AggSplit = c_uint;
pub const AggSplit = enum_AggSplit;
pub const SETOPCMD_INTERSECT: c_int = 0;
pub const SETOPCMD_INTERSECT_ALL: c_int = 1;
pub const SETOPCMD_EXCEPT: c_int = 2;
pub const SETOPCMD_EXCEPT_ALL: c_int = 3;
pub const enum_SetOpCmd = c_uint;
pub const SetOpCmd = enum_SetOpCmd;
pub const SETOP_SORTED: c_int = 0;
pub const SETOP_HASHED: c_int = 1;
pub const enum_SetOpStrategy = c_uint;
pub const SetOpStrategy = enum_SetOpStrategy;
pub const ONCONFLICT_NONE: c_int = 0;
pub const ONCONFLICT_NOTHING: c_int = 1;
pub const ONCONFLICT_UPDATE: c_int = 2;
pub const enum_OnConflictAction = c_uint;
pub const OnConflictAction = enum_OnConflictAction;
pub const LIMIT_OPTION_COUNT: c_int = 0;
pub const LIMIT_OPTION_WITH_TIES: c_int = 1;
pub const LIMIT_OPTION_DEFAULT: c_int = 2;
pub const enum_LimitOption = c_uint;
pub const LimitOption = enum_LimitOption;
pub const union_ListCell = extern union {
    ptr_value: ?*anyopaque,
    int_value: c_int,
    oid_value: Oid,
    xid_value: TransactionId,
};
pub const ListCell = union_ListCell;
pub const struct_List = extern struct {
    type: NodeTag align(8),
    length: c_int,
    max_length: c_int,
    elements: [*c]ListCell,
    pub fn initial_elements(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), ListCell) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), ListCell);
        return @ptrCast(ReturnType, @alignCast(@alignOf(ListCell), @ptrCast(Intermediate, self) + 24));
    }
};
pub const signedbitmapword = int64;
pub const Bitmapset = struct_Bitmapset;
pub const BMS_EQUAL: c_int = 0;
pub const BMS_SUBSET1: c_int = 1;
pub const BMS_SUBSET2: c_int = 2;
pub const BMS_DIFFERENT: c_int = 3;
pub const BMS_Comparison = c_uint;
pub const BMS_EMPTY_SET: c_int = 0;
pub const BMS_SINGLETON: c_int = 1;
pub const BMS_MULTIPLE: c_int = 2;
pub const BMS_Membership = c_uint;
pub extern fn bms_copy(a: [*c]const Bitmapset) [*c]Bitmapset;
pub extern fn bms_equal(a: [*c]const Bitmapset, b: [*c]const Bitmapset) bool;
pub extern fn bms_compare(a: [*c]const Bitmapset, b: [*c]const Bitmapset) c_int;
pub extern fn bms_make_singleton(x: c_int) [*c]Bitmapset;
pub extern fn bms_free(a: [*c]Bitmapset) void;
pub extern fn bms_union(a: [*c]const Bitmapset, b: [*c]const Bitmapset) [*c]Bitmapset;
pub extern fn bms_intersect(a: [*c]const Bitmapset, b: [*c]const Bitmapset) [*c]Bitmapset;
pub extern fn bms_difference(a: [*c]const Bitmapset, b: [*c]const Bitmapset) [*c]Bitmapset;
pub extern fn bms_is_subset(a: [*c]const Bitmapset, b: [*c]const Bitmapset) bool;
pub extern fn bms_subset_compare(a: [*c]const Bitmapset, b: [*c]const Bitmapset) BMS_Comparison;
pub extern fn bms_is_member(x: c_int, a: [*c]const Bitmapset) bool;
pub extern fn bms_member_index(a: [*c]Bitmapset, x: c_int) c_int;
pub extern fn bms_overlap(a: [*c]const Bitmapset, b: [*c]const Bitmapset) bool;
pub extern fn bms_overlap_list(a: [*c]const Bitmapset, b: [*c]const struct_List) bool;
pub extern fn bms_nonempty_difference(a: [*c]const Bitmapset, b: [*c]const Bitmapset) bool;
pub extern fn bms_singleton_member(a: [*c]const Bitmapset) c_int;
pub extern fn bms_get_singleton_member(a: [*c]const Bitmapset, member: [*c]c_int) bool;
pub extern fn bms_num_members(a: [*c]const Bitmapset) c_int;
pub extern fn bms_membership(a: [*c]const Bitmapset) BMS_Membership;
pub extern fn bms_add_member(a: [*c]Bitmapset, x: c_int) [*c]Bitmapset;
pub extern fn bms_del_member(a: [*c]Bitmapset, x: c_int) [*c]Bitmapset;
pub extern fn bms_add_members(a: [*c]Bitmapset, b: [*c]const Bitmapset) [*c]Bitmapset;
pub extern fn bms_add_range(a: [*c]Bitmapset, lower: c_int, upper: c_int) [*c]Bitmapset;
pub extern fn bms_int_members(a: [*c]Bitmapset, b: [*c]const Bitmapset) [*c]Bitmapset;
pub extern fn bms_del_members(a: [*c]Bitmapset, b: [*c]const Bitmapset) [*c]Bitmapset;
pub extern fn bms_join(a: [*c]Bitmapset, b: [*c]Bitmapset) [*c]Bitmapset;
pub extern fn bms_next_member(a: [*c]const Bitmapset, prevbit: c_int) c_int;
pub extern fn bms_prev_member(a: [*c]const Bitmapset, prevbit: c_int) c_int;
pub extern fn bms_hash_value(a: [*c]const Bitmapset) uint32;
pub extern fn bitmap_hash(key: ?*const anyopaque, keysize: Size) uint32;
pub extern fn bitmap_match(key1: ?*const anyopaque, key2: ?*const anyopaque, keysize: Size) c_int;
pub const LCS_NONE: c_int = 0;
pub const LCS_FORKEYSHARE: c_int = 1;
pub const LCS_FORSHARE: c_int = 2;
pub const LCS_FORNOKEYUPDATE: c_int = 3;
pub const LCS_FORUPDATE: c_int = 4;
pub const enum_LockClauseStrength = c_uint;
pub const LockClauseStrength = enum_LockClauseStrength;
pub const LockWaitBlock: c_int = 0;
pub const LockWaitSkip: c_int = 1;
pub const LockWaitError: c_int = 2;
pub const enum_LockWaitPolicy = c_uint;
pub const LockWaitPolicy = enum_LockWaitPolicy;
pub const LockTupleKeyShare: c_int = 0;
pub const LockTupleShare: c_int = 1;
pub const LockTupleNoKeyExclusive: c_int = 2;
pub const LockTupleExclusive: c_int = 3;
pub const enum_LockTupleMode = c_uint;
pub const LockTupleMode = enum_LockTupleMode;
pub const AttrNumber = int16;
pub const List = struct_List;
pub const struct_ForEachState = extern struct {
    l: [*c]const List,
    i: c_int,
};
pub const ForEachState = struct_ForEachState;
pub const struct_ForBothState = extern struct {
    l1: [*c]const List,
    l2: [*c]const List,
    i: c_int,
};
pub const ForBothState = struct_ForBothState;
pub const struct_ForBothCellState = extern struct {
    l1: [*c]const List,
    l2: [*c]const List,
    i1: c_int,
    i2: c_int,
};
pub const ForBothCellState = struct_ForBothCellState;
pub const struct_ForThreeState = extern struct {
    l1: [*c]const List,
    l2: [*c]const List,
    l3: [*c]const List,
    i: c_int,
};
pub const ForThreeState = struct_ForThreeState;
pub const struct_ForFourState = extern struct {
    l1: [*c]const List,
    l2: [*c]const List,
    l3: [*c]const List,
    l4: [*c]const List,
    i: c_int,
};
pub const ForFourState = struct_ForFourState;
pub const struct_ForFiveState = extern struct {
    l1: [*c]const List,
    l2: [*c]const List,
    l3: [*c]const List,
    l4: [*c]const List,
    l5: [*c]const List,
    i: c_int,
};
pub const ForFiveState = struct_ForFiveState;
pub fn list_head(arg_l: [*c]const List) callconv(.C) [*c]ListCell {
    var l = arg_l;
    return if (l != null) &l.*.elements[@intCast(c_uint, @as(c_int, 0))] else null;
}
pub fn list_tail(arg_l: [*c]const List) callconv(.C) [*c]ListCell {
    var l = arg_l;
    return if (l != null) &(blk: {
        const tmp = l.*.length - @as(c_int, 1);
        if (tmp >= 0) break :blk l.*.elements + @intCast(usize, tmp) else break :blk l.*.elements - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
    }).* else null;
}
pub fn list_second_cell(arg_l: [*c]const List) callconv(.C) [*c]ListCell {
    var l = arg_l;
    if ((l != null) and (l.*.length >= @as(c_int, 2))) return &l.*.elements[@intCast(c_uint, @as(c_int, 1))] else return null;
    return null;
}
pub fn list_length(arg_l: [*c]const List) callconv(.C) c_int {
    var l = arg_l;
    return if (l != null) l.*.length else @as(c_int, 0);
}
pub fn list_nth_cell(arg_list: [*c]const List, arg_n: c_int) callconv(.C) [*c]ListCell {
    var list = arg_list;
    var n = arg_n;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    return &(blk: {
        const tmp = n;
        if (tmp >= 0) break :blk list.*.elements + @intCast(usize, tmp) else break :blk list.*.elements - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
    }).*;
}
pub fn list_last_cell(arg_list: [*c]const List) callconv(.C) [*c]ListCell {
    var list = arg_list;
    _ = @as(c_int, 1);
    return &(blk: {
        const tmp = list.*.length - @as(c_int, 1);
        if (tmp >= 0) break :blk list.*.elements + @intCast(usize, tmp) else break :blk list.*.elements - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
    }).*;
}
pub fn list_nth(arg_list: [*c]const List, arg_n: c_int) callconv(.C) ?*anyopaque {
    var list = arg_list;
    var n = arg_n;
    _ = @as(c_int, 1);
    return list_nth_cell(list, n).*.ptr_value;
}
pub fn list_nth_int(arg_list: [*c]const List, arg_n: c_int) callconv(.C) c_int {
    var list = arg_list;
    var n = arg_n;
    _ = @as(c_int, 1);
    return list_nth_cell(list, n).*.int_value;
}
pub fn list_nth_oid(arg_list: [*c]const List, arg_n: c_int) callconv(.C) Oid {
    var list = arg_list;
    var n = arg_n;
    _ = @as(c_int, 1);
    return list_nth_cell(list, n).*.oid_value;
}
pub fn list_cell_number(arg_l: [*c]const List, arg_c: [*c]const ListCell) callconv(.C) c_int {
    var l = arg_l;
    var c = arg_c;
    _ = @as(c_int, 1);
    return @bitCast(c_int, @truncate(c_int, @divExact(@bitCast(c_long, @ptrToInt(c) -% @ptrToInt(l.*.elements)), @sizeOf(ListCell))));
}
pub fn lnext(arg_l: [*c]const List, arg_c: [*c]const ListCell) callconv(.C) [*c]ListCell {
    var l = arg_l;
    var c = arg_c;
    _ = @as(c_int, 1);
    c += 1;
    if (c < @ptrCast([*c]const ListCell, @alignCast(@import("std").meta.alignment([*c]const ListCell), &(blk: {
        const tmp = l.*.length;
        if (tmp >= 0) break :blk l.*.elements + @intCast(usize, tmp) else break :blk l.*.elements - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
    }).*))) return @intToPtr([*c]ListCell, @ptrToInt(c)) else return null;
    return null;
}
pub fn for_each_from_setup(arg_lst: [*c]const List, arg_N: c_int) callconv(.C) ForEachState {
    var lst = arg_lst;
    var N = arg_N;
    var r: ForEachState = ForEachState{
        .l = lst,
        .i = N,
    };
    _ = @as(c_int, 1);
    return r;
}
pub fn for_each_cell_setup(arg_lst: [*c]const List, arg_initcell: [*c]const ListCell) callconv(.C) ForEachState {
    var lst = arg_lst;
    var initcell = arg_initcell;
    var r: ForEachState = ForEachState{
        .l = lst,
        .i = if (initcell != null) list_cell_number(lst, initcell) else list_length(lst),
    };
    return r;
}
pub fn for_both_cell_setup(arg_list1: [*c]const List, arg_initcell1: [*c]const ListCell, arg_list2: [*c]const List, arg_initcell2: [*c]const ListCell) callconv(.C) ForBothCellState {
    var list1 = arg_list1;
    var initcell1 = arg_initcell1;
    var list2 = arg_list2;
    var initcell2 = arg_initcell2;
    var r: ForBothCellState = ForBothCellState{
        .l1 = list1,
        .l2 = list2,
        .@"i1" = if (initcell1 != null) list_cell_number(list1, initcell1) else list_length(list1),
        .@"i2" = if (initcell2 != null) list_cell_number(list2, initcell2) else list_length(list2),
    };
    return r;
}
pub extern fn list_make1_impl(t: NodeTag, datum1: ListCell) [*c]List;
pub extern fn list_make2_impl(t: NodeTag, datum1: ListCell, datum2: ListCell) [*c]List;
pub extern fn list_make3_impl(t: NodeTag, datum1: ListCell, datum2: ListCell, datum3: ListCell) [*c]List;
pub extern fn list_make4_impl(t: NodeTag, datum1: ListCell, datum2: ListCell, datum3: ListCell, datum4: ListCell) [*c]List;
pub extern fn list_make5_impl(t: NodeTag, datum1: ListCell, datum2: ListCell, datum3: ListCell, datum4: ListCell, datum5: ListCell) [*c]List;
pub extern fn lappend(list: [*c]List, datum: ?*anyopaque) [*c]List;
pub extern fn lappend_int(list: [*c]List, datum: c_int) [*c]List;
pub extern fn lappend_oid(list: [*c]List, datum: Oid) [*c]List;
pub extern fn lappend_xid(list: [*c]List, datum: TransactionId) [*c]List;
pub extern fn list_insert_nth(list: [*c]List, pos: c_int, datum: ?*anyopaque) [*c]List;
pub extern fn list_insert_nth_int(list: [*c]List, pos: c_int, datum: c_int) [*c]List;
pub extern fn list_insert_nth_oid(list: [*c]List, pos: c_int, datum: Oid) [*c]List;
pub extern fn lcons(datum: ?*anyopaque, list: [*c]List) [*c]List;
pub extern fn lcons_int(datum: c_int, list: [*c]List) [*c]List;
pub extern fn lcons_oid(datum: Oid, list: [*c]List) [*c]List;
pub extern fn list_concat(list1: [*c]List, list2: [*c]const List) [*c]List;
pub extern fn list_concat_copy(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_truncate(list: [*c]List, new_size: c_int) [*c]List;
pub extern fn list_member(list: [*c]const List, datum: ?*const anyopaque) bool;
pub extern fn list_member_ptr(list: [*c]const List, datum: ?*const anyopaque) bool;
pub extern fn list_member_int(list: [*c]const List, datum: c_int) bool;
pub extern fn list_member_oid(list: [*c]const List, datum: Oid) bool;
pub extern fn list_member_xid(list: [*c]const List, datum: TransactionId) bool;
pub extern fn list_delete(list: [*c]List, datum: ?*anyopaque) [*c]List;
pub extern fn list_delete_ptr(list: [*c]List, datum: ?*anyopaque) [*c]List;
pub extern fn list_delete_int(list: [*c]List, datum: c_int) [*c]List;
pub extern fn list_delete_oid(list: [*c]List, datum: Oid) [*c]List;
pub extern fn list_delete_first(list: [*c]List) [*c]List;
pub extern fn list_delete_last(list: [*c]List) [*c]List;
pub extern fn list_delete_first_n(list: [*c]List, n: c_int) [*c]List;
pub extern fn list_delete_nth_cell(list: [*c]List, n: c_int) [*c]List;
pub extern fn list_delete_cell(list: [*c]List, cell: [*c]ListCell) [*c]List;
pub extern fn list_union(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_union_ptr(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_union_int(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_union_oid(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_intersection(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_intersection_int(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_difference(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_difference_ptr(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_difference_int(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_difference_oid(list1: [*c]const List, list2: [*c]const List) [*c]List;
pub extern fn list_append_unique(list: [*c]List, datum: ?*anyopaque) [*c]List;
pub extern fn list_append_unique_ptr(list: [*c]List, datum: ?*anyopaque) [*c]List;
pub extern fn list_append_unique_int(list: [*c]List, datum: c_int) [*c]List;
pub extern fn list_append_unique_oid(list: [*c]List, datum: Oid) [*c]List;
pub extern fn list_concat_unique(list1: [*c]List, list2: [*c]const List) [*c]List;
pub extern fn list_concat_unique_ptr(list1: [*c]List, list2: [*c]const List) [*c]List;
pub extern fn list_concat_unique_int(list1: [*c]List, list2: [*c]const List) [*c]List;
pub extern fn list_concat_unique_oid(list1: [*c]List, list2: [*c]const List) [*c]List;
pub extern fn list_deduplicate_oid(list: [*c]List) void;
pub extern fn list_free(list: [*c]List) void;
pub extern fn list_free_deep(list: [*c]List) void;
pub extern fn list_copy(oldlist: [*c]const List) [*c]List;
pub extern fn list_copy_head(oldlist: [*c]const List, len: c_int) [*c]List;
pub extern fn list_copy_tail(oldlist: [*c]const List, nskip: c_int) [*c]List;
pub extern fn list_copy_deep(oldlist: [*c]const List) [*c]List;
pub const list_sort_comparator = ?*const fn ([*c]const ListCell, [*c]const ListCell) callconv(.C) c_int;
pub extern fn list_sort(list: [*c]List, cmp: list_sort_comparator) void;
pub extern fn list_int_cmp(p1: [*c]const ListCell, p2: [*c]const ListCell) c_int;
pub extern fn list_oid_cmp(p1: [*c]const ListCell, p2: [*c]const ListCell) c_int;
pub const struct_Alias = extern struct {
    type: NodeTag,
    aliasname: [*c]u8,
    colnames: [*c]List,
};
pub const Alias = struct_Alias;
pub const ONCOMMIT_NOOP: c_int = 0;
pub const ONCOMMIT_PRESERVE_ROWS: c_int = 1;
pub const ONCOMMIT_DELETE_ROWS: c_int = 2;
pub const ONCOMMIT_DROP: c_int = 3;
pub const enum_OnCommitAction = c_uint;
pub const OnCommitAction = enum_OnCommitAction;
pub const struct_RangeVar = extern struct {
    type: NodeTag,
    catalogname: [*c]u8,
    schemaname: [*c]u8,
    relname: [*c]u8,
    inh: bool,
    relpersistence: u8,
    alias: [*c]Alias,
    location: c_int,
};
pub const RangeVar = struct_RangeVar;
pub const struct_TableFunc = extern struct {
    type: NodeTag,
    ns_uris: [*c]List,
    ns_names: [*c]List,
    docexpr: [*c]Node,
    rowexpr: [*c]Node,
    colnames: [*c]List,
    coltypes: [*c]List,
    coltypmods: [*c]List,
    colcollations: [*c]List,
    colexprs: [*c]List,
    coldefexprs: [*c]List,
    notnulls: [*c]Bitmapset,
    ordinalitycol: c_int,
    location: c_int,
};
pub const TableFunc = struct_TableFunc;
pub const struct_IntoClause = extern struct {
    type: NodeTag,
    rel: [*c]RangeVar,
    colNames: [*c]List,
    accessMethod: [*c]u8,
    options: [*c]List,
    onCommit: OnCommitAction,
    tableSpaceName: [*c]u8,
    viewQuery: [*c]Node,
    skipData: bool,
};
pub const IntoClause = struct_IntoClause;
pub const struct_Expr = extern struct {
    type: NodeTag,
};
pub const Expr = struct_Expr;
pub const struct_Var = extern struct {
    xpr: Expr,
    varno: c_int,
    varattno: AttrNumber,
    vartype: Oid,
    vartypmod: int32,
    varcollid: Oid,
    varnullingrels: [*c]Bitmapset,
    varlevelsup: Index,
    varnosyn: Index,
    varattnosyn: AttrNumber,
    location: c_int,
};
pub const Var = struct_Var;
pub const struct_Const = extern struct {
    xpr: Expr,
    consttype: Oid,
    consttypmod: int32,
    constcollid: Oid,
    constlen: c_int,
    constvalue: Datum,
    constisnull: bool,
    constbyval: bool,
    location: c_int,
};
pub const Const = struct_Const;
pub const PARAM_EXTERN: c_int = 0;
pub const PARAM_EXEC: c_int = 1;
pub const PARAM_SUBLINK: c_int = 2;
pub const PARAM_MULTIEXPR: c_int = 3;
pub const enum_ParamKind = c_uint;
pub const ParamKind = enum_ParamKind;
pub const struct_Param = extern struct {
    xpr: Expr,
    paramkind: ParamKind,
    paramid: c_int,
    paramtype: Oid,
    paramtypmod: int32,
    paramcollid: Oid,
    location: c_int,
};
pub const Param = struct_Param;
pub const struct_Aggref = extern struct {
    xpr: Expr,
    aggfnoid: Oid,
    aggtype: Oid,
    aggcollid: Oid,
    inputcollid: Oid,
    aggtranstype: Oid,
    aggargtypes: [*c]List,
    aggdirectargs: [*c]List,
    args: [*c]List,
    aggorder: [*c]List,
    aggdistinct: [*c]List,
    aggfilter: [*c]Expr,
    aggstar: bool,
    aggvariadic: bool,
    aggkind: u8,
    aggpresorted: bool,
    agglevelsup: Index,
    aggsplit: AggSplit,
    aggno: c_int,
    aggtransno: c_int,
    location: c_int,
};
pub const Aggref = struct_Aggref;
pub const struct_GroupingFunc = extern struct {
    xpr: Expr,
    args: [*c]List,
    refs: [*c]List,
    cols: [*c]List,
    agglevelsup: Index,
    location: c_int,
};
pub const GroupingFunc = struct_GroupingFunc;
pub const struct_WindowFunc = extern struct {
    xpr: Expr,
    winfnoid: Oid,
    wintype: Oid,
    wincollid: Oid,
    inputcollid: Oid,
    args: [*c]List,
    aggfilter: [*c]Expr,
    winref: Index,
    winstar: bool,
    winagg: bool,
    location: c_int,
};
pub const WindowFunc = struct_WindowFunc;
pub const struct_SubscriptingRef = extern struct {
    xpr: Expr,
    refcontainertype: Oid,
    refelemtype: Oid,
    refrestype: Oid,
    reftypmod: int32,
    refcollid: Oid,
    refupperindexpr: [*c]List,
    reflowerindexpr: [*c]List,
    refexpr: [*c]Expr,
    refassgnexpr: [*c]Expr,
};
pub const SubscriptingRef = struct_SubscriptingRef;
pub const COERCION_IMPLICIT: c_int = 0;
pub const COERCION_ASSIGNMENT: c_int = 1;
pub const COERCION_PLPGSQL: c_int = 2;
pub const COERCION_EXPLICIT: c_int = 3;
pub const enum_CoercionContext = c_uint;
pub const CoercionContext = enum_CoercionContext;
pub const COERCE_EXPLICIT_CALL: c_int = 0;
pub const COERCE_EXPLICIT_CAST: c_int = 1;
pub const COERCE_IMPLICIT_CAST: c_int = 2;
pub const COERCE_SQL_SYNTAX: c_int = 3;
pub const enum_CoercionForm = c_uint;
pub const CoercionForm = enum_CoercionForm;
pub const struct_FuncExpr = extern struct {
    xpr: Expr,
    funcid: Oid,
    funcresulttype: Oid,
    funcretset: bool,
    funcvariadic: bool,
    funcformat: CoercionForm,
    funccollid: Oid,
    inputcollid: Oid,
    args: [*c]List,
    location: c_int,
};
pub const FuncExpr = struct_FuncExpr;
pub const struct_NamedArgExpr = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    name: [*c]u8,
    argnumber: c_int,
    location: c_int,
};
pub const NamedArgExpr = struct_NamedArgExpr;
pub const struct_OpExpr = extern struct {
    xpr: Expr,
    opno: Oid,
    opfuncid: Oid,
    opresulttype: Oid,
    opretset: bool,
    opcollid: Oid,
    inputcollid: Oid,
    args: [*c]List,
    location: c_int,
};
pub const OpExpr = struct_OpExpr;
pub const DistinctExpr = OpExpr;
pub const NullIfExpr = OpExpr;
pub const struct_ScalarArrayOpExpr = extern struct {
    xpr: Expr,
    opno: Oid,
    opfuncid: Oid,
    hashfuncid: Oid,
    negfuncid: Oid,
    useOr: bool,
    inputcollid: Oid,
    args: [*c]List,
    location: c_int,
};
pub const ScalarArrayOpExpr = struct_ScalarArrayOpExpr;
pub const AND_EXPR: c_int = 0;
pub const OR_EXPR: c_int = 1;
pub const NOT_EXPR: c_int = 2;
pub const enum_BoolExprType = c_uint;
pub const BoolExprType = enum_BoolExprType;
pub const struct_BoolExpr = extern struct {
    xpr: Expr,
    boolop: BoolExprType,
    args: [*c]List,
    location: c_int,
};
pub const BoolExpr = struct_BoolExpr;
pub const EXISTS_SUBLINK: c_int = 0;
pub const ALL_SUBLINK: c_int = 1;
pub const ANY_SUBLINK: c_int = 2;
pub const ROWCOMPARE_SUBLINK: c_int = 3;
pub const EXPR_SUBLINK: c_int = 4;
pub const MULTIEXPR_SUBLINK: c_int = 5;
pub const ARRAY_SUBLINK: c_int = 6;
pub const CTE_SUBLINK: c_int = 7;
pub const enum_SubLinkType = c_uint;
pub const SubLinkType = enum_SubLinkType;
pub const struct_SubLink = extern struct {
    xpr: Expr,
    subLinkType: SubLinkType,
    subLinkId: c_int,
    testexpr: [*c]Node,
    operName: [*c]List,
    subselect: [*c]Node,
    location: c_int,
};
pub const SubLink = struct_SubLink;
pub const struct_SubPlan = extern struct {
    xpr: Expr,
    subLinkType: SubLinkType,
    testexpr: [*c]Node,
    paramIds: [*c]List,
    plan_id: c_int,
    plan_name: [*c]u8,
    firstColType: Oid,
    firstColTypmod: int32,
    firstColCollation: Oid,
    useHashTable: bool,
    unknownEqFalse: bool,
    parallel_safe: bool,
    setParam: [*c]List,
    parParam: [*c]List,
    args: [*c]List,
    startup_cost: Cost,
    per_call_cost: Cost,
};
pub const SubPlan = struct_SubPlan;
pub const struct_AlternativeSubPlan = extern struct {
    xpr: Expr,
    subplans: [*c]List,
};
pub const AlternativeSubPlan = struct_AlternativeSubPlan;
pub const struct_FieldSelect = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    fieldnum: AttrNumber,
    resulttype: Oid,
    resulttypmod: int32,
    resultcollid: Oid,
};
pub const FieldSelect = struct_FieldSelect;
pub const struct_FieldStore = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    newvals: [*c]List,
    fieldnums: [*c]List,
    resulttype: Oid,
};
pub const FieldStore = struct_FieldStore;
pub const struct_RelabelType = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    resulttype: Oid,
    resulttypmod: int32,
    resultcollid: Oid,
    relabelformat: CoercionForm,
    location: c_int,
};
pub const RelabelType = struct_RelabelType;
pub const struct_CoerceViaIO = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    resulttype: Oid,
    resultcollid: Oid,
    coerceformat: CoercionForm,
    location: c_int,
};
pub const CoerceViaIO = struct_CoerceViaIO;
pub const struct_ArrayCoerceExpr = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    elemexpr: [*c]Expr,
    resulttype: Oid,
    resulttypmod: int32,
    resultcollid: Oid,
    coerceformat: CoercionForm,
    location: c_int,
};
pub const ArrayCoerceExpr = struct_ArrayCoerceExpr;
pub const struct_ConvertRowtypeExpr = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    resulttype: Oid,
    convertformat: CoercionForm,
    location: c_int,
};
pub const ConvertRowtypeExpr = struct_ConvertRowtypeExpr;
pub const struct_CollateExpr = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    collOid: Oid,
    location: c_int,
};
pub const CollateExpr = struct_CollateExpr;
pub const struct_CaseExpr = extern struct {
    xpr: Expr,
    casetype: Oid,
    casecollid: Oid,
    arg: [*c]Expr,
    args: [*c]List,
    defresult: [*c]Expr,
    location: c_int,
};
pub const CaseExpr = struct_CaseExpr;
pub const struct_CaseWhen = extern struct {
    xpr: Expr,
    expr: [*c]Expr,
    result: [*c]Expr,
    location: c_int,
};
pub const CaseWhen = struct_CaseWhen;
pub const struct_CaseTestExpr = extern struct {
    xpr: Expr,
    typeId: Oid,
    typeMod: int32,
    collation: Oid,
};
pub const CaseTestExpr = struct_CaseTestExpr;
pub const struct_ArrayExpr = extern struct {
    xpr: Expr,
    array_typeid: Oid,
    array_collid: Oid,
    element_typeid: Oid,
    elements: [*c]List,
    multidims: bool,
    location: c_int,
};
pub const ArrayExpr = struct_ArrayExpr;
pub const struct_RowExpr = extern struct {
    xpr: Expr,
    args: [*c]List,
    row_typeid: Oid,
    row_format: CoercionForm,
    colnames: [*c]List,
    location: c_int,
};
pub const RowExpr = struct_RowExpr;
pub const ROWCOMPARE_LT: c_int = 1;
pub const ROWCOMPARE_LE: c_int = 2;
pub const ROWCOMPARE_EQ: c_int = 3;
pub const ROWCOMPARE_GE: c_int = 4;
pub const ROWCOMPARE_GT: c_int = 5;
pub const ROWCOMPARE_NE: c_int = 6;
pub const enum_RowCompareType = c_uint;
pub const RowCompareType = enum_RowCompareType;
pub const struct_RowCompareExpr = extern struct {
    xpr: Expr,
    rctype: RowCompareType,
    opnos: [*c]List,
    opfamilies: [*c]List,
    inputcollids: [*c]List,
    largs: [*c]List,
    rargs: [*c]List,
};
pub const RowCompareExpr = struct_RowCompareExpr;
pub const struct_CoalesceExpr = extern struct {
    xpr: Expr,
    coalescetype: Oid,
    coalescecollid: Oid,
    args: [*c]List,
    location: c_int,
};
pub const CoalesceExpr = struct_CoalesceExpr;
pub const IS_GREATEST: c_int = 0;
pub const IS_LEAST: c_int = 1;
pub const enum_MinMaxOp = c_uint;
pub const MinMaxOp = enum_MinMaxOp;
pub const struct_MinMaxExpr = extern struct {
    xpr: Expr,
    minmaxtype: Oid,
    minmaxcollid: Oid,
    inputcollid: Oid,
    op: MinMaxOp,
    args: [*c]List,
    location: c_int,
};
pub const MinMaxExpr = struct_MinMaxExpr;
pub const SVFOP_CURRENT_DATE: c_int = 0;
pub const SVFOP_CURRENT_TIME: c_int = 1;
pub const SVFOP_CURRENT_TIME_N: c_int = 2;
pub const SVFOP_CURRENT_TIMESTAMP: c_int = 3;
pub const SVFOP_CURRENT_TIMESTAMP_N: c_int = 4;
pub const SVFOP_LOCALTIME: c_int = 5;
pub const SVFOP_LOCALTIME_N: c_int = 6;
pub const SVFOP_LOCALTIMESTAMP: c_int = 7;
pub const SVFOP_LOCALTIMESTAMP_N: c_int = 8;
pub const SVFOP_CURRENT_ROLE: c_int = 9;
pub const SVFOP_CURRENT_USER: c_int = 10;
pub const SVFOP_USER: c_int = 11;
pub const SVFOP_SESSION_USER: c_int = 12;
pub const SVFOP_CURRENT_CATALOG: c_int = 13;
pub const SVFOP_CURRENT_SCHEMA: c_int = 14;
pub const enum_SQLValueFunctionOp = c_uint;
pub const SQLValueFunctionOp = enum_SQLValueFunctionOp;
pub const struct_SQLValueFunction = extern struct {
    xpr: Expr,
    op: SQLValueFunctionOp,
    type: Oid,
    typmod: int32,
    location: c_int,
};
pub const SQLValueFunction = struct_SQLValueFunction;
pub const IS_XMLCONCAT: c_int = 0;
pub const IS_XMLELEMENT: c_int = 1;
pub const IS_XMLFOREST: c_int = 2;
pub const IS_XMLPARSE: c_int = 3;
pub const IS_XMLPI: c_int = 4;
pub const IS_XMLROOT: c_int = 5;
pub const IS_XMLSERIALIZE: c_int = 6;
pub const IS_DOCUMENT: c_int = 7;
pub const enum_XmlExprOp = c_uint;
pub const XmlExprOp = enum_XmlExprOp;
pub const XMLOPTION_DOCUMENT: c_int = 0;
pub const XMLOPTION_CONTENT: c_int = 1;
pub const enum_XmlOptionType = c_uint;
pub const XmlOptionType = enum_XmlOptionType;
pub const struct_XmlExpr = extern struct {
    xpr: Expr,
    op: XmlExprOp,
    name: [*c]u8,
    named_args: [*c]List,
    arg_names: [*c]List,
    args: [*c]List,
    xmloption: XmlOptionType,
    indent: bool,
    type: Oid,
    typmod: int32,
    location: c_int,
};
pub const XmlExpr = struct_XmlExpr;
pub const JS_ENC_DEFAULT: c_int = 0;
pub const JS_ENC_UTF8: c_int = 1;
pub const JS_ENC_UTF16: c_int = 2;
pub const JS_ENC_UTF32: c_int = 3;
pub const enum_JsonEncoding = c_uint;
pub const JsonEncoding = enum_JsonEncoding;
pub const JS_FORMAT_DEFAULT: c_int = 0;
pub const JS_FORMAT_JSON: c_int = 1;
pub const JS_FORMAT_JSONB: c_int = 2;
pub const enum_JsonFormatType = c_uint;
pub const JsonFormatType = enum_JsonFormatType;
pub const struct_JsonFormat = extern struct {
    type: NodeTag,
    format_type: JsonFormatType,
    encoding: JsonEncoding,
    location: c_int,
};
pub const JsonFormat = struct_JsonFormat;
pub const struct_JsonReturning = extern struct {
    type: NodeTag,
    format: [*c]JsonFormat,
    typid: Oid,
    typmod: int32,
};
pub const JsonReturning = struct_JsonReturning;
pub const struct_JsonValueExpr = extern struct {
    type: NodeTag,
    raw_expr: [*c]Expr,
    formatted_expr: [*c]Expr,
    format: [*c]JsonFormat,
};
pub const JsonValueExpr = struct_JsonValueExpr;
pub const JSCTOR_JSON_OBJECT: c_int = 1;
pub const JSCTOR_JSON_ARRAY: c_int = 2;
pub const JSCTOR_JSON_OBJECTAGG: c_int = 3;
pub const JSCTOR_JSON_ARRAYAGG: c_int = 4;
pub const enum_JsonConstructorType = c_uint;
pub const JsonConstructorType = enum_JsonConstructorType;
pub const struct_JsonConstructorExpr = extern struct {
    xpr: Expr,
    type: JsonConstructorType,
    args: [*c]List,
    func: [*c]Expr,
    coercion: [*c]Expr,
    returning: [*c]JsonReturning,
    absent_on_null: bool,
    unique: bool,
    location: c_int,
};
pub const JsonConstructorExpr = struct_JsonConstructorExpr;
pub const JS_TYPE_ANY: c_int = 0;
pub const JS_TYPE_OBJECT: c_int = 1;
pub const JS_TYPE_ARRAY: c_int = 2;
pub const JS_TYPE_SCALAR: c_int = 3;
pub const enum_JsonValueType = c_uint;
pub const JsonValueType = enum_JsonValueType;
pub const struct_JsonIsPredicate = extern struct {
    type: NodeTag,
    expr: [*c]Node,
    format: [*c]JsonFormat,
    item_type: JsonValueType,
    unique_keys: bool,
    location: c_int,
};
pub const JsonIsPredicate = struct_JsonIsPredicate;
pub const IS_NULL: c_int = 0;
pub const IS_NOT_NULL: c_int = 1;
pub const enum_NullTestType = c_uint;
pub const NullTestType = enum_NullTestType;
pub const struct_NullTest = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    nulltesttype: NullTestType,
    argisrow: bool,
    location: c_int,
};
pub const NullTest = struct_NullTest;
pub const IS_TRUE: c_int = 0;
pub const IS_NOT_TRUE: c_int = 1;
pub const IS_FALSE: c_int = 2;
pub const IS_NOT_FALSE: c_int = 3;
pub const IS_UNKNOWN: c_int = 4;
pub const IS_NOT_UNKNOWN: c_int = 5;
pub const enum_BoolTestType = c_uint;
pub const BoolTestType = enum_BoolTestType;
pub const struct_BooleanTest = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    booltesttype: BoolTestType,
    location: c_int,
};
pub const BooleanTest = struct_BooleanTest;
pub const struct_CoerceToDomain = extern struct {
    xpr: Expr,
    arg: [*c]Expr,
    resulttype: Oid,
    resulttypmod: int32,
    resultcollid: Oid,
    coercionformat: CoercionForm,
    location: c_int,
};
pub const CoerceToDomain = struct_CoerceToDomain;
pub const struct_CoerceToDomainValue = extern struct {
    xpr: Expr,
    typeId: Oid,
    typeMod: int32,
    collation: Oid,
    location: c_int,
};
pub const CoerceToDomainValue = struct_CoerceToDomainValue;
pub const struct_SetToDefault = extern struct {
    xpr: Expr,
    typeId: Oid,
    typeMod: int32,
    collation: Oid,
    location: c_int,
};
pub const SetToDefault = struct_SetToDefault;
pub const struct_CurrentOfExpr = extern struct {
    xpr: Expr,
    cvarno: Index,
    cursor_name: [*c]u8,
    cursor_param: c_int,
};
pub const CurrentOfExpr = struct_CurrentOfExpr;
pub const struct_NextValueExpr = extern struct {
    xpr: Expr,
    seqid: Oid,
    typeId: Oid,
};
pub const NextValueExpr = struct_NextValueExpr;
pub const struct_InferenceElem = extern struct {
    xpr: Expr,
    expr: [*c]Node,
    infercollid: Oid,
    inferopclass: Oid,
};
pub const InferenceElem = struct_InferenceElem;
pub const struct_TargetEntry = extern struct {
    xpr: Expr,
    expr: [*c]Expr,
    resno: AttrNumber,
    resname: [*c]u8,
    ressortgroupref: Index,
    resorigtbl: Oid,
    resorigcol: AttrNumber,
    resjunk: bool,
};
pub const TargetEntry = struct_TargetEntry;
pub const struct_RangeTblRef = extern struct {
    type: NodeTag,
    rtindex: c_int,
};
pub const RangeTblRef = struct_RangeTblRef;
pub const struct_JoinExpr = extern struct {
    type: NodeTag,
    jointype: JoinType,
    isNatural: bool,
    larg: [*c]Node,
    rarg: [*c]Node,
    usingClause: [*c]List,
    join_using_alias: [*c]Alias,
    quals: [*c]Node,
    alias: [*c]Alias,
    rtindex: c_int,
};
pub const JoinExpr = struct_JoinExpr;
pub const struct_FromExpr = extern struct {
    type: NodeTag,
    fromlist: [*c]List,
    quals: [*c]Node,
};
pub const FromExpr = struct_FromExpr;
pub const struct_OnConflictExpr = extern struct {
    type: NodeTag,
    action: OnConflictAction,
    arbiterElems: [*c]List,
    arbiterWhere: [*c]Node,
    constraint: Oid,
    onConflictSet: [*c]List,
    onConflictWhere: [*c]Node,
    exclRelIndex: c_int,
    exclRelTlist: [*c]List,
};
pub const OnConflictExpr = struct_OnConflictExpr;
pub const struct_Integer = extern struct {
    type: NodeTag,
    ival: c_int,
};
pub const Integer = struct_Integer;
pub const struct_Float = extern struct {
    type: NodeTag,
    fval: [*c]u8,
};
pub const Float = struct_Float;
pub const struct_Boolean = extern struct {
    type: NodeTag,
    boolval: bool,
};
pub const Boolean = struct_Boolean;
pub const struct_String = extern struct {
    type: NodeTag,
    sval: [*c]u8,
};
pub const String = struct_String;
pub const struct_BitString = extern struct {
    type: NodeTag,
    bsval: [*c]u8,
};
pub const BitString = struct_BitString;
pub extern fn makeInteger(i: c_int) [*c]Integer;
pub extern fn makeFloat(numericStr: [*c]u8) [*c]Float;
pub extern fn makeBoolean(val: bool) [*c]Boolean;
pub extern fn makeString(str: [*c]u8) [*c]String;
pub extern fn makeBitString(str: [*c]u8) [*c]BitString;
pub const struct_PartitionBoundInfoData = opaque {};
pub const PartitionBoundInfo = ?*struct_PartitionBoundInfoData;
pub const struct_PartitionKeyData = opaque {};
pub const PartitionKey = ?*struct_PartitionKeyData;
pub const struct_PartitionBoundSpec = extern struct {
    type: NodeTag,
    strategy: u8,
    is_default: bool,
    modulus: c_int,
    remainder: c_int,
    listdatums: [*c]List,
    lowerdatums: [*c]List,
    upperdatums: [*c]List,
    location: c_int,
};
pub const PartitionBoundSpec = struct_PartitionBoundSpec;
pub const struct_PartitionDescData = opaque {};
pub const PartitionDesc = ?*struct_PartitionDescData;
pub const struct_PartitionDirectoryData = opaque {};
pub const PartitionDirectory = ?*struct_PartitionDirectoryData;
pub const OVERRIDING_NOT_SET: c_int = 0;
pub const OVERRIDING_USER_VALUE: c_int = 1;
pub const OVERRIDING_SYSTEM_VALUE: c_int = 2;
pub const enum_OverridingKind = c_uint;
pub const OverridingKind = enum_OverridingKind;
pub const QSRC_ORIGINAL: c_int = 0;
pub const QSRC_PARSER: c_int = 1;
pub const QSRC_INSTEAD_RULE: c_int = 2;
pub const QSRC_QUAL_INSTEAD_RULE: c_int = 3;
pub const QSRC_NON_INSTEAD_RULE: c_int = 4;
pub const enum_QuerySource = c_uint;
pub const QuerySource = enum_QuerySource;
pub const SORTBY_DEFAULT: c_int = 0;
pub const SORTBY_ASC: c_int = 1;
pub const SORTBY_DESC: c_int = 2;
pub const SORTBY_USING: c_int = 3;
pub const enum_SortByDir = c_uint;
pub const SortByDir = enum_SortByDir;
pub const SORTBY_NULLS_DEFAULT: c_int = 0;
pub const SORTBY_NULLS_FIRST: c_int = 1;
pub const SORTBY_NULLS_LAST: c_int = 2;
pub const enum_SortByNulls = c_uint;
pub const SortByNulls = enum_SortByNulls;
pub const SET_QUANTIFIER_DEFAULT: c_int = 0;
pub const SET_QUANTIFIER_ALL: c_int = 1;
pub const SET_QUANTIFIER_DISTINCT: c_int = 2;
pub const enum_SetQuantifier = c_uint;
pub const SetQuantifier = enum_SetQuantifier;
pub const AclMode = uint64;
pub const struct_Query = extern struct {
    type: NodeTag,
    commandType: CmdType,
    querySource: QuerySource,
    queryId: uint64,
    canSetTag: bool,
    utilityStmt: [*c]Node,
    resultRelation: c_int,
    hasAggs: bool,
    hasWindowFuncs: bool,
    hasTargetSRFs: bool,
    hasSubLinks: bool,
    hasDistinctOn: bool,
    hasRecursive: bool,
    hasModifyingCTE: bool,
    hasForUpdate: bool,
    hasRowSecurity: bool,
    isReturn: bool,
    cteList: [*c]List,
    rtable: [*c]List,
    rteperminfos: [*c]List,
    jointree: [*c]FromExpr,
    mergeActionList: [*c]List,
    mergeUseOuterJoin: bool,
    targetList: [*c]List,
    override: OverridingKind,
    onConflict: [*c]OnConflictExpr,
    returningList: [*c]List,
    groupClause: [*c]List,
    groupDistinct: bool,
    groupingSets: [*c]List,
    havingQual: [*c]Node,
    windowClause: [*c]List,
    distinctClause: [*c]List,
    sortClause: [*c]List,
    limitOffset: [*c]Node,
    limitCount: [*c]Node,
    limitOption: LimitOption,
    rowMarks: [*c]List,
    setOperations: [*c]Node,
    constraintDeps: [*c]List,
    withCheckOptions: [*c]List,
    stmt_location: c_int,
    stmt_len: c_int,
};
pub const Query = struct_Query;
pub const struct_TypeName = extern struct {
    type: NodeTag,
    names: [*c]List,
    typeOid: Oid,
    setof: bool,
    pct_type: bool,
    typmods: [*c]List,
    typemod: int32,
    arrayBounds: [*c]List,
    location: c_int,
};
pub const TypeName = struct_TypeName;
pub const struct_ColumnRef = extern struct {
    type: NodeTag,
    fields: [*c]List,
    location: c_int,
};
pub const ColumnRef = struct_ColumnRef;
pub const struct_ParamRef = extern struct {
    type: NodeTag,
    number: c_int,
    location: c_int,
};
pub const ParamRef = struct_ParamRef;
pub const AEXPR_OP: c_int = 0;
pub const AEXPR_OP_ANY: c_int = 1;
pub const AEXPR_OP_ALL: c_int = 2;
pub const AEXPR_DISTINCT: c_int = 3;
pub const AEXPR_NOT_DISTINCT: c_int = 4;
pub const AEXPR_NULLIF: c_int = 5;
pub const AEXPR_IN: c_int = 6;
pub const AEXPR_LIKE: c_int = 7;
pub const AEXPR_ILIKE: c_int = 8;
pub const AEXPR_SIMILAR: c_int = 9;
pub const AEXPR_BETWEEN: c_int = 10;
pub const AEXPR_NOT_BETWEEN: c_int = 11;
pub const AEXPR_BETWEEN_SYM: c_int = 12;
pub const AEXPR_NOT_BETWEEN_SYM: c_int = 13;
pub const enum_A_Expr_Kind = c_uint;
pub const A_Expr_Kind = enum_A_Expr_Kind;
pub const struct_A_Expr = extern struct {
    type: NodeTag,
    kind: A_Expr_Kind,
    name: [*c]List,
    lexpr: [*c]Node,
    rexpr: [*c]Node,
    location: c_int,
};
pub const A_Expr = struct_A_Expr;
pub const union_ValUnion = extern union {
    node: Node,
    ival: Integer,
    fval: Float,
    boolval: Boolean,
    sval: String,
    bsval: BitString,
};
pub const struct_A_Const = extern struct {
    type: NodeTag,
    val: union_ValUnion,
    isnull: bool,
    location: c_int,
};
pub const A_Const = struct_A_Const;
pub const struct_TypeCast = extern struct {
    type: NodeTag,
    arg: [*c]Node,
    typeName: [*c]TypeName,
    location: c_int,
};
pub const TypeCast = struct_TypeCast;
pub const struct_CollateClause = extern struct {
    type: NodeTag,
    arg: [*c]Node,
    collname: [*c]List,
    location: c_int,
};
pub const CollateClause = struct_CollateClause;
pub const ROLESPEC_CSTRING: c_int = 0;
pub const ROLESPEC_CURRENT_ROLE: c_int = 1;
pub const ROLESPEC_CURRENT_USER: c_int = 2;
pub const ROLESPEC_SESSION_USER: c_int = 3;
pub const ROLESPEC_PUBLIC: c_int = 4;
pub const enum_RoleSpecType = c_uint;
pub const RoleSpecType = enum_RoleSpecType;
pub const struct_RoleSpec = extern struct {
    type: NodeTag,
    roletype: RoleSpecType,
    rolename: [*c]u8,
    location: c_int,
};
pub const RoleSpec = struct_RoleSpec;
pub const struct_WindowDef = extern struct {
    type: NodeTag,
    name: [*c]u8,
    refname: [*c]u8,
    partitionClause: [*c]List,
    orderClause: [*c]List,
    frameOptions: c_int,
    startOffset: [*c]Node,
    endOffset: [*c]Node,
    location: c_int,
};
pub const struct_FuncCall = extern struct {
    type: NodeTag,
    funcname: [*c]List,
    args: [*c]List,
    agg_order: [*c]List,
    agg_filter: [*c]Node,
    over: [*c]struct_WindowDef,
    agg_within_group: bool,
    agg_star: bool,
    agg_distinct: bool,
    func_variadic: bool,
    funcformat: CoercionForm,
    location: c_int,
};
pub const FuncCall = struct_FuncCall;
pub const struct_A_Star = extern struct {
    type: NodeTag,
};
pub const A_Star = struct_A_Star;
pub const struct_A_Indices = extern struct {
    type: NodeTag,
    is_slice: bool,
    lidx: [*c]Node,
    uidx: [*c]Node,
};
pub const A_Indices = struct_A_Indices;
pub const struct_A_Indirection = extern struct {
    type: NodeTag,
    arg: [*c]Node,
    indirection: [*c]List,
};
pub const A_Indirection = struct_A_Indirection;
pub const struct_A_ArrayExpr = extern struct {
    type: NodeTag,
    elements: [*c]List,
    location: c_int,
};
pub const A_ArrayExpr = struct_A_ArrayExpr;
pub const struct_ResTarget = extern struct {
    type: NodeTag,
    name: [*c]u8,
    indirection: [*c]List,
    val: [*c]Node,
    location: c_int,
};
pub const ResTarget = struct_ResTarget;
pub const struct_MultiAssignRef = extern struct {
    type: NodeTag,
    source: [*c]Node,
    colno: c_int,
    ncolumns: c_int,
};
pub const MultiAssignRef = struct_MultiAssignRef;
pub const struct_SortBy = extern struct {
    type: NodeTag,
    node: [*c]Node,
    sortby_dir: SortByDir,
    sortby_nulls: SortByNulls,
    useOp: [*c]List,
    location: c_int,
};
pub const SortBy = struct_SortBy;
pub const WindowDef = struct_WindowDef;
pub const struct_RangeSubselect = extern struct {
    type: NodeTag,
    lateral: bool,
    subquery: [*c]Node,
    alias: [*c]Alias,
};
pub const RangeSubselect = struct_RangeSubselect;
pub const struct_RangeFunction = extern struct {
    type: NodeTag,
    lateral: bool,
    ordinality: bool,
    is_rowsfrom: bool,
    functions: [*c]List,
    alias: [*c]Alias,
    coldeflist: [*c]List,
};
pub const RangeFunction = struct_RangeFunction;
pub const struct_RangeTableFunc = extern struct {
    type: NodeTag,
    lateral: bool,
    docexpr: [*c]Node,
    rowexpr: [*c]Node,
    namespaces: [*c]List,
    columns: [*c]List,
    alias: [*c]Alias,
    location: c_int,
};
pub const RangeTableFunc = struct_RangeTableFunc;
pub const struct_RangeTableFuncCol = extern struct {
    type: NodeTag,
    colname: [*c]u8,
    typeName: [*c]TypeName,
    for_ordinality: bool,
    is_not_null: bool,
    colexpr: [*c]Node,
    coldefexpr: [*c]Node,
    location: c_int,
};
pub const RangeTableFuncCol = struct_RangeTableFuncCol;
pub const struct_RangeTableSample = extern struct {
    type: NodeTag,
    relation: [*c]Node,
    method: [*c]List,
    args: [*c]List,
    repeatable: [*c]Node,
    location: c_int,
};
pub const RangeTableSample = struct_RangeTableSample;
pub const struct_ColumnDef = extern struct {
    type: NodeTag,
    colname: [*c]u8,
    typeName: [*c]TypeName,
    compression: [*c]u8,
    inhcount: c_int,
    is_local: bool,
    is_not_null: bool,
    is_from_type: bool,
    storage: u8,
    storage_name: [*c]u8,
    raw_default: [*c]Node,
    cooked_default: [*c]Node,
    identity: u8,
    identitySequence: [*c]RangeVar,
    generated: u8,
    collClause: [*c]CollateClause,
    collOid: Oid,
    constraints: [*c]List,
    fdwoptions: [*c]List,
    location: c_int,
};
pub const ColumnDef = struct_ColumnDef;
pub const struct_TableLikeClause = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    options: bits32,
    relationOid: Oid,
};
pub const TableLikeClause = struct_TableLikeClause;
pub const CREATE_TABLE_LIKE_COMMENTS: c_int = 1;
pub const CREATE_TABLE_LIKE_COMPRESSION: c_int = 2;
pub const CREATE_TABLE_LIKE_CONSTRAINTS: c_int = 4;
pub const CREATE_TABLE_LIKE_DEFAULTS: c_int = 8;
pub const CREATE_TABLE_LIKE_GENERATED: c_int = 16;
pub const CREATE_TABLE_LIKE_IDENTITY: c_int = 32;
pub const CREATE_TABLE_LIKE_INDEXES: c_int = 64;
pub const CREATE_TABLE_LIKE_STATISTICS: c_int = 128;
pub const CREATE_TABLE_LIKE_STORAGE: c_int = 256;
pub const CREATE_TABLE_LIKE_ALL: c_int = 2147483647;
pub const enum_TableLikeOption = c_uint;
pub const TableLikeOption = enum_TableLikeOption;
pub const struct_IndexElem = extern struct {
    type: NodeTag,
    name: [*c]u8,
    expr: [*c]Node,
    indexcolname: [*c]u8,
    collation: [*c]List,
    opclass: [*c]List,
    opclassopts: [*c]List,
    ordering: SortByDir,
    nulls_ordering: SortByNulls,
};
pub const IndexElem = struct_IndexElem;
pub const DEFELEM_UNSPEC: c_int = 0;
pub const DEFELEM_SET: c_int = 1;
pub const DEFELEM_ADD: c_int = 2;
pub const DEFELEM_DROP: c_int = 3;
pub const enum_DefElemAction = c_uint;
pub const DefElemAction = enum_DefElemAction;
pub const struct_DefElem = extern struct {
    type: NodeTag,
    defnamespace: [*c]u8,
    defname: [*c]u8,
    arg: [*c]Node,
    defaction: DefElemAction,
    location: c_int,
};
pub const DefElem = struct_DefElem;
pub const struct_LockingClause = extern struct {
    type: NodeTag,
    lockedRels: [*c]List,
    strength: LockClauseStrength,
    waitPolicy: LockWaitPolicy,
};
pub const LockingClause = struct_LockingClause;
pub const struct_XmlSerialize = extern struct {
    type: NodeTag,
    xmloption: XmlOptionType,
    expr: [*c]Node,
    typeName: [*c]TypeName,
    indent: bool,
    location: c_int,
};
pub const XmlSerialize = struct_XmlSerialize;
pub const struct_PartitionElem = extern struct {
    type: NodeTag,
    name: [*c]u8,
    expr: [*c]Node,
    collation: [*c]List,
    opclass: [*c]List,
    location: c_int,
};
pub const PartitionElem = struct_PartitionElem;
pub const PARTITION_STRATEGY_LIST: c_int = 108;
pub const PARTITION_STRATEGY_RANGE: c_int = 114;
pub const PARTITION_STRATEGY_HASH: c_int = 104;
pub const enum_PartitionStrategy = c_uint;
pub const PartitionStrategy = enum_PartitionStrategy;
pub const struct_PartitionSpec = extern struct {
    type: NodeTag,
    strategy: PartitionStrategy,
    partParams: [*c]List,
    location: c_int,
};
pub const PartitionSpec = struct_PartitionSpec;
pub const PARTITION_RANGE_DATUM_MINVALUE: c_int = -1;
pub const PARTITION_RANGE_DATUM_VALUE: c_int = 0;
pub const PARTITION_RANGE_DATUM_MAXVALUE: c_int = 1;
pub const enum_PartitionRangeDatumKind = c_int;
pub const PartitionRangeDatumKind = enum_PartitionRangeDatumKind;
pub const struct_PartitionRangeDatum = extern struct {
    type: NodeTag,
    kind: PartitionRangeDatumKind,
    value: [*c]Node,
    location: c_int,
};
pub const PartitionRangeDatum = struct_PartitionRangeDatum;
pub const struct_PartitionCmd = extern struct {
    type: NodeTag,
    name: [*c]RangeVar,
    bound: [*c]PartitionBoundSpec,
    concurrent: bool,
};
pub const PartitionCmd = struct_PartitionCmd;
pub const RTE_RELATION: c_int = 0;
pub const RTE_SUBQUERY: c_int = 1;
pub const RTE_JOIN: c_int = 2;
pub const RTE_FUNCTION: c_int = 3;
pub const RTE_TABLEFUNC: c_int = 4;
pub const RTE_VALUES: c_int = 5;
pub const RTE_CTE: c_int = 6;
pub const RTE_NAMEDTUPLESTORE: c_int = 7;
pub const RTE_RESULT: c_int = 8;
pub const enum_RTEKind = c_uint;
pub const RTEKind = enum_RTEKind;
pub const struct_TableSampleClause = extern struct {
    type: NodeTag,
    tsmhandler: Oid,
    args: [*c]List,
    repeatable: [*c]Expr,
};
pub const struct_RangeTblEntry = extern struct {
    type: NodeTag,
    rtekind: RTEKind,
    relid: Oid,
    relkind: u8,
    rellockmode: c_int,
    tablesample: [*c]struct_TableSampleClause,
    perminfoindex: Index,
    subquery: [*c]Query,
    security_barrier: bool,
    jointype: JoinType,
    joinmergedcols: c_int,
    joinaliasvars: [*c]List,
    joinleftcols: [*c]List,
    joinrightcols: [*c]List,
    join_using_alias: [*c]Alias,
    functions: [*c]List,
    funcordinality: bool,
    tablefunc: [*c]TableFunc,
    values_lists: [*c]List,
    ctename: [*c]u8,
    ctelevelsup: Index,
    self_reference: bool,
    coltypes: [*c]List,
    coltypmods: [*c]List,
    colcollations: [*c]List,
    enrname: [*c]u8,
    enrtuples: Cardinality,
    alias: [*c]Alias,
    eref: [*c]Alias,
    lateral: bool,
    inh: bool,
    inFromCl: bool,
    securityQuals: [*c]List,
};
pub const RangeTblEntry = struct_RangeTblEntry;
pub const struct_RTEPermissionInfo = extern struct {
    type: NodeTag,
    relid: Oid,
    inh: bool,
    requiredPerms: AclMode,
    checkAsUser: Oid,
    selectedCols: [*c]Bitmapset,
    insertedCols: [*c]Bitmapset,
    updatedCols: [*c]Bitmapset,
};
pub const RTEPermissionInfo = struct_RTEPermissionInfo;
pub const struct_RangeTblFunction = extern struct {
    type: NodeTag,
    funcexpr: [*c]Node,
    funccolcount: c_int,
    funccolnames: [*c]List,
    funccoltypes: [*c]List,
    funccoltypmods: [*c]List,
    funccolcollations: [*c]List,
    funcparams: [*c]Bitmapset,
};
pub const RangeTblFunction = struct_RangeTblFunction;
pub const TableSampleClause = struct_TableSampleClause;
pub const WCO_VIEW_CHECK: c_int = 0;
pub const WCO_RLS_INSERT_CHECK: c_int = 1;
pub const WCO_RLS_UPDATE_CHECK: c_int = 2;
pub const WCO_RLS_CONFLICT_CHECK: c_int = 3;
pub const WCO_RLS_MERGE_UPDATE_CHECK: c_int = 4;
pub const WCO_RLS_MERGE_DELETE_CHECK: c_int = 5;
pub const enum_WCOKind = c_uint;
pub const WCOKind = enum_WCOKind;
pub const struct_WithCheckOption = extern struct {
    type: NodeTag,
    kind: WCOKind,
    relname: [*c]u8,
    polname: [*c]u8,
    qual: [*c]Node,
    cascaded: bool,
};
pub const WithCheckOption = struct_WithCheckOption;
pub const struct_SortGroupClause = extern struct {
    type: NodeTag,
    tleSortGroupRef: Index,
    eqop: Oid,
    sortop: Oid,
    nulls_first: bool,
    hashable: bool,
};
pub const SortGroupClause = struct_SortGroupClause;
pub const GROUPING_SET_EMPTY: c_int = 0;
pub const GROUPING_SET_SIMPLE: c_int = 1;
pub const GROUPING_SET_ROLLUP: c_int = 2;
pub const GROUPING_SET_CUBE: c_int = 3;
pub const GROUPING_SET_SETS: c_int = 4;
pub const enum_GroupingSetKind = c_uint;
pub const GroupingSetKind = enum_GroupingSetKind;
pub const struct_GroupingSet = extern struct {
    type: NodeTag,
    kind: GroupingSetKind,
    content: [*c]List,
    location: c_int,
};
pub const GroupingSet = struct_GroupingSet;
pub const struct_WindowClause = extern struct {
    type: NodeTag,
    name: [*c]u8,
    refname: [*c]u8,
    partitionClause: [*c]List,
    orderClause: [*c]List,
    frameOptions: c_int,
    startOffset: [*c]Node,
    endOffset: [*c]Node,
    runCondition: [*c]List,
    startInRangeFunc: Oid,
    endInRangeFunc: Oid,
    inRangeColl: Oid,
    inRangeAsc: bool,
    inRangeNullsFirst: bool,
    winref: Index,
    copiedOrder: bool,
};
pub const WindowClause = struct_WindowClause;
pub const struct_RowMarkClause = extern struct {
    type: NodeTag,
    rti: Index,
    strength: LockClauseStrength,
    waitPolicy: LockWaitPolicy,
    pushedDown: bool,
};
pub const RowMarkClause = struct_RowMarkClause;
pub const struct_WithClause = extern struct {
    type: NodeTag,
    ctes: [*c]List,
    recursive: bool,
    location: c_int,
};
pub const WithClause = struct_WithClause;
pub const struct_InferClause = extern struct {
    type: NodeTag,
    indexElems: [*c]List,
    whereClause: [*c]Node,
    conname: [*c]u8,
    location: c_int,
};
pub const InferClause = struct_InferClause;
pub const struct_OnConflictClause = extern struct {
    type: NodeTag,
    action: OnConflictAction,
    infer: [*c]InferClause,
    targetList: [*c]List,
    whereClause: [*c]Node,
    location: c_int,
};
pub const OnConflictClause = struct_OnConflictClause;
pub const CTEMaterializeDefault: c_int = 0;
pub const CTEMaterializeAlways: c_int = 1;
pub const CTEMaterializeNever: c_int = 2;
pub const enum_CTEMaterialize = c_uint;
pub const CTEMaterialize = enum_CTEMaterialize;
pub const struct_CTESearchClause = extern struct {
    type: NodeTag,
    search_col_list: [*c]List,
    search_breadth_first: bool,
    search_seq_column: [*c]u8,
    location: c_int,
};
pub const CTESearchClause = struct_CTESearchClause;
pub const struct_CTECycleClause = extern struct {
    type: NodeTag,
    cycle_col_list: [*c]List,
    cycle_mark_column: [*c]u8,
    cycle_mark_value: [*c]Node,
    cycle_mark_default: [*c]Node,
    cycle_path_column: [*c]u8,
    location: c_int,
    cycle_mark_type: Oid,
    cycle_mark_typmod: c_int,
    cycle_mark_collation: Oid,
    cycle_mark_neop: Oid,
};
pub const CTECycleClause = struct_CTECycleClause;
pub const struct_CommonTableExpr = extern struct {
    type: NodeTag,
    ctename: [*c]u8,
    aliascolnames: [*c]List,
    ctematerialized: CTEMaterialize,
    ctequery: [*c]Node,
    search_clause: [*c]CTESearchClause,
    cycle_clause: [*c]CTECycleClause,
    location: c_int,
    cterecursive: bool,
    cterefcount: c_int,
    ctecolnames: [*c]List,
    ctecoltypes: [*c]List,
    ctecoltypmods: [*c]List,
    ctecolcollations: [*c]List,
};
pub const CommonTableExpr = struct_CommonTableExpr;
pub const struct_MergeWhenClause = extern struct {
    type: NodeTag,
    matched: bool,
    commandType: CmdType,
    override: OverridingKind,
    condition: [*c]Node,
    targetList: [*c]List,
    values: [*c]List,
};
pub const MergeWhenClause = struct_MergeWhenClause;
pub const struct_MergeAction = extern struct {
    type: NodeTag,
    matched: bool,
    commandType: CmdType,
    override: OverridingKind,
    qual: [*c]Node,
    targetList: [*c]List,
    updateColnos: [*c]List,
};
pub const MergeAction = struct_MergeAction;
pub const struct_TriggerTransition = extern struct {
    type: NodeTag,
    name: [*c]u8,
    isNew: bool,
    isTable: bool,
};
pub const TriggerTransition = struct_TriggerTransition;
pub const struct_JsonOutput = extern struct {
    type: NodeTag,
    typeName: [*c]TypeName,
    returning: [*c]JsonReturning,
};
pub const JsonOutput = struct_JsonOutput;
pub const struct_JsonKeyValue = extern struct {
    type: NodeTag,
    key: [*c]Expr,
    value: [*c]JsonValueExpr,
};
pub const JsonKeyValue = struct_JsonKeyValue;
pub const struct_JsonObjectConstructor = extern struct {
    type: NodeTag,
    exprs: [*c]List,
    output: [*c]JsonOutput,
    absent_on_null: bool,
    unique: bool,
    location: c_int,
};
pub const JsonObjectConstructor = struct_JsonObjectConstructor;
pub const struct_JsonArrayConstructor = extern struct {
    type: NodeTag,
    exprs: [*c]List,
    output: [*c]JsonOutput,
    absent_on_null: bool,
    location: c_int,
};
pub const JsonArrayConstructor = struct_JsonArrayConstructor;
pub const struct_JsonArrayQueryConstructor = extern struct {
    type: NodeTag,
    query: [*c]Node,
    output: [*c]JsonOutput,
    format: [*c]JsonFormat,
    absent_on_null: bool,
    location: c_int,
};
pub const JsonArrayQueryConstructor = struct_JsonArrayQueryConstructor;
pub const struct_JsonAggConstructor = extern struct {
    type: NodeTag,
    output: [*c]JsonOutput,
    agg_filter: [*c]Node,
    agg_order: [*c]List,
    over: [*c]struct_WindowDef,
    location: c_int,
};
pub const JsonAggConstructor = struct_JsonAggConstructor;
pub const struct_JsonObjectAgg = extern struct {
    type: NodeTag,
    constructor: [*c]JsonAggConstructor,
    arg: [*c]JsonKeyValue,
    absent_on_null: bool,
    unique: bool,
};
pub const JsonObjectAgg = struct_JsonObjectAgg;
pub const struct_JsonArrayAgg = extern struct {
    type: NodeTag,
    constructor: [*c]JsonAggConstructor,
    arg: [*c]JsonValueExpr,
    absent_on_null: bool,
};
pub const JsonArrayAgg = struct_JsonArrayAgg;
pub const struct_RawStmt = extern struct {
    type: NodeTag,
    stmt: [*c]Node,
    stmt_location: c_int,
    stmt_len: c_int,
};
pub const RawStmt = struct_RawStmt;
pub const struct_InsertStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    cols: [*c]List,
    selectStmt: [*c]Node,
    onConflictClause: [*c]OnConflictClause,
    returningList: [*c]List,
    withClause: [*c]WithClause,
    override: OverridingKind,
};
pub const InsertStmt = struct_InsertStmt;
pub const struct_DeleteStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    usingClause: [*c]List,
    whereClause: [*c]Node,
    returningList: [*c]List,
    withClause: [*c]WithClause,
};
pub const DeleteStmt = struct_DeleteStmt;
pub const struct_UpdateStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    targetList: [*c]List,
    whereClause: [*c]Node,
    fromClause: [*c]List,
    returningList: [*c]List,
    withClause: [*c]WithClause,
};
pub const UpdateStmt = struct_UpdateStmt;
pub const struct_MergeStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    sourceRelation: [*c]Node,
    joinCondition: [*c]Node,
    mergeWhenClauses: [*c]List,
    withClause: [*c]WithClause,
};
pub const MergeStmt = struct_MergeStmt;
pub const SETOP_NONE: c_int = 0;
pub const SETOP_UNION: c_int = 1;
pub const SETOP_INTERSECT: c_int = 2;
pub const SETOP_EXCEPT: c_int = 3;
pub const enum_SetOperation = c_uint;
pub const SetOperation = enum_SetOperation;
pub const struct_SelectStmt = extern struct {
    type: NodeTag,
    distinctClause: [*c]List,
    intoClause: [*c]IntoClause,
    targetList: [*c]List,
    fromClause: [*c]List,
    whereClause: [*c]Node,
    groupClause: [*c]List,
    groupDistinct: bool,
    havingClause: [*c]Node,
    windowClause: [*c]List,
    valuesLists: [*c]List,
    sortClause: [*c]List,
    limitOffset: [*c]Node,
    limitCount: [*c]Node,
    limitOption: LimitOption,
    lockingClause: [*c]List,
    withClause: [*c]WithClause,
    op: SetOperation,
    all: bool,
    larg: [*c]struct_SelectStmt,
    rarg: [*c]struct_SelectStmt,
};
pub const SelectStmt = struct_SelectStmt;
pub const struct_SetOperationStmt = extern struct {
    type: NodeTag,
    op: SetOperation,
    all: bool,
    larg: [*c]Node,
    rarg: [*c]Node,
    colTypes: [*c]List,
    colTypmods: [*c]List,
    colCollations: [*c]List,
    groupClauses: [*c]List,
};
pub const SetOperationStmt = struct_SetOperationStmt;
pub const struct_ReturnStmt = extern struct {
    type: NodeTag,
    returnval: [*c]Node,
};
pub const ReturnStmt = struct_ReturnStmt;
pub const struct_PLAssignStmt = extern struct {
    type: NodeTag,
    name: [*c]u8,
    indirection: [*c]List,
    nnames: c_int,
    val: [*c]SelectStmt,
    location: c_int,
};
pub const PLAssignStmt = struct_PLAssignStmt;
pub const OBJECT_ACCESS_METHOD: c_int = 0;
pub const OBJECT_AGGREGATE: c_int = 1;
pub const OBJECT_AMOP: c_int = 2;
pub const OBJECT_AMPROC: c_int = 3;
pub const OBJECT_ATTRIBUTE: c_int = 4;
pub const OBJECT_CAST: c_int = 5;
pub const OBJECT_COLUMN: c_int = 6;
pub const OBJECT_COLLATION: c_int = 7;
pub const OBJECT_CONVERSION: c_int = 8;
pub const OBJECT_DATABASE: c_int = 9;
pub const OBJECT_DEFAULT: c_int = 10;
pub const OBJECT_DEFACL: c_int = 11;
pub const OBJECT_DOMAIN: c_int = 12;
pub const OBJECT_DOMCONSTRAINT: c_int = 13;
pub const OBJECT_EVENT_TRIGGER: c_int = 14;
pub const OBJECT_EXTENSION: c_int = 15;
pub const OBJECT_FDW: c_int = 16;
pub const OBJECT_FOREIGN_SERVER: c_int = 17;
pub const OBJECT_FOREIGN_TABLE: c_int = 18;
pub const OBJECT_FUNCTION: c_int = 19;
pub const OBJECT_INDEX: c_int = 20;
pub const OBJECT_LANGUAGE: c_int = 21;
pub const OBJECT_LARGEOBJECT: c_int = 22;
pub const OBJECT_MATVIEW: c_int = 23;
pub const OBJECT_OPCLASS: c_int = 24;
pub const OBJECT_OPERATOR: c_int = 25;
pub const OBJECT_OPFAMILY: c_int = 26;
pub const OBJECT_PARAMETER_ACL: c_int = 27;
pub const OBJECT_POLICY: c_int = 28;
pub const OBJECT_PROCEDURE: c_int = 29;
pub const OBJECT_PUBLICATION: c_int = 30;
pub const OBJECT_PUBLICATION_NAMESPACE: c_int = 31;
pub const OBJECT_PUBLICATION_REL: c_int = 32;
pub const OBJECT_ROLE: c_int = 33;
pub const OBJECT_ROUTINE: c_int = 34;
pub const OBJECT_RULE: c_int = 35;
pub const OBJECT_SCHEMA: c_int = 36;
pub const OBJECT_SEQUENCE: c_int = 37;
pub const OBJECT_SUBSCRIPTION: c_int = 38;
pub const OBJECT_STATISTIC_EXT: c_int = 39;
pub const OBJECT_TABCONSTRAINT: c_int = 40;
pub const OBJECT_TABLE: c_int = 41;
pub const OBJECT_TABLESPACE: c_int = 42;
pub const OBJECT_TRANSFORM: c_int = 43;
pub const OBJECT_TRIGGER: c_int = 44;
pub const OBJECT_TSCONFIGURATION: c_int = 45;
pub const OBJECT_TSDICTIONARY: c_int = 46;
pub const OBJECT_TSPARSER: c_int = 47;
pub const OBJECT_TSTEMPLATE: c_int = 48;
pub const OBJECT_TYPE: c_int = 49;
pub const OBJECT_USER_MAPPING: c_int = 50;
pub const OBJECT_VIEW: c_int = 51;
pub const enum_ObjectType = c_uint;
pub const ObjectType = enum_ObjectType;
pub const struct_CreateSchemaStmt = extern struct {
    type: NodeTag,
    schemaname: [*c]u8,
    authrole: [*c]RoleSpec,
    schemaElts: [*c]List,
    if_not_exists: bool,
};
pub const CreateSchemaStmt = struct_CreateSchemaStmt;
pub const DROP_RESTRICT: c_int = 0;
pub const DROP_CASCADE: c_int = 1;
pub const enum_DropBehavior = c_uint;
pub const DropBehavior = enum_DropBehavior;
pub const struct_AlterTableStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    cmds: [*c]List,
    objtype: ObjectType,
    missing_ok: bool,
};
pub const AlterTableStmt = struct_AlterTableStmt;
pub const AT_AddColumn: c_int = 0;
pub const AT_AddColumnToView: c_int = 1;
pub const AT_ColumnDefault: c_int = 2;
pub const AT_CookedColumnDefault: c_int = 3;
pub const AT_DropNotNull: c_int = 4;
pub const AT_SetNotNull: c_int = 5;
pub const AT_DropExpression: c_int = 6;
pub const AT_CheckNotNull: c_int = 7;
pub const AT_SetStatistics: c_int = 8;
pub const AT_SetOptions: c_int = 9;
pub const AT_ResetOptions: c_int = 10;
pub const AT_SetStorage: c_int = 11;
pub const AT_SetCompression: c_int = 12;
pub const AT_DropColumn: c_int = 13;
pub const AT_AddIndex: c_int = 14;
pub const AT_ReAddIndex: c_int = 15;
pub const AT_AddConstraint: c_int = 16;
pub const AT_ReAddConstraint: c_int = 17;
pub const AT_ReAddDomainConstraint: c_int = 18;
pub const AT_AlterConstraint: c_int = 19;
pub const AT_ValidateConstraint: c_int = 20;
pub const AT_AddIndexConstraint: c_int = 21;
pub const AT_DropConstraint: c_int = 22;
pub const AT_ReAddComment: c_int = 23;
pub const AT_AlterColumnType: c_int = 24;
pub const AT_AlterColumnGenericOptions: c_int = 25;
pub const AT_ChangeOwner: c_int = 26;
pub const AT_ClusterOn: c_int = 27;
pub const AT_DropCluster: c_int = 28;
pub const AT_SetLogged: c_int = 29;
pub const AT_SetUnLogged: c_int = 30;
pub const AT_DropOids: c_int = 31;
pub const AT_SetAccessMethod: c_int = 32;
pub const AT_SetTableSpace: c_int = 33;
pub const AT_SetRelOptions: c_int = 34;
pub const AT_ResetRelOptions: c_int = 35;
pub const AT_ReplaceRelOptions: c_int = 36;
pub const AT_EnableTrig: c_int = 37;
pub const AT_EnableAlwaysTrig: c_int = 38;
pub const AT_EnableReplicaTrig: c_int = 39;
pub const AT_DisableTrig: c_int = 40;
pub const AT_EnableTrigAll: c_int = 41;
pub const AT_DisableTrigAll: c_int = 42;
pub const AT_EnableTrigUser: c_int = 43;
pub const AT_DisableTrigUser: c_int = 44;
pub const AT_EnableRule: c_int = 45;
pub const AT_EnableAlwaysRule: c_int = 46;
pub const AT_EnableReplicaRule: c_int = 47;
pub const AT_DisableRule: c_int = 48;
pub const AT_AddInherit: c_int = 49;
pub const AT_DropInherit: c_int = 50;
pub const AT_AddOf: c_int = 51;
pub const AT_DropOf: c_int = 52;
pub const AT_ReplicaIdentity: c_int = 53;
pub const AT_EnableRowSecurity: c_int = 54;
pub const AT_DisableRowSecurity: c_int = 55;
pub const AT_ForceRowSecurity: c_int = 56;
pub const AT_NoForceRowSecurity: c_int = 57;
pub const AT_GenericOptions: c_int = 58;
pub const AT_AttachPartition: c_int = 59;
pub const AT_DetachPartition: c_int = 60;
pub const AT_DetachPartitionFinalize: c_int = 61;
pub const AT_AddIdentity: c_int = 62;
pub const AT_SetIdentity: c_int = 63;
pub const AT_DropIdentity: c_int = 64;
pub const AT_ReAddStatistics: c_int = 65;
pub const enum_AlterTableType = c_uint;
pub const AlterTableType = enum_AlterTableType;
pub const struct_ReplicaIdentityStmt = extern struct {
    type: NodeTag,
    identity_type: u8,
    name: [*c]u8,
};
pub const ReplicaIdentityStmt = struct_ReplicaIdentityStmt;
pub const struct_AlterTableCmd = extern struct {
    type: NodeTag,
    subtype: AlterTableType,
    name: [*c]u8,
    num: int16,
    newowner: [*c]RoleSpec,
    def: [*c]Node,
    behavior: DropBehavior,
    missing_ok: bool,
    recurse: bool,
};
pub const AlterTableCmd = struct_AlterTableCmd;
pub const struct_AlterCollationStmt = extern struct {
    type: NodeTag,
    collname: [*c]List,
};
pub const AlterCollationStmt = struct_AlterCollationStmt;
pub const struct_AlterDomainStmt = extern struct {
    type: NodeTag,
    subtype: u8,
    typeName: [*c]List,
    name: [*c]u8,
    def: [*c]Node,
    behavior: DropBehavior,
    missing_ok: bool,
};
pub const AlterDomainStmt = struct_AlterDomainStmt;
pub const ACL_TARGET_OBJECT: c_int = 0;
pub const ACL_TARGET_ALL_IN_SCHEMA: c_int = 1;
pub const ACL_TARGET_DEFAULTS: c_int = 2;
pub const enum_GrantTargetType = c_uint;
pub const GrantTargetType = enum_GrantTargetType;
pub const struct_GrantStmt = extern struct {
    type: NodeTag,
    is_grant: bool,
    targtype: GrantTargetType,
    objtype: ObjectType,
    objects: [*c]List,
    privileges: [*c]List,
    grantees: [*c]List,
    grant_option: bool,
    grantor: [*c]RoleSpec,
    behavior: DropBehavior,
};
pub const GrantStmt = struct_GrantStmt;
pub const struct_ObjectWithArgs = extern struct {
    type: NodeTag,
    objname: [*c]List,
    objargs: [*c]List,
    objfuncargs: [*c]List,
    args_unspecified: bool,
};
pub const ObjectWithArgs = struct_ObjectWithArgs;
pub const struct_AccessPriv = extern struct {
    type: NodeTag,
    priv_name: [*c]u8,
    cols: [*c]List,
};
pub const AccessPriv = struct_AccessPriv;
pub const struct_GrantRoleStmt = extern struct {
    type: NodeTag,
    granted_roles: [*c]List,
    grantee_roles: [*c]List,
    is_grant: bool,
    opt: [*c]List,
    grantor: [*c]RoleSpec,
    behavior: DropBehavior,
};
pub const GrantRoleStmt = struct_GrantRoleStmt;
pub const struct_AlterDefaultPrivilegesStmt = extern struct {
    type: NodeTag,
    options: [*c]List,
    action: [*c]GrantStmt,
};
pub const AlterDefaultPrivilegesStmt = struct_AlterDefaultPrivilegesStmt;
pub const struct_CopyStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    query: [*c]Node,
    attlist: [*c]List,
    is_from: bool,
    is_program: bool,
    filename: [*c]u8,
    options: [*c]List,
    whereClause: [*c]Node,
};
pub const CopyStmt = struct_CopyStmt;
pub const VAR_SET_VALUE: c_int = 0;
pub const VAR_SET_DEFAULT: c_int = 1;
pub const VAR_SET_CURRENT: c_int = 2;
pub const VAR_SET_MULTI: c_int = 3;
pub const VAR_RESET: c_int = 4;
pub const VAR_RESET_ALL: c_int = 5;
pub const enum_VariableSetKind = c_uint;
pub const VariableSetKind = enum_VariableSetKind;
pub const struct_VariableSetStmt = extern struct {
    type: NodeTag,
    kind: VariableSetKind,
    name: [*c]u8,
    args: [*c]List,
    is_local: bool,
};
pub const VariableSetStmt = struct_VariableSetStmt;
pub const struct_VariableShowStmt = extern struct {
    type: NodeTag,
    name: [*c]u8,
};
pub const VariableShowStmt = struct_VariableShowStmt;
pub const struct_CreateStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    tableElts: [*c]List,
    inhRelations: [*c]List,
    partbound: [*c]PartitionBoundSpec,
    partspec: [*c]PartitionSpec,
    ofTypename: [*c]TypeName,
    constraints: [*c]List,
    options: [*c]List,
    oncommit: OnCommitAction,
    tablespacename: [*c]u8,
    accessMethod: [*c]u8,
    if_not_exists: bool,
};
pub const CreateStmt = struct_CreateStmt;
pub const CONSTR_NULL: c_int = 0;
pub const CONSTR_NOTNULL: c_int = 1;
pub const CONSTR_DEFAULT: c_int = 2;
pub const CONSTR_IDENTITY: c_int = 3;
pub const CONSTR_GENERATED: c_int = 4;
pub const CONSTR_CHECK: c_int = 5;
pub const CONSTR_PRIMARY: c_int = 6;
pub const CONSTR_UNIQUE: c_int = 7;
pub const CONSTR_EXCLUSION: c_int = 8;
pub const CONSTR_FOREIGN: c_int = 9;
pub const CONSTR_ATTR_DEFERRABLE: c_int = 10;
pub const CONSTR_ATTR_NOT_DEFERRABLE: c_int = 11;
pub const CONSTR_ATTR_DEFERRED: c_int = 12;
pub const CONSTR_ATTR_IMMEDIATE: c_int = 13;
pub const enum_ConstrType = c_uint;
pub const ConstrType = enum_ConstrType;
pub const struct_Constraint = extern struct {
    type: NodeTag,
    contype: ConstrType,
    conname: [*c]u8,
    deferrable: bool,
    initdeferred: bool,
    location: c_int,
    is_no_inherit: bool,
    raw_expr: [*c]Node,
    cooked_expr: [*c]u8,
    generated_when: u8,
    nulls_not_distinct: bool,
    keys: [*c]List,
    including: [*c]List,
    exclusions: [*c]List,
    options: [*c]List,
    indexname: [*c]u8,
    indexspace: [*c]u8,
    reset_default_tblspc: bool,
    access_method: [*c]u8,
    where_clause: [*c]Node,
    pktable: [*c]RangeVar,
    fk_attrs: [*c]List,
    pk_attrs: [*c]List,
    fk_matchtype: u8,
    fk_upd_action: u8,
    fk_del_action: u8,
    fk_del_set_cols: [*c]List,
    old_conpfeqop: [*c]List,
    old_pktable_oid: Oid,
    skip_validation: bool,
    initially_valid: bool,
};
pub const Constraint = struct_Constraint;
pub const struct_CreateTableSpaceStmt = extern struct {
    type: NodeTag,
    tablespacename: [*c]u8,
    owner: [*c]RoleSpec,
    location: [*c]u8,
    options: [*c]List,
};
pub const CreateTableSpaceStmt = struct_CreateTableSpaceStmt;
pub const struct_DropTableSpaceStmt = extern struct {
    type: NodeTag,
    tablespacename: [*c]u8,
    missing_ok: bool,
};
pub const DropTableSpaceStmt = struct_DropTableSpaceStmt;
pub const struct_AlterTableSpaceOptionsStmt = extern struct {
    type: NodeTag,
    tablespacename: [*c]u8,
    options: [*c]List,
    isReset: bool,
};
pub const AlterTableSpaceOptionsStmt = struct_AlterTableSpaceOptionsStmt;
pub const struct_AlterTableMoveAllStmt = extern struct {
    type: NodeTag,
    orig_tablespacename: [*c]u8,
    objtype: ObjectType,
    roles: [*c]List,
    new_tablespacename: [*c]u8,
    nowait: bool,
};
pub const AlterTableMoveAllStmt = struct_AlterTableMoveAllStmt;
pub const struct_CreateExtensionStmt = extern struct {
    type: NodeTag,
    extname: [*c]u8,
    if_not_exists: bool,
    options: [*c]List,
};
pub const CreateExtensionStmt = struct_CreateExtensionStmt;
pub const struct_AlterExtensionStmt = extern struct {
    type: NodeTag,
    extname: [*c]u8,
    options: [*c]List,
};
pub const AlterExtensionStmt = struct_AlterExtensionStmt;
pub const struct_AlterExtensionContentsStmt = extern struct {
    type: NodeTag,
    extname: [*c]u8,
    action: c_int,
    objtype: ObjectType,
    object: [*c]Node,
};
pub const AlterExtensionContentsStmt = struct_AlterExtensionContentsStmt;
pub const struct_CreateFdwStmt = extern struct {
    type: NodeTag,
    fdwname: [*c]u8,
    func_options: [*c]List,
    options: [*c]List,
};
pub const CreateFdwStmt = struct_CreateFdwStmt;
pub const struct_AlterFdwStmt = extern struct {
    type: NodeTag,
    fdwname: [*c]u8,
    func_options: [*c]List,
    options: [*c]List,
};
pub const AlterFdwStmt = struct_AlterFdwStmt;
pub const struct_CreateForeignServerStmt = extern struct {
    type: NodeTag,
    servername: [*c]u8,
    servertype: [*c]u8,
    version: [*c]u8,
    fdwname: [*c]u8,
    if_not_exists: bool,
    options: [*c]List,
};
pub const CreateForeignServerStmt = struct_CreateForeignServerStmt;
pub const struct_AlterForeignServerStmt = extern struct {
    type: NodeTag,
    servername: [*c]u8,
    version: [*c]u8,
    options: [*c]List,
    has_version: bool,
};
pub const AlterForeignServerStmt = struct_AlterForeignServerStmt;
pub const struct_CreateForeignTableStmt = extern struct {
    base: CreateStmt,
    servername: [*c]u8,
    options: [*c]List,
};
pub const CreateForeignTableStmt = struct_CreateForeignTableStmt;
pub const struct_CreateUserMappingStmt = extern struct {
    type: NodeTag,
    user: [*c]RoleSpec,
    servername: [*c]u8,
    if_not_exists: bool,
    options: [*c]List,
};
pub const CreateUserMappingStmt = struct_CreateUserMappingStmt;
pub const struct_AlterUserMappingStmt = extern struct {
    type: NodeTag,
    user: [*c]RoleSpec,
    servername: [*c]u8,
    options: [*c]List,
};
pub const AlterUserMappingStmt = struct_AlterUserMappingStmt;
pub const struct_DropUserMappingStmt = extern struct {
    type: NodeTag,
    user: [*c]RoleSpec,
    servername: [*c]u8,
    missing_ok: bool,
};
pub const DropUserMappingStmt = struct_DropUserMappingStmt;
pub const FDW_IMPORT_SCHEMA_ALL: c_int = 0;
pub const FDW_IMPORT_SCHEMA_LIMIT_TO: c_int = 1;
pub const FDW_IMPORT_SCHEMA_EXCEPT: c_int = 2;
pub const enum_ImportForeignSchemaType = c_uint;
pub const ImportForeignSchemaType = enum_ImportForeignSchemaType;
pub const struct_ImportForeignSchemaStmt = extern struct {
    type: NodeTag,
    server_name: [*c]u8,
    remote_schema: [*c]u8,
    local_schema: [*c]u8,
    list_type: ImportForeignSchemaType,
    table_list: [*c]List,
    options: [*c]List,
};
pub const ImportForeignSchemaStmt = struct_ImportForeignSchemaStmt;
pub const struct_CreatePolicyStmt = extern struct {
    type: NodeTag,
    policy_name: [*c]u8,
    table: [*c]RangeVar,
    cmd_name: [*c]u8,
    permissive: bool,
    roles: [*c]List,
    qual: [*c]Node,
    with_check: [*c]Node,
};
pub const CreatePolicyStmt = struct_CreatePolicyStmt;
pub const struct_AlterPolicyStmt = extern struct {
    type: NodeTag,
    policy_name: [*c]u8,
    table: [*c]RangeVar,
    roles: [*c]List,
    qual: [*c]Node,
    with_check: [*c]Node,
};
pub const AlterPolicyStmt = struct_AlterPolicyStmt;
pub const struct_CreateAmStmt = extern struct {
    type: NodeTag,
    amname: [*c]u8,
    handler_name: [*c]List,
    amtype: u8,
};
pub const CreateAmStmt = struct_CreateAmStmt;
pub const struct_CreateTrigStmt = extern struct {
    type: NodeTag,
    replace: bool,
    isconstraint: bool,
    trigname: [*c]u8,
    relation: [*c]RangeVar,
    funcname: [*c]List,
    args: [*c]List,
    row: bool,
    timing: int16,
    events: int16,
    columns: [*c]List,
    whenClause: [*c]Node,
    transitionRels: [*c]List,
    deferrable: bool,
    initdeferred: bool,
    constrrel: [*c]RangeVar,
};
pub const CreateTrigStmt = struct_CreateTrigStmt;
pub const struct_CreateEventTrigStmt = extern struct {
    type: NodeTag,
    trigname: [*c]u8,
    eventname: [*c]u8,
    whenclause: [*c]List,
    funcname: [*c]List,
};
pub const CreateEventTrigStmt = struct_CreateEventTrigStmt;
pub const struct_AlterEventTrigStmt = extern struct {
    type: NodeTag,
    trigname: [*c]u8,
    tgenabled: u8,
};
pub const AlterEventTrigStmt = struct_AlterEventTrigStmt;
pub const struct_CreatePLangStmt = extern struct {
    type: NodeTag,
    replace: bool,
    plname: [*c]u8,
    plhandler: [*c]List,
    plinline: [*c]List,
    plvalidator: [*c]List,
    pltrusted: bool,
};
pub const CreatePLangStmt = struct_CreatePLangStmt;
pub const ROLESTMT_ROLE: c_int = 0;
pub const ROLESTMT_USER: c_int = 1;
pub const ROLESTMT_GROUP: c_int = 2;
pub const enum_RoleStmtType = c_uint;
pub const RoleStmtType = enum_RoleStmtType;
pub const struct_CreateRoleStmt = extern struct {
    type: NodeTag,
    stmt_type: RoleStmtType,
    role: [*c]u8,
    options: [*c]List,
};
pub const CreateRoleStmt = struct_CreateRoleStmt;
pub const struct_AlterRoleStmt = extern struct {
    type: NodeTag,
    role: [*c]RoleSpec,
    options: [*c]List,
    action: c_int,
};
pub const AlterRoleStmt = struct_AlterRoleStmt;
pub const struct_AlterRoleSetStmt = extern struct {
    type: NodeTag,
    role: [*c]RoleSpec,
    database: [*c]u8,
    setstmt: [*c]VariableSetStmt,
};
pub const AlterRoleSetStmt = struct_AlterRoleSetStmt;
pub const struct_DropRoleStmt = extern struct {
    type: NodeTag,
    roles: [*c]List,
    missing_ok: bool,
};
pub const DropRoleStmt = struct_DropRoleStmt;
pub const struct_CreateSeqStmt = extern struct {
    type: NodeTag,
    sequence: [*c]RangeVar,
    options: [*c]List,
    ownerId: Oid,
    for_identity: bool,
    if_not_exists: bool,
};
pub const CreateSeqStmt = struct_CreateSeqStmt;
pub const struct_AlterSeqStmt = extern struct {
    type: NodeTag,
    sequence: [*c]RangeVar,
    options: [*c]List,
    for_identity: bool,
    missing_ok: bool,
};
pub const AlterSeqStmt = struct_AlterSeqStmt;
pub const struct_DefineStmt = extern struct {
    type: NodeTag,
    kind: ObjectType,
    oldstyle: bool,
    defnames: [*c]List,
    args: [*c]List,
    definition: [*c]List,
    if_not_exists: bool,
    replace: bool,
};
pub const DefineStmt = struct_DefineStmt;
pub const struct_CreateDomainStmt = extern struct {
    type: NodeTag,
    domainname: [*c]List,
    typeName: [*c]TypeName,
    collClause: [*c]CollateClause,
    constraints: [*c]List,
};
pub const CreateDomainStmt = struct_CreateDomainStmt;
pub const struct_CreateOpClassStmt = extern struct {
    type: NodeTag,
    opclassname: [*c]List,
    opfamilyname: [*c]List,
    amname: [*c]u8,
    datatype: [*c]TypeName,
    items: [*c]List,
    isDefault: bool,
};
pub const CreateOpClassStmt = struct_CreateOpClassStmt;
pub const struct_CreateOpClassItem = extern struct {
    type: NodeTag,
    itemtype: c_int,
    name: [*c]ObjectWithArgs,
    number: c_int,
    order_family: [*c]List,
    class_args: [*c]List,
    storedtype: [*c]TypeName,
};
pub const CreateOpClassItem = struct_CreateOpClassItem;
pub const struct_CreateOpFamilyStmt = extern struct {
    type: NodeTag,
    opfamilyname: [*c]List,
    amname: [*c]u8,
};
pub const CreateOpFamilyStmt = struct_CreateOpFamilyStmt;
pub const struct_AlterOpFamilyStmt = extern struct {
    type: NodeTag,
    opfamilyname: [*c]List,
    amname: [*c]u8,
    isDrop: bool,
    items: [*c]List,
};
pub const AlterOpFamilyStmt = struct_AlterOpFamilyStmt;
pub const struct_DropStmt = extern struct {
    type: NodeTag,
    objects: [*c]List,
    removeType: ObjectType,
    behavior: DropBehavior,
    missing_ok: bool,
    concurrent: bool,
};
pub const DropStmt = struct_DropStmt;
pub const struct_TruncateStmt = extern struct {
    type: NodeTag,
    relations: [*c]List,
    restart_seqs: bool,
    behavior: DropBehavior,
};
pub const TruncateStmt = struct_TruncateStmt;
pub const struct_CommentStmt = extern struct {
    type: NodeTag,
    objtype: ObjectType,
    object: [*c]Node,
    comment: [*c]u8,
};
pub const CommentStmt = struct_CommentStmt;
pub const struct_SecLabelStmt = extern struct {
    type: NodeTag,
    objtype: ObjectType,
    object: [*c]Node,
    provider: [*c]u8,
    label: [*c]u8,
};
pub const SecLabelStmt = struct_SecLabelStmt;
pub const struct_DeclareCursorStmt = extern struct {
    type: NodeTag,
    portalname: [*c]u8,
    options: c_int,
    query: [*c]Node,
};
pub const DeclareCursorStmt = struct_DeclareCursorStmt;
pub const struct_ClosePortalStmt = extern struct {
    type: NodeTag,
    portalname: [*c]u8,
};
pub const ClosePortalStmt = struct_ClosePortalStmt;
pub const FETCH_FORWARD: c_int = 0;
pub const FETCH_BACKWARD: c_int = 1;
pub const FETCH_ABSOLUTE: c_int = 2;
pub const FETCH_RELATIVE: c_int = 3;
pub const enum_FetchDirection = c_uint;
pub const FetchDirection = enum_FetchDirection;
pub const struct_FetchStmt = extern struct {
    type: NodeTag,
    direction: FetchDirection,
    howMany: c_long,
    portalname: [*c]u8,
    ismove: bool,
};
pub const FetchStmt = struct_FetchStmt;
pub const struct_IndexStmt = extern struct {
    type: NodeTag,
    idxname: [*c]u8,
    relation: [*c]RangeVar,
    accessMethod: [*c]u8,
    tableSpace: [*c]u8,
    indexParams: [*c]List,
    indexIncludingParams: [*c]List,
    options: [*c]List,
    whereClause: [*c]Node,
    excludeOpNames: [*c]List,
    idxcomment: [*c]u8,
    indexOid: Oid,
    oldNumber: RelFileNumber,
    oldCreateSubid: SubTransactionId,
    oldFirstRelfilelocatorSubid: SubTransactionId,
    unique: bool,
    nulls_not_distinct: bool,
    primary: bool,
    isconstraint: bool,
    deferrable: bool,
    initdeferred: bool,
    transformed: bool,
    concurrent: bool,
    if_not_exists: bool,
    reset_default_tblspc: bool,
};
pub const IndexStmt = struct_IndexStmt;
pub const struct_CreateStatsStmt = extern struct {
    type: NodeTag,
    defnames: [*c]List,
    stat_types: [*c]List,
    exprs: [*c]List,
    relations: [*c]List,
    stxcomment: [*c]u8,
    transformed: bool,
    if_not_exists: bool,
};
pub const CreateStatsStmt = struct_CreateStatsStmt;
pub const struct_StatsElem = extern struct {
    type: NodeTag,
    name: [*c]u8,
    expr: [*c]Node,
};
pub const StatsElem = struct_StatsElem;
pub const struct_AlterStatsStmt = extern struct {
    type: NodeTag,
    defnames: [*c]List,
    stxstattarget: c_int,
    missing_ok: bool,
};
pub const AlterStatsStmt = struct_AlterStatsStmt;
pub const struct_CreateFunctionStmt = extern struct {
    type: NodeTag,
    is_procedure: bool,
    replace: bool,
    funcname: [*c]List,
    parameters: [*c]List,
    returnType: [*c]TypeName,
    options: [*c]List,
    sql_body: [*c]Node,
};
pub const CreateFunctionStmt = struct_CreateFunctionStmt;
pub const FUNC_PARAM_IN: c_int = 105;
pub const FUNC_PARAM_OUT: c_int = 111;
pub const FUNC_PARAM_INOUT: c_int = 98;
pub const FUNC_PARAM_VARIADIC: c_int = 118;
pub const FUNC_PARAM_TABLE: c_int = 116;
pub const FUNC_PARAM_DEFAULT: c_int = 100;
pub const enum_FunctionParameterMode = c_uint;
pub const FunctionParameterMode = enum_FunctionParameterMode;
pub const struct_FunctionParameter = extern struct {
    type: NodeTag,
    name: [*c]u8,
    argType: [*c]TypeName,
    mode: FunctionParameterMode,
    defexpr: [*c]Node,
};
pub const FunctionParameter = struct_FunctionParameter;
pub const struct_AlterFunctionStmt = extern struct {
    type: NodeTag,
    objtype: ObjectType,
    func: [*c]ObjectWithArgs,
    actions: [*c]List,
};
pub const AlterFunctionStmt = struct_AlterFunctionStmt;
pub const struct_DoStmt = extern struct {
    type: NodeTag,
    args: [*c]List,
};
pub const DoStmt = struct_DoStmt;
pub const struct_InlineCodeBlock = extern struct {
    type: NodeTag,
    source_text: [*c]u8,
    langOid: Oid,
    langIsTrusted: bool,
    atomic: bool,
};
pub const InlineCodeBlock = struct_InlineCodeBlock;
pub const struct_CallStmt = extern struct {
    type: NodeTag,
    funccall: [*c]FuncCall,
    funcexpr: [*c]FuncExpr,
    outargs: [*c]List,
};
pub const CallStmt = struct_CallStmt;
pub const struct_CallContext = extern struct {
    type: NodeTag,
    atomic: bool,
};
pub const CallContext = struct_CallContext;
pub const struct_RenameStmt = extern struct {
    type: NodeTag,
    renameType: ObjectType,
    relationType: ObjectType,
    relation: [*c]RangeVar,
    object: [*c]Node,
    subname: [*c]u8,
    newname: [*c]u8,
    behavior: DropBehavior,
    missing_ok: bool,
};
pub const RenameStmt = struct_RenameStmt;
pub const struct_AlterObjectDependsStmt = extern struct {
    type: NodeTag,
    objectType: ObjectType,
    relation: [*c]RangeVar,
    object: [*c]Node,
    extname: [*c]String,
    remove: bool,
};
pub const AlterObjectDependsStmt = struct_AlterObjectDependsStmt;
pub const struct_AlterObjectSchemaStmt = extern struct {
    type: NodeTag,
    objectType: ObjectType,
    relation: [*c]RangeVar,
    object: [*c]Node,
    newschema: [*c]u8,
    missing_ok: bool,
};
pub const AlterObjectSchemaStmt = struct_AlterObjectSchemaStmt;
pub const struct_AlterOwnerStmt = extern struct {
    type: NodeTag,
    objectType: ObjectType,
    relation: [*c]RangeVar,
    object: [*c]Node,
    newowner: [*c]RoleSpec,
};
pub const AlterOwnerStmt = struct_AlterOwnerStmt;
pub const struct_AlterOperatorStmt = extern struct {
    type: NodeTag,
    opername: [*c]ObjectWithArgs,
    options: [*c]List,
};
pub const AlterOperatorStmt = struct_AlterOperatorStmt;
pub const struct_AlterTypeStmt = extern struct {
    type: NodeTag,
    typeName: [*c]List,
    options: [*c]List,
};
pub const AlterTypeStmt = struct_AlterTypeStmt;
pub const struct_RuleStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    rulename: [*c]u8,
    whereClause: [*c]Node,
    event: CmdType,
    instead: bool,
    actions: [*c]List,
    replace: bool,
};
pub const RuleStmt = struct_RuleStmt;
pub const struct_NotifyStmt = extern struct {
    type: NodeTag,
    conditionname: [*c]u8,
    payload: [*c]u8,
};
pub const NotifyStmt = struct_NotifyStmt;
pub const struct_ListenStmt = extern struct {
    type: NodeTag,
    conditionname: [*c]u8,
};
pub const ListenStmt = struct_ListenStmt;
pub const struct_UnlistenStmt = extern struct {
    type: NodeTag,
    conditionname: [*c]u8,
};
pub const UnlistenStmt = struct_UnlistenStmt;
pub const TRANS_STMT_BEGIN: c_int = 0;
pub const TRANS_STMT_START: c_int = 1;
pub const TRANS_STMT_COMMIT: c_int = 2;
pub const TRANS_STMT_ROLLBACK: c_int = 3;
pub const TRANS_STMT_SAVEPOINT: c_int = 4;
pub const TRANS_STMT_RELEASE: c_int = 5;
pub const TRANS_STMT_ROLLBACK_TO: c_int = 6;
pub const TRANS_STMT_PREPARE: c_int = 7;
pub const TRANS_STMT_COMMIT_PREPARED: c_int = 8;
pub const TRANS_STMT_ROLLBACK_PREPARED: c_int = 9;
pub const enum_TransactionStmtKind = c_uint;
pub const TransactionStmtKind = enum_TransactionStmtKind;
pub const struct_TransactionStmt = extern struct {
    type: NodeTag,
    kind: TransactionStmtKind,
    options: [*c]List,
    savepoint_name: [*c]u8,
    gid: [*c]u8,
    chain: bool,
};
pub const TransactionStmt = struct_TransactionStmt;
pub const struct_CompositeTypeStmt = extern struct {
    type: NodeTag,
    typevar: [*c]RangeVar,
    coldeflist: [*c]List,
};
pub const CompositeTypeStmt = struct_CompositeTypeStmt;
pub const struct_CreateEnumStmt = extern struct {
    type: NodeTag,
    typeName: [*c]List,
    vals: [*c]List,
};
pub const CreateEnumStmt = struct_CreateEnumStmt;
pub const struct_CreateRangeStmt = extern struct {
    type: NodeTag,
    typeName: [*c]List,
    params: [*c]List,
};
pub const CreateRangeStmt = struct_CreateRangeStmt;
pub const struct_AlterEnumStmt = extern struct {
    type: NodeTag,
    typeName: [*c]List,
    oldVal: [*c]u8,
    newVal: [*c]u8,
    newValNeighbor: [*c]u8,
    newValIsAfter: bool,
    skipIfNewValExists: bool,
};
pub const AlterEnumStmt = struct_AlterEnumStmt;
pub const NO_CHECK_OPTION: c_int = 0;
pub const LOCAL_CHECK_OPTION: c_int = 1;
pub const CASCADED_CHECK_OPTION: c_int = 2;
pub const enum_ViewCheckOption = c_uint;
pub const ViewCheckOption = enum_ViewCheckOption;
pub const struct_ViewStmt = extern struct {
    type: NodeTag,
    view: [*c]RangeVar,
    aliases: [*c]List,
    query: [*c]Node,
    replace: bool,
    options: [*c]List,
    withCheckOption: ViewCheckOption,
};
pub const ViewStmt = struct_ViewStmt;
pub const struct_LoadStmt = extern struct {
    type: NodeTag,
    filename: [*c]u8,
};
pub const LoadStmt = struct_LoadStmt;
pub const struct_CreatedbStmt = extern struct {
    type: NodeTag,
    dbname: [*c]u8,
    options: [*c]List,
};
pub const CreatedbStmt = struct_CreatedbStmt;
pub const struct_AlterDatabaseStmt = extern struct {
    type: NodeTag,
    dbname: [*c]u8,
    options: [*c]List,
};
pub const AlterDatabaseStmt = struct_AlterDatabaseStmt;
pub const struct_AlterDatabaseRefreshCollStmt = extern struct {
    type: NodeTag,
    dbname: [*c]u8,
};
pub const AlterDatabaseRefreshCollStmt = struct_AlterDatabaseRefreshCollStmt;
pub const struct_AlterDatabaseSetStmt = extern struct {
    type: NodeTag,
    dbname: [*c]u8,
    setstmt: [*c]VariableSetStmt,
};
pub const AlterDatabaseSetStmt = struct_AlterDatabaseSetStmt;
pub const struct_DropdbStmt = extern struct {
    type: NodeTag,
    dbname: [*c]u8,
    missing_ok: bool,
    options: [*c]List,
};
pub const DropdbStmt = struct_DropdbStmt;
pub const struct_AlterSystemStmt = extern struct {
    type: NodeTag,
    setstmt: [*c]VariableSetStmt,
};
pub const AlterSystemStmt = struct_AlterSystemStmt;
pub const struct_ClusterStmt = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    indexname: [*c]u8,
    params: [*c]List,
};
pub const ClusterStmt = struct_ClusterStmt;
pub const struct_VacuumStmt = extern struct {
    type: NodeTag,
    options: [*c]List,
    rels: [*c]List,
    is_vacuumcmd: bool,
};
pub const VacuumStmt = struct_VacuumStmt;
pub const struct_VacuumRelation = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    oid: Oid,
    va_cols: [*c]List,
};
pub const VacuumRelation = struct_VacuumRelation;
pub const struct_ExplainStmt = extern struct {
    type: NodeTag,
    query: [*c]Node,
    options: [*c]List,
};
pub const ExplainStmt = struct_ExplainStmt;
pub const struct_CreateTableAsStmt = extern struct {
    type: NodeTag,
    query: [*c]Node,
    into: [*c]IntoClause,
    objtype: ObjectType,
    is_select_into: bool,
    if_not_exists: bool,
};
pub const CreateTableAsStmt = struct_CreateTableAsStmt;
pub const struct_RefreshMatViewStmt = extern struct {
    type: NodeTag,
    concurrent: bool,
    skipData: bool,
    relation: [*c]RangeVar,
};
pub const RefreshMatViewStmt = struct_RefreshMatViewStmt;
pub const struct_CheckPointStmt = extern struct {
    type: NodeTag,
};
pub const CheckPointStmt = struct_CheckPointStmt;
pub const DISCARD_ALL: c_int = 0;
pub const DISCARD_PLANS: c_int = 1;
pub const DISCARD_SEQUENCES: c_int = 2;
pub const DISCARD_TEMP: c_int = 3;
pub const enum_DiscardMode = c_uint;
pub const DiscardMode = enum_DiscardMode;
pub const struct_DiscardStmt = extern struct {
    type: NodeTag,
    target: DiscardMode,
};
pub const DiscardStmt = struct_DiscardStmt;
pub const struct_LockStmt = extern struct {
    type: NodeTag,
    relations: [*c]List,
    mode: c_int,
    nowait: bool,
};
pub const LockStmt = struct_LockStmt;
pub const struct_ConstraintsSetStmt = extern struct {
    type: NodeTag,
    constraints: [*c]List,
    deferred: bool,
};
pub const ConstraintsSetStmt = struct_ConstraintsSetStmt;
pub const REINDEX_OBJECT_INDEX: c_int = 0;
pub const REINDEX_OBJECT_TABLE: c_int = 1;
pub const REINDEX_OBJECT_SCHEMA: c_int = 2;
pub const REINDEX_OBJECT_SYSTEM: c_int = 3;
pub const REINDEX_OBJECT_DATABASE: c_int = 4;
pub const enum_ReindexObjectType = c_uint;
pub const ReindexObjectType = enum_ReindexObjectType;
pub const struct_ReindexStmt = extern struct {
    type: NodeTag,
    kind: ReindexObjectType,
    relation: [*c]RangeVar,
    name: [*c]const u8,
    params: [*c]List,
};
pub const ReindexStmt = struct_ReindexStmt;
pub const struct_CreateConversionStmt = extern struct {
    type: NodeTag,
    conversion_name: [*c]List,
    for_encoding_name: [*c]u8,
    to_encoding_name: [*c]u8,
    func_name: [*c]List,
    def: bool,
};
pub const CreateConversionStmt = struct_CreateConversionStmt;
pub const struct_CreateCastStmt = extern struct {
    type: NodeTag,
    sourcetype: [*c]TypeName,
    targettype: [*c]TypeName,
    func: [*c]ObjectWithArgs,
    context: CoercionContext,
    inout: bool,
};
pub const CreateCastStmt = struct_CreateCastStmt;
pub const struct_CreateTransformStmt = extern struct {
    type: NodeTag,
    replace: bool,
    type_name: [*c]TypeName,
    lang: [*c]u8,
    fromsql: [*c]ObjectWithArgs,
    tosql: [*c]ObjectWithArgs,
};
pub const CreateTransformStmt = struct_CreateTransformStmt;
pub const struct_PrepareStmt = extern struct {
    type: NodeTag,
    name: [*c]u8,
    argtypes: [*c]List,
    query: [*c]Node,
};
pub const PrepareStmt = struct_PrepareStmt;
pub const struct_ExecuteStmt = extern struct {
    type: NodeTag,
    name: [*c]u8,
    params: [*c]List,
};
pub const ExecuteStmt = struct_ExecuteStmt;
pub const struct_DeallocateStmt = extern struct {
    type: NodeTag,
    name: [*c]u8,
};
pub const DeallocateStmt = struct_DeallocateStmt;
pub const struct_DropOwnedStmt = extern struct {
    type: NodeTag,
    roles: [*c]List,
    behavior: DropBehavior,
};
pub const DropOwnedStmt = struct_DropOwnedStmt;
pub const struct_ReassignOwnedStmt = extern struct {
    type: NodeTag,
    roles: [*c]List,
    newrole: [*c]RoleSpec,
};
pub const ReassignOwnedStmt = struct_ReassignOwnedStmt;
pub const struct_AlterTSDictionaryStmt = extern struct {
    type: NodeTag,
    dictname: [*c]List,
    options: [*c]List,
};
pub const AlterTSDictionaryStmt = struct_AlterTSDictionaryStmt;
pub const ALTER_TSCONFIG_ADD_MAPPING: c_int = 0;
pub const ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN: c_int = 1;
pub const ALTER_TSCONFIG_REPLACE_DICT: c_int = 2;
pub const ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN: c_int = 3;
pub const ALTER_TSCONFIG_DROP_MAPPING: c_int = 4;
pub const enum_AlterTSConfigType = c_uint;
pub const AlterTSConfigType = enum_AlterTSConfigType;
pub const struct_AlterTSConfigurationStmt = extern struct {
    type: NodeTag,
    kind: AlterTSConfigType,
    cfgname: [*c]List,
    tokentype: [*c]List,
    dicts: [*c]List,
    override: bool,
    replace: bool,
    missing_ok: bool,
};
pub const AlterTSConfigurationStmt = struct_AlterTSConfigurationStmt;
pub const struct_PublicationTable = extern struct {
    type: NodeTag,
    relation: [*c]RangeVar,
    whereClause: [*c]Node,
    columns: [*c]List,
};
pub const PublicationTable = struct_PublicationTable;
pub const PUBLICATIONOBJ_TABLE: c_int = 0;
pub const PUBLICATIONOBJ_TABLES_IN_SCHEMA: c_int = 1;
pub const PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA: c_int = 2;
pub const PUBLICATIONOBJ_CONTINUATION: c_int = 3;
pub const enum_PublicationObjSpecType = c_uint;
pub const PublicationObjSpecType = enum_PublicationObjSpecType;
pub const struct_PublicationObjSpec = extern struct {
    type: NodeTag,
    pubobjtype: PublicationObjSpecType,
    name: [*c]u8,
    pubtable: [*c]PublicationTable,
    location: c_int,
};
pub const PublicationObjSpec = struct_PublicationObjSpec;
pub const struct_CreatePublicationStmt = extern struct {
    type: NodeTag,
    pubname: [*c]u8,
    options: [*c]List,
    pubobjects: [*c]List,
    for_all_tables: bool,
};
pub const CreatePublicationStmt = struct_CreatePublicationStmt;
pub const AP_AddObjects: c_int = 0;
pub const AP_DropObjects: c_int = 1;
pub const AP_SetObjects: c_int = 2;
pub const enum_AlterPublicationAction = c_uint;
pub const AlterPublicationAction = enum_AlterPublicationAction;
pub const struct_AlterPublicationStmt = extern struct {
    type: NodeTag,
    pubname: [*c]u8,
    options: [*c]List,
    pubobjects: [*c]List,
    for_all_tables: bool,
    action: AlterPublicationAction,
};
pub const AlterPublicationStmt = struct_AlterPublicationStmt;
pub const struct_CreateSubscriptionStmt = extern struct {
    type: NodeTag,
    subname: [*c]u8,
    conninfo: [*c]u8,
    publication: [*c]List,
    options: [*c]List,
};
pub const CreateSubscriptionStmt = struct_CreateSubscriptionStmt;
pub const ALTER_SUBSCRIPTION_OPTIONS: c_int = 0;
pub const ALTER_SUBSCRIPTION_CONNECTION: c_int = 1;
pub const ALTER_SUBSCRIPTION_SET_PUBLICATION: c_int = 2;
pub const ALTER_SUBSCRIPTION_ADD_PUBLICATION: c_int = 3;
pub const ALTER_SUBSCRIPTION_DROP_PUBLICATION: c_int = 4;
pub const ALTER_SUBSCRIPTION_REFRESH: c_int = 5;
pub const ALTER_SUBSCRIPTION_ENABLED: c_int = 6;
pub const ALTER_SUBSCRIPTION_SKIP: c_int = 7;
pub const enum_AlterSubscriptionType = c_uint;
pub const AlterSubscriptionType = enum_AlterSubscriptionType;
pub const struct_AlterSubscriptionStmt = extern struct {
    type: NodeTag,
    kind: AlterSubscriptionType,
    subname: [*c]u8,
    conninfo: [*c]u8,
    publication: [*c]List,
    options: [*c]List,
};
pub const AlterSubscriptionStmt = struct_AlterSubscriptionStmt;
pub const struct_DropSubscriptionStmt = extern struct {
    type: NodeTag,
    subname: [*c]u8,
    missing_ok: bool,
    behavior: DropBehavior,
};
pub const DropSubscriptionStmt = struct_DropSubscriptionStmt;
pub const LOCKMASK = c_int;
pub const LOCKMODE = c_int;
pub const struct_xl_standby_lock = extern struct {
    xid: TransactionId,
    dbOid: Oid,
    relOid: Oid,
};
pub const xl_standby_lock = struct_xl_standby_lock;
pub const struct_FormData_pg_attribute = extern struct {
    attrelid: Oid,
    attname: NameData,
    atttypid: Oid,
    attlen: int16,
    attnum: int16,
    attcacheoff: int32,
    atttypmod: int32,
    attndims: int16,
    attbyval: bool,
    attalign: u8,
    attstorage: u8,
    attcompression: u8,
    attnotnull: bool,
    atthasdef: bool,
    atthasmissing: bool,
    attidentity: u8,
    attgenerated: u8,
    attisdropped: bool,
    attislocal: bool,
    attinhcount: int16,
    attstattarget: int16,
    attcollation: Oid,
};
pub const FormData_pg_attribute = struct_FormData_pg_attribute;
pub const Form_pg_attribute = [*c]FormData_pg_attribute;
pub extern var no_such_variable: c_int;
pub const struct_AttrDefault = extern struct {
    adnum: AttrNumber,
    adbin: [*c]u8,
};
pub const AttrDefault = struct_AttrDefault;
pub const struct_ConstrCheck = extern struct {
    ccname: [*c]u8,
    ccbin: [*c]u8,
    ccvalid: bool,
    ccnoinherit: bool,
};
pub const ConstrCheck = struct_ConstrCheck;
pub const struct_AttrMissing = opaque {};
pub const struct_TupleConstr = extern struct {
    defval: [*c]AttrDefault,
    check: [*c]ConstrCheck,
    missing: ?*struct_AttrMissing,
    num_defval: uint16,
    num_check: uint16,
    has_not_null: bool,
    has_generated_stored: bool,
};
pub const TupleConstr = struct_TupleConstr;
pub const struct_TupleDescData = extern struct {
    natts: c_int align(8),
    tdtypeid: Oid,
    tdtypmod: int32,
    tdrefcount: c_int,
    constr: [*c]TupleConstr,
    pub fn attrs(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), FormData_pg_attribute) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), FormData_pg_attribute);
        return @ptrCast(ReturnType, @alignCast(@alignOf(FormData_pg_attribute), @ptrCast(Intermediate, self) + 24));
    }
};
pub const TupleDescData = struct_TupleDescData;
pub const TupleDesc = [*c]struct_TupleDescData;
pub extern fn CreateTemplateTupleDesc(natts: c_int) TupleDesc;
pub extern fn CreateTupleDesc(natts: c_int, attrs: [*c]Form_pg_attribute) TupleDesc;
pub extern fn CreateTupleDescCopy(tupdesc: TupleDesc) TupleDesc;
pub extern fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) TupleDesc;
pub extern fn TupleDescCopy(dst: TupleDesc, src: TupleDesc) void;
pub extern fn TupleDescCopyEntry(dst: TupleDesc, dstAttno: AttrNumber, src: TupleDesc, srcAttno: AttrNumber) void;
pub extern fn FreeTupleDesc(tupdesc: TupleDesc) void;
pub extern fn IncrTupleDescRefCount(tupdesc: TupleDesc) void;
pub extern fn DecrTupleDescRefCount(tupdesc: TupleDesc) void;
pub extern fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) bool;
pub extern fn hashTupleDesc(desc: TupleDesc) uint32;
pub extern fn TupleDescInitEntry(desc: TupleDesc, attributeNumber: AttrNumber, attributeName: [*c]const u8, oidtypeid: Oid, typmod: int32, attdim: c_int) void;
pub extern fn TupleDescInitBuiltinEntry(desc: TupleDesc, attributeNumber: AttrNumber, attributeName: [*c]const u8, oidtypeid: Oid, typmod: int32, attdim: c_int) void;
pub extern fn TupleDescInitEntryCollation(desc: TupleDesc, attributeNumber: AttrNumber, collationid: Oid) void;
pub extern fn BuildDescForRelation(schema: [*c]List) TupleDesc;
pub extern fn BuildDescFromLists(names: [*c]List, types: [*c]List, typmods: [*c]List, collations: [*c]List) TupleDesc;
pub const struct_RelFileLocator = extern struct {
    spcOid: Oid,
    dbOid: Oid,
    relNumber: RelFileNumber,
};
pub const RelFileLocator = struct_RelFileLocator;
pub const BackendId = c_int;
pub const struct_RelFileLocatorBackend = extern struct {
    locator: RelFileLocator,
    backend: BackendId,
};
pub const RelFileLocatorBackend = struct_RelFileLocatorBackend;
pub const struct__MdfdVec = opaque {};
pub const struct_dlist_node = extern struct {
    prev: [*c]dlist_node,
    next: [*c]dlist_node,
};
pub const dlist_node = struct_dlist_node;
pub const struct_SMgrRelationData = extern struct {
    smgr_rlocator: RelFileLocatorBackend,
    smgr_owner: [*c][*c]struct_SMgrRelationData,
    smgr_targblock: BlockNumber,
    smgr_cached_nblocks: [4]BlockNumber,
    smgr_which: c_int,
    md_num_open_segs: [4]c_int,
    md_seg_fds: [4]?*struct__MdfdVec,
    node: dlist_node,
};
pub const SMgrRelationData = struct_SMgrRelationData;
pub const SMgrRelation = [*c]SMgrRelationData;
pub const struct_FormData_pg_class = extern struct {
    oid: Oid,
    relname: NameData,
    relnamespace: Oid,
    reltype: Oid,
    reloftype: Oid,
    relowner: Oid,
    relam: Oid,
    relfilenode: Oid,
    reltablespace: Oid,
    relpages: int32,
    reltuples: float4,
    relallvisible: int32,
    reltoastrelid: Oid,
    relhasindex: bool,
    relisshared: bool,
    relpersistence: u8,
    relkind: u8,
    relnatts: int16,
    relchecks: int16,
    relhasrules: bool,
    relhastriggers: bool,
    relhassubclass: bool,
    relrowsecurity: bool,
    relforcerowsecurity: bool,
    relispopulated: bool,
    relreplident: u8,
    relispartition: bool,
    relrewrite: Oid,
    relfrozenxid: TransactionId,
    relminmxid: TransactionId,
};
pub const FormData_pg_class = struct_FormData_pg_class;
pub const Form_pg_class = [*c]FormData_pg_class;
pub const struct_LockRelId = extern struct {
    relId: Oid,
    dbId: Oid,
};
pub const LockRelId = struct_LockRelId;
pub const struct_LockInfoData = extern struct {
    lockRelId: LockRelId,
};
pub const LockInfoData = struct_LockInfoData;
pub const struct_RewriteRule = extern struct {
    ruleId: Oid,
    event: CmdType,
    qual: [*c]Node,
    actions: [*c]List,
    enabled: u8,
    isInstead: bool,
};
pub const RewriteRule = struct_RewriteRule;
pub const struct_RuleLock = extern struct {
    numLocks: c_int,
    rules: [*c][*c]RewriteRule,
};
pub const RuleLock = struct_RuleLock;
pub const struct_Trigger = extern struct {
    tgoid: Oid,
    tgname: [*c]u8,
    tgfoid: Oid,
    tgtype: int16,
    tgenabled: u8,
    tgisinternal: bool,
    tgisclone: bool,
    tgconstrrelid: Oid,
    tgconstrindid: Oid,
    tgconstraint: Oid,
    tgdeferrable: bool,
    tginitdeferred: bool,
    tgnargs: int16,
    tgnattr: int16,
    tgattr: [*c]int16,
    tgargs: [*c][*c]u8,
    tgqual: [*c]u8,
    tgoldtable: [*c]u8,
    tgnewtable: [*c]u8,
};
pub const Trigger = struct_Trigger;
pub const struct_TriggerDesc = extern struct {
    triggers: [*c]Trigger,
    numtriggers: c_int,
    trig_insert_before_row: bool,
    trig_insert_after_row: bool,
    trig_insert_instead_row: bool,
    trig_insert_before_statement: bool,
    trig_insert_after_statement: bool,
    trig_update_before_row: bool,
    trig_update_after_row: bool,
    trig_update_instead_row: bool,
    trig_update_before_statement: bool,
    trig_update_after_statement: bool,
    trig_delete_before_row: bool,
    trig_delete_after_row: bool,
    trig_delete_instead_row: bool,
    trig_delete_before_statement: bool,
    trig_delete_after_statement: bool,
    trig_truncate_before_statement: bool,
    trig_truncate_after_statement: bool,
    trig_insert_new_table: bool,
    trig_update_old_table: bool,
    trig_update_new_table: bool,
    trig_delete_old_table: bool,
};
pub const TriggerDesc = struct_TriggerDesc;
pub const struct_RowSecurityDesc = opaque {};
pub const struct_PublicationActions = extern struct {
    pubinsert: bool,
    pubupdate: bool,
    pubdelete: bool,
    pubtruncate: bool,
};
pub const PublicationActions = struct_PublicationActions;
pub const struct_PublicationDesc = extern struct {
    pubactions: PublicationActions,
    rf_valid_for_update: bool,
    rf_valid_for_delete: bool,
    cols_valid_for_update: bool,
    cols_valid_for_delete: bool,
};
pub const PublicationDesc = struct_PublicationDesc;
pub const struct_TableAmRoutine = opaque {};
pub const struct_FormData_pg_index = extern struct {
    indexrelid: Oid,
    indrelid: Oid,
    indnatts: int16,
    indnkeyatts: int16,
    indisunique: bool,
    indnullsnotdistinct: bool,
    indisprimary: bool,
    indisexclusion: bool,
    indimmediate: bool,
    indisclustered: bool,
    indisvalid: bool,
    indcheckxmin: bool,
    indisready: bool,
    indislive: bool,
    indisreplident: bool,
    indkey: int2vector,
};
pub const FormData_pg_index = struct_FormData_pg_index;
pub const Form_pg_index = [*c]FormData_pg_index;
pub const struct_IndexAmRoutine = opaque {};
pub const FmgrInfo = struct_FmgrInfo;
pub const fmNodePtr = [*c]struct_Node;
pub const struct_FunctionCallInfoBaseData = extern struct {
    flinfo: [*c]FmgrInfo align(8),
    context: fmNodePtr,
    resultinfo: fmNodePtr,
    fncollation: Oid,
    isnull: bool,
    nargs: c_short,
    pub fn args(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), NullableDatum) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), NullableDatum);
        return @ptrCast(ReturnType, @alignCast(@alignOf(NullableDatum), @ptrCast(Intermediate, self) + 32));
    }
};
pub const FunctionCallInfo = [*c]struct_FunctionCallInfoBaseData;
pub const PGFunction = ?*const fn (FunctionCallInfo) callconv(.C) Datum;
pub const struct_FmgrInfo = extern struct {
    fn_addr: PGFunction,
    fn_oid: Oid,
    fn_nargs: c_short,
    fn_strict: bool,
    fn_retset: bool,
    fn_stats: u8,
    fn_extra: ?*anyopaque,
    fn_mcxt: MemoryContext,
    fn_expr: fmNodePtr,
};
pub const struct_FdwRoutine = opaque {};
pub const struct_PgStat_TableStatus = opaque {};
pub const struct_RelationData = extern struct {
    rd_locator: RelFileLocator,
    rd_smgr: SMgrRelation,
    rd_refcnt: c_int,
    rd_backend: BackendId,
    rd_islocaltemp: bool,
    rd_isnailed: bool,
    rd_isvalid: bool,
    rd_indexvalid: bool,
    rd_statvalid: bool,
    rd_createSubid: SubTransactionId,
    rd_newRelfilelocatorSubid: SubTransactionId,
    rd_firstRelfilelocatorSubid: SubTransactionId,
    rd_droppedSubid: SubTransactionId,
    rd_rel: Form_pg_class,
    rd_att: TupleDesc,
    rd_id: Oid,
    rd_lockInfo: LockInfoData,
    rd_rules: [*c]RuleLock,
    rd_rulescxt: MemoryContext,
    trigdesc: [*c]TriggerDesc,
    rd_rsdesc: ?*struct_RowSecurityDesc,
    rd_fkeylist: [*c]List,
    rd_fkeyvalid: bool,
    rd_partkey: PartitionKey,
    rd_partkeycxt: MemoryContext,
    rd_partdesc: PartitionDesc,
    rd_pdcxt: MemoryContext,
    rd_partdesc_nodetached: PartitionDesc,
    rd_pddcxt: MemoryContext,
    rd_partdesc_nodetached_xmin: TransactionId,
    rd_partcheck: [*c]List,
    rd_partcheckvalid: bool,
    rd_partcheckcxt: MemoryContext,
    rd_indexlist: [*c]List,
    rd_pkindex: Oid,
    rd_replidindex: Oid,
    rd_statlist: [*c]List,
    rd_attrsvalid: bool,
    rd_keyattr: [*c]Bitmapset,
    rd_pkattr: [*c]Bitmapset,
    rd_idattr: [*c]Bitmapset,
    rd_hotblockingattr: [*c]Bitmapset,
    rd_summarizedattr: [*c]Bitmapset,
    rd_pubdesc: [*c]PublicationDesc,
    rd_options: [*c]bytea,
    rd_amhandler: Oid,
    rd_tableam: ?*const struct_TableAmRoutine,
    rd_index: Form_pg_index,
    rd_indextuple: [*c]struct_HeapTupleData,
    rd_indexcxt: MemoryContext,
    rd_indam: ?*struct_IndexAmRoutine,
    rd_opfamily: [*c]Oid,
    rd_opcintype: [*c]Oid,
    rd_support: [*c]RegProcedure,
    rd_supportinfo: [*c]struct_FmgrInfo,
    rd_indoption: [*c]int16,
    rd_indexprs: [*c]List,
    rd_indpred: [*c]List,
    rd_exclops: [*c]Oid,
    rd_exclprocs: [*c]Oid,
    rd_exclstrats: [*c]uint16,
    rd_indcollation: [*c]Oid,
    rd_opcoptions: [*c][*c]bytea,
    rd_amcache: ?*anyopaque,
    rd_fdwroutine: ?*struct_FdwRoutine,
    rd_toastoid: Oid,
    pgstat_enabled: bool,
    pgstat_info: ?*struct_PgStat_TableStatus,
};
pub const Relation = [*c]struct_RelationData;
pub const RelationPtr = [*c]Relation;
pub extern fn RelationIdGetRelation(relationId: Oid) Relation;
pub extern fn RelationClose(relation: Relation) void;
pub extern fn RelationGetFKeyList(relation: Relation) [*c]List;
pub extern fn RelationGetIndexList(relation: Relation) [*c]List;
pub extern fn RelationGetStatExtList(relation: Relation) [*c]List;
pub extern fn RelationGetPrimaryKeyIndex(relation: Relation) Oid;
pub extern fn RelationGetReplicaIndex(relation: Relation) Oid;
pub extern fn RelationGetIndexExpressions(relation: Relation) [*c]List;
pub extern fn RelationGetDummyIndexExpressions(relation: Relation) [*c]List;
pub extern fn RelationGetIndexPredicate(relation: Relation) [*c]List;
pub extern fn RelationGetIndexRawAttOptions(indexrel: Relation) [*c]Datum;
pub extern fn RelationGetIndexAttOptions(relation: Relation, copy: bool) [*c][*c]bytea;
pub const INDEX_ATTR_BITMAP_KEY: c_int = 0;
pub const INDEX_ATTR_BITMAP_PRIMARY_KEY: c_int = 1;
pub const INDEX_ATTR_BITMAP_IDENTITY_KEY: c_int = 2;
pub const INDEX_ATTR_BITMAP_HOT_BLOCKING: c_int = 3;
pub const INDEX_ATTR_BITMAP_SUMMARIZED: c_int = 4;
pub const enum_IndexAttrBitmapKind = c_uint;
pub const IndexAttrBitmapKind = enum_IndexAttrBitmapKind;
pub extern fn RelationGetIndexAttrBitmap(relation: Relation, attrKind: IndexAttrBitmapKind) [*c]Bitmapset;
pub extern fn RelationGetIdentityKeyBitmap(relation: Relation) [*c]Bitmapset;
pub extern fn RelationGetExclusionInfo(indexRelation: Relation, operators: [*c][*c]Oid, procs: [*c][*c]Oid, strategies: [*c][*c]uint16) void;
pub extern fn RelationInitIndexAccessInfo(relation: Relation) void;
pub extern fn RelationBuildPublicationDesc(relation: Relation, pubdesc: [*c]struct_PublicationDesc) void;
pub extern fn RelationInitTableAccessMethod(relation: Relation) void;
pub extern fn errtable(rel: Relation) c_int;
pub extern fn errtablecol(rel: Relation, attnum: c_int) c_int;
pub extern fn errtablecolname(rel: Relation, colname: [*c]const u8) c_int;
pub extern fn errtableconstraint(rel: Relation, conname: [*c]const u8) c_int;
pub extern fn RelationCacheInitialize() void;
pub extern fn RelationCacheInitializePhase2() void;
pub extern fn RelationCacheInitializePhase3() void;
pub extern fn RelationBuildLocalRelation(relname: [*c]const u8, relnamespace: Oid, tupDesc: TupleDesc, relid: Oid, accessmtd: Oid, relfilenumber: RelFileNumber, reltablespace: Oid, shared_relation: bool, mapped_relation: bool, relpersistence: u8, relkind: u8) Relation;
pub extern fn RelationSetNewRelfilenumber(relation: Relation, persistence: u8) void;
pub extern fn RelationAssumeNewRelfilelocator(relation: Relation) void;
pub extern fn RelationForgetRelation(rid: Oid) void;
pub extern fn RelationCacheInvalidateEntry(relationId: Oid) void;
pub extern fn RelationCacheInvalidate(debug_discard: bool) void;
pub extern fn RelationCloseSmgrByOid(relationId: Oid) void;
pub extern fn AtEOXact_RelationCache(isCommit: bool) void;
pub extern fn AtEOSubXact_RelationCache(isCommit: bool, mySubid: SubTransactionId, parentSubid: SubTransactionId) void;
pub extern fn RelationIdIsInInitFile(relationId: Oid) bool;
pub extern fn RelationCacheInitFilePreInvalidate() void;
pub extern fn RelationCacheInitFilePostInvalidate() void;
pub extern fn RelationCacheInitFileRemove() void;
pub extern var criticalRelcachesBuilt: bool;
pub extern var criticalSharedRelcachesBuilt: bool;
pub const struct_ObjectAddress = extern struct {
    classId: Oid,
    objectId: Oid,
    objectSubId: int32,
};
pub const ObjectAddress = struct_ObjectAddress;
pub extern const InvalidObjectAddress: ObjectAddress;
pub extern fn get_object_address(objtype: ObjectType, object: [*c]Node, relp: [*c]Relation, lockmode: LOCKMODE, missing_ok: bool) ObjectAddress;
pub extern fn get_object_address_rv(objtype: ObjectType, rel: [*c]RangeVar, object: [*c]List, relp: [*c]Relation, lockmode: LOCKMODE, missing_ok: bool) ObjectAddress;
pub extern fn check_object_ownership(roleid: Oid, objtype: ObjectType, address: ObjectAddress, object: [*c]Node, relation: Relation) void;
pub extern fn get_object_namespace(address: [*c]const ObjectAddress) Oid;
pub extern fn is_objectclass_supported(class_id: Oid) bool;
pub extern fn get_object_class_descr(class_id: Oid) [*c]const u8;
pub extern fn get_object_oid_index(class_id: Oid) Oid;
pub extern fn get_object_catcache_oid(class_id: Oid) c_int;
pub extern fn get_object_catcache_name(class_id: Oid) c_int;
pub extern fn get_object_attnum_oid(class_id: Oid) AttrNumber;
pub extern fn get_object_attnum_name(class_id: Oid) AttrNumber;
pub extern fn get_object_attnum_namespace(class_id: Oid) AttrNumber;
pub extern fn get_object_attnum_owner(class_id: Oid) AttrNumber;
pub extern fn get_object_attnum_acl(class_id: Oid) AttrNumber;
pub extern fn get_object_type(class_id: Oid, object_id: Oid) ObjectType;
pub extern fn get_object_namensp_unique(class_id: Oid) bool;
pub extern fn get_catalog_object_by_oid(catalog: Relation, oidcol: AttrNumber, objectId: Oid) HeapTuple;
pub extern fn getObjectDescription(object: [*c]const ObjectAddress, missing_ok: bool) [*c]u8;
pub extern fn getObjectDescriptionOids(classid: Oid, objid: Oid) [*c]u8;
pub extern fn read_objtype_from_string(objtype: [*c]const u8) c_int;
pub extern fn getObjectTypeDescription(object: [*c]const ObjectAddress, missing_ok: bool) [*c]u8;
pub extern fn getObjectIdentity(object: [*c]const ObjectAddress, missing_ok: bool) [*c]u8;
pub extern fn getObjectIdentityParts(object: [*c]const ObjectAddress, objname: [*c][*c]List, objargs: [*c][*c]List, missing_ok: bool) [*c]u8;
pub const struct_ArrayType = opaque {};
pub extern fn strlist_to_textarray(list: [*c]List) ?*struct_ArrayType;
pub extern fn get_relkind_objtype(relkind: u8) ObjectType;
pub const struct_FormData_pg_type = extern struct {
    oid: Oid,
    typname: NameData,
    typnamespace: Oid,
    typowner: Oid,
    typlen: int16,
    typbyval: bool,
    typtype: u8,
    typcategory: u8,
    typispreferred: bool,
    typisdefined: bool,
    typdelim: u8,
    typrelid: Oid,
    typsubscript: regproc,
    typelem: Oid,
    typarray: Oid,
    typinput: regproc,
    typoutput: regproc,
    typreceive: regproc,
    typsend: regproc,
    typmodin: regproc,
    typmodout: regproc,
    typanalyze: regproc,
    typalign: u8,
    typstorage: u8,
    typnotnull: bool,
    typbasetype: Oid,
    typtypmod: int32,
    typndims: int32,
    typcollation: Oid,
};
pub const FormData_pg_type = struct_FormData_pg_type;
pub const Form_pg_type = [*c]FormData_pg_type;
pub extern fn TypeShellMake(typeName: [*c]const u8, typeNamespace: Oid, ownerId: Oid) ObjectAddress;
pub extern fn TypeCreate(newTypeOid: Oid, typeName: [*c]const u8, typeNamespace: Oid, relationOid: Oid, relationKind: u8, ownerId: Oid, internalSize: int16, typeType: u8, typeCategory: u8, typePreferred: bool, typDelim: u8, inputProcedure: Oid, outputProcedure: Oid, receiveProcedure: Oid, sendProcedure: Oid, typmodinProcedure: Oid, typmodoutProcedure: Oid, analyzeProcedure: Oid, subscriptProcedure: Oid, elementType: Oid, isImplicitArray: bool, arrayType: Oid, baseType: Oid, defaultTypeValue: [*c]const u8, defaultTypeBin: [*c]u8, passedByValue: bool, alignment: u8, storage: u8, typeMod: int32, typNDims: int32, typeNotNull: bool, typeCollation: Oid) ObjectAddress;
pub extern fn GenerateTypeDependencies(typeTuple: HeapTuple, typeCatalog: Relation, defaultExpr: [*c]Node, typacl: ?*anyopaque, relationKind: u8, isImplicitArray: bool, isDependentType: bool, makeExtensionDep: bool, rebuild: bool) void;
pub extern fn RenameTypeInternal(typeOid: Oid, newTypeName: [*c]const u8, typeNamespace: Oid) void;
pub extern fn makeArrayTypeName(typeName: [*c]const u8, typeNamespace: Oid) [*c]u8;
pub extern fn moveArrayTypeName(typeOid: Oid, typeName: [*c]const u8, typeNamespace: Oid) bool;
pub extern fn makeMultirangeTypeName(rangeTypeName: [*c]const u8, typeNamespace: Oid) [*c]u8;
pub const struct_flock = extern struct {
    l_type: c_short,
    l_whence: c_short,
    l_start: __off_t,
    l_len: __off_t,
    l_pid: __pid_t,
};
pub const struct_stat = extern struct {
    st_dev: __dev_t,
    st_ino: __ino_t,
    st_nlink: __nlink_t,
    st_mode: __mode_t,
    st_uid: __uid_t,
    st_gid: __gid_t,
    __pad0: c_int,
    st_rdev: __dev_t,
    st_size: __off_t,
    st_blksize: __blksize_t,
    st_blocks: __blkcnt_t,
    st_atim: struct_timespec,
    st_mtim: struct_timespec,
    st_ctim: struct_timespec,
    __glibc_reserved: [3]__syscall_slong_t,
};
pub extern fn fcntl(__fd: c_int, __cmd: c_int, ...) c_int;
pub extern fn open(__file: [*c]const u8, __oflag: c_int, ...) c_int;
pub extern fn openat(__fd: c_int, __file: [*c]const u8, __oflag: c_int, ...) c_int;
pub extern fn creat(__file: [*c]const u8, __mode: mode_t) c_int;
pub extern fn lockf(__fd: c_int, __cmd: c_int, __len: off_t) c_int;
pub extern fn posix_fadvise(__fd: c_int, __offset: off_t, __len: off_t, __advise: c_int) c_int;
pub extern fn posix_fallocate(__fd: c_int, __offset: off_t, __len: off_t) c_int;
pub const XLogRecPtr = uint64;
pub const XLogSegNo = uint64;
pub const TimeLineID = uint32;
pub const RepOriginId = uint16;
pub const pg_time_t = int64;
pub const struct_pg_tm = extern struct {
    tm_sec: c_int,
    tm_min: c_int,
    tm_hour: c_int,
    tm_mday: c_int,
    tm_mon: c_int,
    tm_year: c_int,
    tm_wday: c_int,
    tm_yday: c_int,
    tm_isdst: c_int,
    tm_gmtoff: c_long,
    tm_zone: [*c]const u8,
};
pub const struct_pg_tz = opaque {};
pub const pg_tz = struct_pg_tz;
pub const struct_pg_tzenum = opaque {};
pub const pg_tzenum = struct_pg_tzenum;
pub extern fn pg_localtime(timep: [*c]const pg_time_t, tz: ?*const pg_tz) [*c]struct_pg_tm;
pub extern fn pg_gmtime(timep: [*c]const pg_time_t) [*c]struct_pg_tm;
pub extern fn pg_next_dst_boundary(timep: [*c]const pg_time_t, before_gmtoff: [*c]c_long, before_isdst: [*c]c_int, boundary: [*c]pg_time_t, after_gmtoff: [*c]c_long, after_isdst: [*c]c_int, tz: ?*const pg_tz) c_int;
pub extern fn pg_interpret_timezone_abbrev(abbrev: [*c]const u8, timep: [*c]const pg_time_t, gmtoff: [*c]c_long, isdst: [*c]c_int, tz: ?*const pg_tz) bool;
pub extern fn pg_get_timezone_offset(tz: ?*const pg_tz, gmtoff: [*c]c_long) bool;
pub extern fn pg_get_timezone_name(tz: ?*pg_tz) [*c]const u8;
pub extern fn pg_tz_acceptable(tz: ?*pg_tz) bool;
pub extern fn pg_strftime(s: [*c]u8, maxsize: usize, format: [*c]const u8, t: [*c]const struct_pg_tm) usize;
pub extern var session_timezone: ?*pg_tz;
pub extern var log_timezone: ?*pg_tz;
pub extern fn pg_timezone_initialize() void;
pub extern fn pg_tzset(tzname: [*c]const u8) ?*pg_tz;
pub extern fn pg_tzset_offset(gmtoffset: c_long) ?*pg_tz;
pub extern fn pg_tzenumerate_start() ?*pg_tzenum;
pub extern fn pg_tzenumerate_next(dir: ?*pg_tzenum) ?*pg_tz;
pub extern fn pg_tzenumerate_end(dir: ?*pg_tzenum) void;
pub const struct_BackupState = extern struct {
    name: [1025]u8,
    startpoint: XLogRecPtr,
    starttli: TimeLineID,
    checkpointloc: XLogRecPtr,
    starttime: pg_time_t,
    started_in_recovery: bool,
    stoppoint: XLogRecPtr,
    stoptli: TimeLineID,
    stoptime: pg_time_t,
};
pub const BackupState = struct_BackupState;
pub extern fn build_backup_content(state: [*c]BackupState, ishistoryfile: bool) [*c]u8;
pub const Timestamp = int64;
pub const TimestampTz = int64;
pub const TimeOffset = int64;
pub const fsec_t = int32;
pub const Interval = extern struct {
    time: TimeOffset,
    day: int32,
    month: int32,
};
pub const struct_pg_itm = extern struct {
    tm_usec: c_int,
    tm_sec: c_int,
    tm_min: c_int,
    tm_hour: int64,
    tm_mday: c_int,
    tm_mon: c_int,
    tm_year: c_int,
};
pub const struct_pg_itm_in = extern struct {
    tm_usec: int64,
    tm_mday: c_int,
    tm_mon: c_int,
    tm_year: c_int,
};
pub extern var sync_method: c_int;
pub extern var ProcLastRecPtr: XLogRecPtr;
pub extern var XactLastRecEnd: XLogRecPtr;
pub extern var XactLastCommitEnd: XLogRecPtr;
pub extern var wal_segment_size: c_int;
pub extern var min_wal_size_mb: c_int;
pub extern var max_wal_size_mb: c_int;
pub extern var wal_keep_size_mb: c_int;
pub extern var max_slot_wal_keep_size_mb: c_int;
pub extern var XLOGbuffers: c_int;
pub extern var XLogArchiveTimeout: c_int;
pub extern var wal_retrieve_retry_interval: c_int;
pub extern var XLogArchiveCommand: [*c]u8;
pub extern var EnableHotStandby: bool;
pub extern var fullPageWrites: bool;
pub extern var wal_log_hints: bool;
pub extern var wal_compression: c_int;
pub extern var wal_init_zero: bool;
pub extern var wal_recycle: bool;
pub extern var wal_consistency_checking: [*c]bool;
pub extern var wal_consistency_checking_string: [*c]u8;
pub extern var log_checkpoints: bool;
pub extern var track_wal_io_timing: bool;
pub extern var wal_decode_buffer_size: c_int;
pub extern var CheckPointSegments: c_int;
pub const ARCHIVE_MODE_OFF: c_int = 0;
pub const ARCHIVE_MODE_ON: c_int = 1;
pub const ARCHIVE_MODE_ALWAYS: c_int = 2;
pub const enum_ArchiveMode = c_uint;
pub const ArchiveMode = enum_ArchiveMode;
pub extern var XLogArchiveMode: c_int;
pub const WAL_LEVEL_MINIMAL: c_int = 0;
pub const WAL_LEVEL_REPLICA: c_int = 1;
pub const WAL_LEVEL_LOGICAL: c_int = 2;
pub const enum_WalLevel = c_uint;
pub const WalLevel = enum_WalLevel;
pub const WAL_COMPRESSION_NONE: c_int = 0;
pub const WAL_COMPRESSION_PGLZ: c_int = 1;
pub const WAL_COMPRESSION_LZ4: c_int = 2;
pub const WAL_COMPRESSION_ZSTD: c_int = 3;
pub const enum_WalCompression = c_uint;
pub const WalCompression = enum_WalCompression;
pub const RECOVERY_STATE_CRASH: c_int = 0;
pub const RECOVERY_STATE_ARCHIVE: c_int = 1;
pub const RECOVERY_STATE_DONE: c_int = 2;
pub const enum_RecoveryState = c_uint;
pub const RecoveryState = enum_RecoveryState;
pub extern var wal_level: c_int;
pub const struct_CheckpointStatsData = extern struct {
    ckpt_start_t: TimestampTz,
    ckpt_write_t: TimestampTz,
    ckpt_sync_t: TimestampTz,
    ckpt_sync_end_t: TimestampTz,
    ckpt_end_t: TimestampTz,
    ckpt_bufs_written: c_int,
    ckpt_segs_added: c_int,
    ckpt_segs_removed: c_int,
    ckpt_segs_recycled: c_int,
    ckpt_sync_rels: c_int,
    ckpt_longest_sync: uint64,
    ckpt_agg_sync_time: uint64,
};
pub const CheckpointStatsData = struct_CheckpointStatsData;
pub extern var CheckpointStats: CheckpointStatsData;
pub const WALAVAIL_INVALID_LSN: c_int = 0;
pub const WALAVAIL_RESERVED: c_int = 1;
pub const WALAVAIL_EXTENDED: c_int = 2;
pub const WALAVAIL_UNRESERVED: c_int = 3;
pub const WALAVAIL_REMOVED: c_int = 4;
pub const enum_WALAvailability = c_uint;
pub const WALAvailability = enum_WALAvailability;
pub const struct_XLogRecData = opaque {};
pub const XLogReaderState = struct_XLogReaderState;
pub const XLogPageReadCB = ?*const fn ([*c]XLogReaderState, XLogRecPtr, c_int, XLogRecPtr, [*c]u8) callconv(.C) c_int;
pub const WALSegmentOpenCB = ?*const fn ([*c]XLogReaderState, XLogSegNo, [*c]TimeLineID) callconv(.C) void;
pub const WALSegmentCloseCB = ?*const fn ([*c]XLogReaderState) callconv(.C) void;
pub const struct_XLogReaderRoutine = extern struct {
    page_read: XLogPageReadCB,
    segment_open: WALSegmentOpenCB,
    segment_close: WALSegmentCloseCB,
};
pub const XLogReaderRoutine = struct_XLogReaderRoutine;
pub const RmgrId = uint8;
pub const pg_crc32c = uint32;
pub const struct_XLogRecord = extern struct {
    xl_tot_len: uint32,
    xl_xid: TransactionId,
    xl_prev: XLogRecPtr,
    xl_info: uint8,
    xl_rmid: RmgrId,
    xl_crc: pg_crc32c,
};
pub const XLogRecord = struct_XLogRecord;
pub const struct_DecodedXLogRecord = extern struct {
    size: usize align(8),
    oversized: bool,
    next: [*c]struct_DecodedXLogRecord,
    lsn: XLogRecPtr,
    next_lsn: XLogRecPtr,
    header: XLogRecord,
    record_origin: RepOriginId,
    toplevel_xid: TransactionId,
    main_data: [*c]u8,
    main_data_len: uint32,
    max_block_id: c_int,
    pub fn blocks(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), DecodedBkpBlock) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), DecodedBkpBlock);
        return @ptrCast(ReturnType, @alignCast(@alignOf(DecodedBkpBlock), @ptrCast(Intermediate, self) + 88));
    }
};
pub const DecodedXLogRecord = struct_DecodedXLogRecord;
pub const struct_WALSegmentContext = extern struct {
    ws_dir: [1024]u8,
    ws_segsize: c_int,
};
pub const WALSegmentContext = struct_WALSegmentContext;
pub const struct_WALOpenSegment = extern struct {
    ws_file: c_int,
    ws_segno: XLogSegNo,
    ws_tli: TimeLineID,
};
pub const WALOpenSegment = struct_WALOpenSegment;
pub const struct_XLogReaderState = extern struct {
    routine: XLogReaderRoutine,
    system_identifier: uint64,
    private_data: ?*anyopaque,
    ReadRecPtr: XLogRecPtr,
    EndRecPtr: XLogRecPtr,
    abortedRecPtr: XLogRecPtr,
    missingContrecPtr: XLogRecPtr,
    overwrittenRecPtr: XLogRecPtr,
    DecodeRecPtr: XLogRecPtr,
    NextRecPtr: XLogRecPtr,
    PrevRecPtr: XLogRecPtr,
    record: [*c]DecodedXLogRecord,
    decode_buffer: [*c]u8,
    decode_buffer_size: usize,
    free_decode_buffer: bool,
    decode_buffer_head: [*c]u8,
    decode_buffer_tail: [*c]u8,
    decode_queue_head: [*c]DecodedXLogRecord,
    decode_queue_tail: [*c]DecodedXLogRecord,
    readBuf: [*c]u8,
    readLen: uint32,
    segcxt: WALSegmentContext,
    seg: WALOpenSegment,
    segoff: uint32,
    latestPagePtr: XLogRecPtr,
    latestPageTLI: TimeLineID,
    currRecPtr: XLogRecPtr,
    currTLI: TimeLineID,
    currTLIValidUntil: XLogRecPtr,
    nextTLI: TimeLineID,
    readRecordBuf: [*c]u8,
    readRecordBufSize: uint32,
    errormsg_buf: [*c]u8,
    errormsg_deferred: bool,
    nonblocking: bool,
};
pub extern fn XLogInsertRecord(rdata: ?*struct_XLogRecData, fpw_lsn: XLogRecPtr, flags: uint8, num_fpi: c_int, topxid_included: bool) XLogRecPtr;
pub extern fn XLogFlush(record: XLogRecPtr) void;
pub extern fn XLogBackgroundFlush() bool;
pub extern fn XLogNeedsFlush(record: XLogRecPtr) bool;
pub extern fn XLogFileInit(logsegno: XLogSegNo, logtli: TimeLineID) c_int;
pub extern fn XLogFileOpen(segno: XLogSegNo, tli: TimeLineID) c_int;
pub extern fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID) void;
pub extern fn XLogGetLastRemovedSegno() XLogSegNo;
pub extern fn XLogSetAsyncXactLSN(asyncXactLSN: XLogRecPtr) void;
pub extern fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr) void;
pub extern fn xlog_redo(record: [*c]struct_XLogReaderState) void;
pub extern fn xlog_desc(buf: StringInfo, record: [*c]struct_XLogReaderState) void;
pub extern fn xlog_identify(info: uint8) [*c]const u8;
pub extern fn issue_xlog_fsync(fd: c_int, segno: XLogSegNo, tli: TimeLineID) void;
pub extern fn RecoveryInProgress() bool;
pub extern fn GetRecoveryState() RecoveryState;
pub extern fn XLogInsertAllowed() bool;
pub extern fn GetXLogInsertRecPtr() XLogRecPtr;
pub extern fn GetXLogWriteRecPtr() XLogRecPtr;
pub extern fn GetSystemIdentifier() uint64;
pub extern fn GetMockAuthenticationNonce() [*c]u8;
pub extern fn DataChecksumsEnabled() bool;
pub extern fn GetFakeLSNForUnloggedRel() XLogRecPtr;
pub extern fn XLOGShmemSize() Size;
pub extern fn XLOGShmemInit() void;
pub extern fn BootStrapXLOG() void;
pub extern fn InitializeWalConsistencyChecking() void;
pub extern fn LocalProcessControlFile(reset: bool) void;
pub extern fn GetActiveWalLevelOnStandby() WalLevel;
pub extern fn StartupXLOG() void;
pub extern fn ShutdownXLOG(code: c_int, arg: Datum) void;
pub extern fn CreateCheckPoint(flags: c_int) void;
pub extern fn CreateRestartPoint(flags: c_int) bool;
pub extern fn GetWALAvailability(targetLSN: XLogRecPtr) WALAvailability;
pub extern fn XLogPutNextOid(nextOid: Oid) void;
pub extern fn XLogRestorePoint(rpName: [*c]const u8) XLogRecPtr;
pub extern fn UpdateFullPageWrites() void;
pub extern fn GetFullPageWriteInfo(RedoRecPtr_p: [*c]XLogRecPtr, doPageWrites_p: [*c]bool) void;
pub extern fn GetRedoRecPtr() XLogRecPtr;
pub extern fn GetInsertRecPtr() XLogRecPtr;
pub extern fn GetFlushRecPtr(insertTLI: [*c]TimeLineID) XLogRecPtr;
pub extern fn GetWALInsertionTimeLine() TimeLineID;
pub extern fn GetLastImportantRecPtr() XLogRecPtr;
pub extern fn SetWalWriterSleeping(sleeping: bool) void;
pub extern fn RemoveNonParentXlogFiles(switchpoint: XLogRecPtr, newTLI: TimeLineID) void;
pub extern fn XLogCheckpointNeeded(new_segno: XLogSegNo) bool;
pub extern fn SwitchIntoArchiveRecovery(EndRecPtr: XLogRecPtr, replayTLI: TimeLineID) void;
pub extern fn ReachedEndOfBackup(EndRecPtr: XLogRecPtr, tli: TimeLineID) void;
pub extern fn SetInstallXLogFileSegmentActive() void;
pub extern fn IsInstallXLogFileSegmentActive() bool;
pub extern fn XLogShutdownWalRcv() void;
pub const SESSION_BACKUP_NONE: c_int = 0;
pub const SESSION_BACKUP_RUNNING: c_int = 1;
pub const enum_SessionBackupState = c_uint;
pub const SessionBackupState = enum_SessionBackupState;
pub extern fn do_pg_backup_start(backupidstr: [*c]const u8, fast: bool, tablespaces: [*c][*c]List, state: [*c]BackupState, tblspcmapfile: StringInfo) void;
pub extern fn do_pg_backup_stop(state: [*c]BackupState, waitforarchive: bool) void;
pub extern fn do_pg_abort_backup(code: c_int, arg: Datum) void;
pub extern fn register_persistent_abort_backup_handler() void;
pub extern fn get_backup_status() SessionBackupState;
pub const struct_FullTransactionId = extern struct {
    value: uint64,
};
pub const FullTransactionId = struct_FullTransactionId;
pub fn FullTransactionIdFromEpochAndXid(arg_epoch: uint32, arg_xid: TransactionId) callconv(.C) FullTransactionId {
    var epoch = arg_epoch;
    var xid = arg_xid;
    var result: FullTransactionId = undefined;
    result.value = (@bitCast(uint64, @as(c_ulong, epoch)) << @intCast(@import("std").math.Log2Int(uint64), 32)) | @bitCast(c_ulong, @as(c_ulong, xid));
    return result;
}
pub fn FullTransactionIdFromU64(arg_value: uint64) callconv(.C) FullTransactionId {
    var value = arg_value;
    var result: FullTransactionId = undefined;
    result.value = value;
    return result;
}
pub fn FullTransactionIdRetreat(arg_dest: [*c]FullTransactionId) callconv(.C) void {
    var dest = arg_dest;
    dest.*.value -%= 1;
    if (dest.*.value < FullTransactionIdFromEpochAndXid(@bitCast(uint32, @as(c_int, 0)), @bitCast(TransactionId, @as(c_int, 3))).value) return;
    while (@bitCast(uint32, @truncate(c_uint, dest.*.value)) < @bitCast(TransactionId, @as(c_int, 3))) {
        dest.*.value -%= 1;
    }
}
pub fn FullTransactionIdAdvance(arg_dest: [*c]FullTransactionId) callconv(.C) void {
    var dest = arg_dest;
    dest.*.value +%= 1;
    if (dest.*.value < FullTransactionIdFromEpochAndXid(@bitCast(uint32, @as(c_int, 0)), @bitCast(TransactionId, @as(c_int, 3))).value) return;
    while (@bitCast(uint32, @truncate(c_uint, dest.*.value)) < @bitCast(TransactionId, @as(c_int, 3))) {
        dest.*.value +%= 1;
    }
}
pub const struct_VariableCacheData = extern struct {
    nextOid: Oid,
    oidCount: uint32,
    nextXid: FullTransactionId,
    oldestXid: TransactionId,
    xidVacLimit: TransactionId,
    xidWarnLimit: TransactionId,
    xidStopLimit: TransactionId,
    xidWrapLimit: TransactionId,
    oldestXidDB: Oid,
    oldestCommitTsXid: TransactionId,
    newestCommitTsXid: TransactionId,
    latestCompletedXid: FullTransactionId,
    xactCompletionCount: uint64,
    oldestClogXid: TransactionId,
};
pub const VariableCacheData = struct_VariableCacheData;
pub const VariableCache = [*c]VariableCacheData;
pub extern fn TransactionStartedDuringRecovery() bool;
pub extern var ShmemVariableCache: VariableCache;
pub extern fn TransactionIdDidCommit(transactionId: TransactionId) bool;
pub extern fn TransactionIdDidAbort(transactionId: TransactionId) bool;
pub extern fn TransactionIdCommitTree(xid: TransactionId, nxids: c_int, xids: [*c]TransactionId) void;
pub extern fn TransactionIdAsyncCommitTree(xid: TransactionId, nxids: c_int, xids: [*c]TransactionId, lsn: XLogRecPtr) void;
pub extern fn TransactionIdAbortTree(xid: TransactionId, nxids: c_int, xids: [*c]TransactionId) void;
pub extern fn TransactionIdPrecedes(id1: TransactionId, id2: TransactionId) bool;
pub extern fn TransactionIdPrecedesOrEquals(id1: TransactionId, id2: TransactionId) bool;
pub extern fn TransactionIdFollows(id1: TransactionId, id2: TransactionId) bool;
pub extern fn TransactionIdFollowsOrEquals(id1: TransactionId, id2: TransactionId) bool;
pub extern fn TransactionIdLatest(mainxid: TransactionId, nxids: c_int, xids: [*c]const TransactionId) TransactionId;
pub extern fn TransactionIdGetCommitLSN(xid: TransactionId) XLogRecPtr;
pub extern fn GetNewTransactionId(isSubXact: bool) FullTransactionId;
pub extern fn AdvanceNextFullTransactionIdPastXid(xid: TransactionId) void;
pub extern fn ReadNextFullTransactionId() FullTransactionId;
pub extern fn SetTransactionIdLimit(oldest_datfrozenxid: TransactionId, oldest_datoid: Oid) void;
pub extern fn AdvanceOldestClogXid(oldest_datfrozenxid: TransactionId) void;
pub extern fn ForceTransactionIdLimitUpdate() bool;
pub extern fn GetNewObjectId() Oid;
pub extern fn StopGeneratingPinnedObjectIds() void;
pub fn ReadNextTransactionId() callconv(.C) TransactionId {
    return @bitCast(uint32, @truncate(c_uint, ReadNextFullTransactionId().value));
}
pub fn TransactionIdRetreatedBy(arg_xid: TransactionId, arg_amount: uint32) callconv(.C) TransactionId {
    var xid = arg_xid;
    var amount = arg_amount;
    xid -%= amount;
    while (xid < @bitCast(TransactionId, @as(c_int, 3))) {
        xid -%= 1;
    }
    return xid;
}
pub fn TransactionIdOlder(arg_a: TransactionId, arg_b: TransactionId) callconv(.C) TransactionId {
    var a = arg_a;
    var b = arg_b;
    if (!(a != @bitCast(TransactionId, @as(c_int, 0)))) return b;
    if (!(b != @bitCast(TransactionId, @as(c_int, 0)))) return a;
    if (TransactionIdPrecedes(a, b)) return a;
    return b;
}
pub fn NormalTransactionIdOlder(arg_a: TransactionId, arg_b: TransactionId) callconv(.C) TransactionId {
    var a = arg_a;
    var b = arg_b;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    if ((blk: {
        _ = @as(c_int, 1);
        break :blk @bitCast(int32, a -% b) < @as(c_int, 0);
    }) != 0) return a;
    return b;
}
pub fn FullTransactionIdNewer(arg_a: FullTransactionId, arg_b: FullTransactionId) callconv(.C) FullTransactionId {
    var a = arg_a;
    var b = arg_b;
    if (!(@bitCast(uint32, @truncate(c_uint, a.value)) != @bitCast(TransactionId, @as(c_int, 0)))) return b;
    if (!(@bitCast(uint32, @truncate(c_uint, b.value)) != @bitCast(TransactionId, @as(c_int, 0)))) return a;
    if (a.value > b.value) return a;
    return b;
}
pub const RM_XLOG_ID: c_int = 0;
pub const RM_XACT_ID: c_int = 1;
pub const RM_SMGR_ID: c_int = 2;
pub const RM_CLOG_ID: c_int = 3;
pub const RM_DBASE_ID: c_int = 4;
pub const RM_TBLSPC_ID: c_int = 5;
pub const RM_MULTIXACT_ID: c_int = 6;
pub const RM_RELMAP_ID: c_int = 7;
pub const RM_STANDBY_ID: c_int = 8;
pub const RM_HEAP2_ID: c_int = 9;
pub const RM_HEAP_ID: c_int = 10;
pub const RM_BTREE_ID: c_int = 11;
pub const RM_HASH_ID: c_int = 12;
pub const RM_GIN_ID: c_int = 13;
pub const RM_GIST_ID: c_int = 14;
pub const RM_SEQ_ID: c_int = 15;
pub const RM_SPGIST_ID: c_int = 16;
pub const RM_BRIN_ID: c_int = 17;
pub const RM_COMMIT_TS_ID: c_int = 18;
pub const RM_REPLORIGIN_ID: c_int = 19;
pub const RM_GENERIC_ID: c_int = 20;
pub const RM_LOGICALMSG_ID: c_int = 21;
pub const RM_NEXT_ID: c_int = 22;
pub const enum_RmgrIds = c_uint;
pub const RmgrIds = enum_RmgrIds;
pub fn RmgrIdIsBuiltin(arg_rmid: c_int) callconv(.C) bool {
    var rmid = arg_rmid;
    return rmid <= (RM_NEXT_ID - @as(c_int, 1));
}
pub fn RmgrIdIsCustom(arg_rmid: c_int) callconv(.C) bool {
    var rmid = arg_rmid;
    return (rmid >= @as(c_int, 128)) and (rmid <= @as(c_int, 255));
}
pub extern fn pg_comp_crc32c_sb8(crc: pg_crc32c, data: ?*const anyopaque, len: usize) pg_crc32c;
pub extern var pg_comp_crc32c: ?*const fn (pg_crc32c, ?*const anyopaque, usize) callconv(.C) pg_crc32c;
pub extern fn pg_comp_crc32c_sse42(crc: pg_crc32c, data: ?*const anyopaque, len: usize) pg_crc32c;
pub extern var MyBackendId: BackendId;
pub extern var ParallelLeaderBackendId: BackendId;
pub const struct_XLogRecordBlockHeader = extern struct {
    id: uint8,
    fork_flags: uint8,
    data_length: uint16,
};
pub const XLogRecordBlockHeader = struct_XLogRecordBlockHeader;
pub const struct_XLogRecordBlockImageHeader = extern struct {
    length: uint16,
    hole_offset: uint16,
    bimg_info: uint8,
};
pub const XLogRecordBlockImageHeader = struct_XLogRecordBlockImageHeader;
pub const struct_XLogRecordBlockCompressHeader = extern struct {
    hole_length: uint16,
};
pub const XLogRecordBlockCompressHeader = struct_XLogRecordBlockCompressHeader;
pub const struct_XLogRecordDataHeaderShort = extern struct {
    id: uint8,
    data_length: uint8,
};
pub const XLogRecordDataHeaderShort = struct_XLogRecordDataHeaderShort;
pub const struct_XLogRecordDataHeaderLong = extern struct {
    id: uint8,
};
pub const XLogRecordDataHeaderLong = struct_XLogRecordDataHeaderLong;
pub const Buffer = c_int;
pub const struct_BufferAccessStrategyData = opaque {};
pub const BufferAccessStrategy = ?*struct_BufferAccessStrategyData;
pub const DecodedBkpBlock = extern struct {
    in_use: bool,
    rlocator: RelFileLocator,
    forknum: ForkNumber,
    blkno: BlockNumber,
    prefetch_buffer: Buffer,
    flags: uint8,
    has_image: bool,
    apply_image: bool,
    bkp_image: [*c]u8,
    hole_offset: uint16,
    hole_length: uint16,
    bimg_len: uint16,
    bimg_info: uint8,
    has_data: bool,
    data: [*c]u8,
    data_len: uint16,
    data_bufsz: uint16,
};
pub fn XLogReaderHasQueuedRecordOrError(arg_state: [*c]XLogReaderState) callconv(.C) bool {
    var state = arg_state;
    return (state.*.decode_queue_head != @ptrCast([*c]DecodedXLogRecord, @alignCast(@import("std").meta.alignment([*c]DecodedXLogRecord), @intToPtr(?*anyopaque, @as(c_int, 0))))) or (@as(c_int, @boolToInt(state.*.errormsg_deferred)) != 0);
}
pub extern fn XLogReaderAllocate(wal_segment_size: c_int, waldir: [*c]const u8, routine: [*c]XLogReaderRoutine, private_data: ?*anyopaque) [*c]XLogReaderState;
pub extern fn XLogReaderFree(state: [*c]XLogReaderState) void;
pub extern fn XLogReaderSetDecodeBuffer(state: [*c]XLogReaderState, buffer: ?*anyopaque, size: usize) void;
pub extern fn XLogBeginRead(state: [*c]XLogReaderState, RecPtr: XLogRecPtr) void;
pub extern fn XLogFindNextRecord(state: [*c]XLogReaderState, RecPtr: XLogRecPtr) XLogRecPtr;
pub const XLREAD_SUCCESS: c_int = 0;
pub const XLREAD_FAIL: c_int = -1;
pub const XLREAD_WOULDBLOCK: c_int = -2;
pub const enum_XLogPageReadResult = c_int;
pub const XLogPageReadResult = enum_XLogPageReadResult;
pub extern fn XLogReadRecord(state: [*c]XLogReaderState, errormsg: [*c][*c]u8) [*c]struct_XLogRecord;
pub extern fn XLogNextRecord(state: [*c]XLogReaderState, errormsg: [*c][*c]u8) [*c]DecodedXLogRecord;
pub extern fn XLogReleasePreviousRecord(state: [*c]XLogReaderState) XLogRecPtr;
pub extern fn XLogReadAhead(state: [*c]XLogReaderState, nonblocking: bool) [*c]DecodedXLogRecord;
pub extern fn XLogReaderValidatePageHeader(state: [*c]XLogReaderState, recptr: XLogRecPtr, phdr: [*c]u8) bool;
pub extern fn XLogReaderResetError(state: [*c]XLogReaderState) void;
pub const struct_WALReadError = extern struct {
    wre_errno: c_int,
    wre_off: c_int,
    wre_req: c_int,
    wre_read: c_int,
    wre_seg: WALOpenSegment,
};
pub const WALReadError = struct_WALReadError;
pub extern fn WALRead(state: [*c]XLogReaderState, buf: [*c]u8, startptr: XLogRecPtr, count: Size, tli: TimeLineID, errinfo: [*c]WALReadError) bool;
pub extern fn DecodeXLogRecordRequiredSpace(xl_tot_len: usize) usize;
pub extern fn DecodeXLogRecord(state: [*c]XLogReaderState, decoded: [*c]DecodedXLogRecord, record: [*c]XLogRecord, lsn: XLogRecPtr, errormsg: [*c][*c]u8) bool;
pub extern fn XLogRecGetFullXid(record: [*c]XLogReaderState) FullTransactionId;
pub extern fn RestoreBlockImage(record: [*c]XLogReaderState, block_id: uint8, page: [*c]u8) bool;
pub extern fn XLogRecGetBlockData(record: [*c]XLogReaderState, block_id: uint8, len: [*c]Size) [*c]u8;
pub extern fn XLogRecGetBlockTag(record: [*c]XLogReaderState, block_id: uint8, rlocator: [*c]RelFileLocator, forknum: [*c]ForkNumber, blknum: [*c]BlockNumber) void;
pub extern fn XLogRecGetBlockTagExtended(record: [*c]XLogReaderState, block_id: uint8, rlocator: [*c]RelFileLocator, forknum: [*c]ForkNumber, blknum: [*c]BlockNumber, prefetch_buffer: [*c]Buffer) bool;
pub fn att_isnull(arg_ATT: c_int, arg_BITS: [*c]const bits8) callconv(.C) bool {
    var ATT = arg_ATT;
    var BITS = arg_BITS;
    return !((@bitCast(c_int, @as(c_uint, (blk: {
        const tmp = ATT >> @intCast(@import("std").math.Log2Int(c_int), 3);
        if (tmp >= 0) break :blk BITS + @intCast(usize, tmp) else break :blk BITS - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
    }).*)) & (@as(c_int, 1) << @intCast(@import("std").math.Log2Int(c_int), ATT & @as(c_int, 7)))) != 0);
}
pub fn fetch_att(arg_T: ?*const anyopaque, arg_attbyval: bool, arg_attlen: c_int) callconv(.C) Datum {
    var T = arg_T;
    var attbyval = arg_attbyval;
    var attlen = arg_attlen;
    if (attbyval) {
        while (true) {
            switch (attlen) {
                @bitCast(c_int, @truncate(c_uint, @as(c_ulong, 1))) => return CharGetDatum(@ptrCast([*c]const u8, @alignCast(@import("std").meta.alignment([*c]const u8), T)).*),
                @bitCast(c_int, @truncate(c_uint, @as(c_ulong, 2))) => return Int16GetDatum(@ptrCast([*c]const int16, @alignCast(@import("std").meta.alignment([*c]const int16), T)).*),
                @bitCast(c_int, @truncate(c_uint, @as(c_ulong, 4))) => return Int32GetDatum(@ptrCast([*c]const int32, @alignCast(@import("std").meta.alignment([*c]const int32), T)).*),
                @bitCast(c_int, @truncate(c_uint, @as(c_ulong, 8))) => return @ptrCast([*c]const Datum, @alignCast(@import("std").meta.alignment([*c]const Datum), T)).*,
                else => {
                    while (true) {
                        var __errno_location_1: c_int = undefined;
                        _ = @TypeOf(__errno_location_1);
                        if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                            _ = blk: {
                                _ = errmsg_internal("unsupported byval length: %d", attlen);
                                break :blk errfinish("../../src/include/access/tupmacs.h", @as(c_int, 69), "fetch_att");
                            };
                        }
                        if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                            __builtin_unreachable();
                        }
                        if (!false) break;
                    }
                    return 0;
                },
            }
            break;
        }
    } else return PointerGetDatum(T);
    return 0;
}
pub fn store_att_byval(arg_T: ?*anyopaque, arg_newdatum: Datum, arg_attlen: c_int) callconv(.C) void {
    var T = arg_T;
    var newdatum = arg_newdatum;
    var attlen = arg_attlen;
    while (true) {
        switch (attlen) {
            @bitCast(c_int, @truncate(c_uint, @as(c_ulong, 1))) => {
                @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), T)).* = DatumGetChar(newdatum);
                break;
            },
            @bitCast(c_int, @truncate(c_uint, @as(c_ulong, 2))) => {
                @ptrCast([*c]int16, @alignCast(@import("std").meta.alignment([*c]int16), T)).* = DatumGetInt16(newdatum);
                break;
            },
            @bitCast(c_int, @truncate(c_uint, @as(c_ulong, 4))) => {
                @ptrCast([*c]int32, @alignCast(@import("std").meta.alignment([*c]int32), T)).* = DatumGetInt32(newdatum);
                break;
            },
            @bitCast(c_int, @truncate(c_uint, @as(c_ulong, 8))) => {
                @ptrCast([*c]Datum, @alignCast(@import("std").meta.alignment([*c]Datum), T)).* = newdatum;
                break;
            },
            else => {
                while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = errmsg_internal("unsupported byval length: %d", attlen);
                            break :blk errfinish("../../src/include/access/tupmacs.h", @as(c_int, 202), "store_att_byval");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                }
            },
        }
        break;
    }
}
pub const Item = Pointer;
pub const Page = Pointer;
pub const LocationIndex = uint16;
pub const PageXLogRecPtr = extern struct {
    xlogid: uint32,
    xrecoff: uint32,
};
pub fn PageXLogRecPtrGet(arg_val: PageXLogRecPtr) callconv(.C) XLogRecPtr {
    var val = arg_val;
    return (@bitCast(uint64, @as(c_ulong, val.xlogid)) << @intCast(@import("std").math.Log2Int(uint64), 32)) | @bitCast(c_ulong, @as(c_ulong, val.xrecoff));
}
pub const struct_PageHeaderData = extern struct {
    pd_lsn: PageXLogRecPtr align(4),
    pd_checksum: uint16,
    pd_flags: uint16,
    pd_lower: LocationIndex,
    pd_upper: LocationIndex,
    pd_special: LocationIndex,
    pd_pagesize_version: uint16,
    pd_prune_xid: TransactionId,
    pub fn pd_linp(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), ItemIdData) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), ItemIdData);
        return @ptrCast(ReturnType, @alignCast(@alignOf(ItemIdData), @ptrCast(Intermediate, self) + 24));
    }
};
pub const PageHeaderData = struct_PageHeaderData;
pub const PageHeader = [*c]PageHeaderData;
pub fn PageIsEmpty(arg_page: Page) callconv(.C) bool {
    var page = arg_page;
    return @bitCast(c_ulong, @as(c_ulong, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_lower)) <= @offsetOf(struct_PageHeaderData, "pd_linp");
}
pub fn PageIsNew(arg_page: Page) callconv(.C) bool {
    var page = arg_page;
    return @bitCast(c_int, @as(c_uint, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_upper)) == @as(c_int, 0);
}
pub fn PageGetItemId(arg_page: Page, arg_offsetNumber: OffsetNumber) callconv(.C) ItemId {
    var page = arg_page;
    var offsetNumber = arg_offsetNumber;
    return &@ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_linp()[@intCast(c_uint, @bitCast(c_int, @as(c_uint, offsetNumber)) - @as(c_int, 1))];
}
pub fn PageGetContents(arg_page: Page) callconv(.C) [*c]u8 {
    var page = arg_page;
    return @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), page)) + ((@bitCast(usize, @offsetOf(struct_PageHeaderData, "pd_linp")) +% @bitCast(c_ulong, @as(c_long, @as(c_int, 8) - @as(c_int, 1)))) & ~@bitCast(usize, @as(c_long, @as(c_int, 8) - @as(c_int, 1))));
}
pub fn PageGetPageSize(arg_page: Page) callconv(.C) Size {
    var page = arg_page;
    return @bitCast(Size, @as(c_long, @bitCast(c_int, @as(c_uint, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_pagesize_version)) & @bitCast(c_int, @as(c_uint, @bitCast(uint16, @truncate(c_short, @as(c_int, 65280)))))));
}
pub fn PageGetPageLayoutVersion(arg_page: Page) callconv(.C) uint8 {
    var page = arg_page;
    return @bitCast(uint8, @truncate(i8, @bitCast(c_int, @as(c_uint, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_pagesize_version)) & @as(c_int, 255)));
}
pub fn PageSetPageSizeAndVersion(arg_page: Page, arg_size: Size, arg_version: uint8) callconv(.C) void {
    var page = arg_page;
    var size = arg_size;
    var version = arg_version;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_pagesize_version = @bitCast(uint16, @truncate(c_ushort, size | @bitCast(c_ulong, @as(c_ulong, version))));
}
pub fn PageGetSpecialSize(arg_page: Page) callconv(.C) uint16 {
    var page = arg_page;
    return @bitCast(uint16, @truncate(c_ushort, PageGetPageSize(page) -% @bitCast(c_ulong, @as(c_ulong, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_special))));
}
pub fn PageValidateSpecialPointer(arg_page: Page) callconv(.C) void {
    var page = arg_page;
    _ = @TypeOf(page);
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
}
pub fn PageGetSpecialPointer(arg_page: Page) callconv(.C) [*c]u8 {
    var page = arg_page;
    PageValidateSpecialPointer(page);
    return @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), page)) + @bitCast(usize, @intCast(isize, @bitCast(c_int, @as(c_uint, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_special))));
}
pub fn PageGetItem(arg_page: Page, arg_itemId: ItemId) callconv(.C) Item {
    var page = arg_page;
    var itemId = arg_itemId;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    return @ptrCast(Item, @alignCast(@import("std").meta.alignment(Item), @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), page)) + @bitCast(usize, @intCast(isize, @bitCast(c_int, itemId.*.lp_off)))));
}
pub fn PageGetMaxOffsetNumber(arg_page: Page) callconv(.C) OffsetNumber {
    var page = arg_page;
    var pageheader: PageHeader = @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page));
    if (@bitCast(c_ulong, @as(c_ulong, pageheader.*.pd_lower)) <= @offsetOf(struct_PageHeaderData, "pd_linp")) return 0 else return @bitCast(OffsetNumber, @truncate(c_ushort, (@bitCast(c_ulong, @as(c_ulong, pageheader.*.pd_lower)) -% @offsetOf(struct_PageHeaderData, "pd_linp")) / @sizeOf(ItemIdData)));
    return 0;
}
pub fn PageGetLSN(arg_page: Page) callconv(.C) XLogRecPtr {
    var page = arg_page;
    return PageXLogRecPtrGet(@ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_lsn);
}
pub fn PageSetLSN(arg_page: Page, arg_lsn: XLogRecPtr) callconv(.C) void {
    var page = arg_page;
    var lsn = arg_lsn;
    _ = blk: {
        @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_lsn.xlogid = @bitCast(uint32, @truncate(c_uint, lsn >> @intCast(@import("std").math.Log2Int(XLogRecPtr), 32)));
        break :blk blk_1: {
            const tmp = @bitCast(uint32, @truncate(c_uint, lsn));
            @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_lsn.xrecoff = tmp;
            break :blk_1 tmp;
        };
    };
}
pub fn PageHasFreeLinePointers(arg_page: Page) callconv(.C) bool {
    var page = arg_page;
    return (@bitCast(c_int, @as(c_uint, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags)) & @as(c_int, 1)) != 0;
}
pub fn PageSetHasFreeLinePointers(arg_page: Page) callconv(.C) void {
    var page = arg_page;
    @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags |= @bitCast(uint16, @truncate(c_short, @as(c_int, 1)));
}
pub fn PageClearHasFreeLinePointers(arg_page: Page) callconv(.C) void {
    var page = arg_page;
    @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags &= @bitCast(uint16, @truncate(c_short, ~@as(c_int, 1)));
}
pub fn PageIsFull(arg_page: Page) callconv(.C) bool {
    var page = arg_page;
    return (@bitCast(c_int, @as(c_uint, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags)) & @as(c_int, 2)) != 0;
}
pub fn PageSetFull(arg_page: Page) callconv(.C) void {
    var page = arg_page;
    @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags |= @bitCast(uint16, @truncate(c_short, @as(c_int, 2)));
}
pub fn PageClearFull(arg_page: Page) callconv(.C) void {
    var page = arg_page;
    @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags &= @bitCast(uint16, @truncate(c_short, ~@as(c_int, 2)));
}
pub fn PageIsAllVisible(arg_page: Page) callconv(.C) bool {
    var page = arg_page;
    return (@bitCast(c_int, @as(c_uint, @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags)) & @as(c_int, 4)) != 0;
}
pub fn PageSetAllVisible(arg_page: Page) callconv(.C) void {
    var page = arg_page;
    @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags |= @bitCast(uint16, @truncate(c_short, @as(c_int, 4)));
}
pub fn PageClearAllVisible(arg_page: Page) callconv(.C) void {
    var page = arg_page;
    @ptrCast(PageHeader, @alignCast(@import("std").meta.alignment(PageHeader), page)).*.pd_flags &= @bitCast(uint16, @truncate(c_short, ~@as(c_int, 4)));
} // ../../src/include/c.h:914:2: warning: ignoring StaticAssert declaration
pub extern fn PageInit(page: Page, pageSize: Size, specialSize: Size) void;
pub extern fn PageIsVerifiedExtended(page: Page, blkno: BlockNumber, flags: c_int) bool;
pub extern fn PageAddItemExtended(page: Page, item: Item, size: Size, offsetNumber: OffsetNumber, flags: c_int) OffsetNumber;
pub extern fn PageGetTempPage(page: Page) Page;
pub extern fn PageGetTempPageCopy(page: Page) Page;
pub extern fn PageGetTempPageCopySpecial(page: Page) Page;
pub extern fn PageRestoreTempPage(tempPage: Page, oldPage: Page) void;
pub extern fn PageRepairFragmentation(page: Page) void;
pub extern fn PageTruncateLinePointerArray(page: Page) void;
pub extern fn PageGetFreeSpace(page: Page) Size;
pub extern fn PageGetFreeSpaceForMultipleTuples(page: Page, ntups: c_int) Size;
pub extern fn PageGetExactFreeSpace(page: Page) Size;
pub extern fn PageGetHeapFreeSpace(page: Page) Size;
pub extern fn PageIndexTupleDelete(page: Page, offnum: OffsetNumber) void;
pub extern fn PageIndexMultiDelete(page: Page, itemnos: [*c]OffsetNumber, nitems: c_int) void;
pub extern fn PageIndexTupleDeleteNoCompact(page: Page, offnum: OffsetNumber) void;
pub extern fn PageIndexTupleOverwrite(page: Page, offnum: OffsetNumber, newtup: Item, newsize: Size) bool;
pub extern fn PageSetChecksumCopy(page: Page, blkno: BlockNumber) [*c]u8;
pub extern fn PageSetChecksumInplace(page: Page, blkno: BlockNumber) void;
pub const struct_varatt_external = extern struct {
    va_rawsize: int32,
    va_extinfo: uint32,
    va_valueid: Oid,
    va_toastrelid: Oid,
};
pub const varatt_external = struct_varatt_external;
pub const struct_varatt_indirect = extern struct {
    pointer: [*c]struct_varlena,
};
pub const varatt_indirect = struct_varatt_indirect;
pub const struct_ExpandedObjectHeader = opaque {};
pub const ExpandedObjectHeader = struct_ExpandedObjectHeader;
pub const struct_varatt_expanded = extern struct {
    eohptr: ?*ExpandedObjectHeader,
};
pub const varatt_expanded = struct_varatt_expanded;
pub const VARTAG_INDIRECT: c_int = 1;
pub const VARTAG_EXPANDED_RO: c_int = 2;
pub const VARTAG_EXPANDED_RW: c_int = 3;
pub const VARTAG_ONDISK: c_int = 18;
pub const enum_vartag_external = c_uint;
pub const vartag_external = enum_vartag_external;
const struct_unnamed_11 = extern struct {
    va_header: uint32 align(4),
    pub fn va_data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @ptrCast(ReturnType, @alignCast(@alignOf(u8), @ptrCast(Intermediate, self) + 4));
    }
};
const struct_unnamed_12 = extern struct {
    va_header: uint32 align(4),
    va_tcinfo: uint32,
    pub fn va_data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @ptrCast(ReturnType, @alignCast(@alignOf(u8), @ptrCast(Intermediate, self) + 8));
    }
};
pub const varattrib_4b = extern union {
    va_4byte: struct_unnamed_11,
    va_compressed: struct_unnamed_12,
};
pub const varattrib_1b = extern struct {
    va_header: uint8 align(1),
    pub fn va_data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @ptrCast(ReturnType, @alignCast(@alignOf(u8), @ptrCast(Intermediate, self) + 1));
    }
};
pub const varattrib_1b_e = extern struct {
    va_header: uint8 align(1),
    va_tag: uint8,
    pub fn va_data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @ptrCast(ReturnType, @alignCast(@alignOf(u8), @ptrCast(Intermediate, self) + 2));
    }
}; // ../../src/include/c.h:914:2: warning: ignoring StaticAssert declaration
pub extern fn heap_compute_data_size(tupleDesc: TupleDesc, values: [*c]Datum, isnull: [*c]bool) Size;
pub extern fn heap_fill_tuple(tupleDesc: TupleDesc, values: [*c]Datum, isnull: [*c]bool, data: [*c]u8, data_size: Size, infomask: [*c]uint16, bit: [*c]bits8) void;
pub extern fn heap_attisnull(tup: HeapTuple, attnum: c_int, tupleDesc: TupleDesc) bool;
pub extern fn nocachegetattr(tup: HeapTuple, attnum: c_int, tupleDesc: TupleDesc) Datum;
pub extern fn heap_getsysattr(tup: HeapTuple, attnum: c_int, tupleDesc: TupleDesc, isnull: [*c]bool) Datum;
pub extern fn getmissingattr(tupleDesc: TupleDesc, attnum: c_int, isnull: [*c]bool) Datum;
pub extern fn heap_copytuple(tuple: HeapTuple) HeapTuple;
pub extern fn heap_copytuple_with_tuple(src: HeapTuple, dest: HeapTuple) void;
pub extern fn heap_copy_tuple_as_datum(tuple: HeapTuple, tupleDesc: TupleDesc) Datum;
pub extern fn heap_form_tuple(tupleDescriptor: TupleDesc, values: [*c]Datum, isnull: [*c]bool) HeapTuple;
pub extern fn heap_modify_tuple(tuple: HeapTuple, tupleDesc: TupleDesc, replValues: [*c]Datum, replIsnull: [*c]bool, doReplace: [*c]bool) HeapTuple;
pub extern fn heap_modify_tuple_by_cols(tuple: HeapTuple, tupleDesc: TupleDesc, nCols: c_int, replCols: [*c]c_int, replValues: [*c]Datum, replIsnull: [*c]bool) HeapTuple;
pub extern fn heap_deform_tuple(tuple: HeapTuple, tupleDesc: TupleDesc, values: [*c]Datum, isnull: [*c]bool) void;
pub extern fn heap_freetuple(htup: HeapTuple) void;
pub extern fn heap_form_minimal_tuple(tupleDescriptor: TupleDesc, values: [*c]Datum, isnull: [*c]bool) MinimalTuple;
pub extern fn heap_free_minimal_tuple(mtup: MinimalTuple) void;
pub extern fn heap_copy_minimal_tuple(mtup: MinimalTuple) MinimalTuple;
pub extern fn heap_tuple_from_minimal_tuple(mtup: MinimalTuple) HeapTuple;
pub extern fn minimal_tuple_from_heap_tuple(htup: HeapTuple) MinimalTuple;
pub extern fn varsize_any(p: ?*anyopaque) usize;
pub extern fn heap_expand_tuple(sourceTuple: HeapTuple, tupleDesc: TupleDesc) HeapTuple;
pub extern fn minimal_expand_tuple(sourceTuple: HeapTuple, tupleDesc: TupleDesc) MinimalTuple;
pub fn fastgetattr(arg_tup: HeapTuple, arg_attnum: c_int, arg_tupleDesc: TupleDesc, arg_isnull: [*c]bool) callconv(.C) Datum {
    var tup = arg_tup;
    var attnum = arg_attnum;
    var tupleDesc = arg_tupleDesc;
    var isnull = arg_isnull;
    _ = @as(c_int, 1);
    isnull.* = @as(c_int, 0) != 0;
    if (!((@bitCast(c_int, @as(c_uint, tup.*.t_data.*.t_infomask)) & @as(c_int, 1)) != 0)) {
        var att: Form_pg_attribute = undefined;
        att = &tupleDesc.*.attrs()[@intCast(c_uint, attnum - @as(c_int, 1))];
        if (att.*.attcacheoff >= @as(c_int, 0)) return fetch_att(@ptrCast(?*const anyopaque, (@ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), tup.*.t_data)) + @bitCast(usize, @intCast(isize, @bitCast(c_int, @as(c_uint, tup.*.t_data.*.t_hoff))))) + @bitCast(usize, @intCast(isize, att.*.attcacheoff))), att.*.attbyval, @bitCast(c_int, @as(c_int, att.*.attlen))) else return nocachegetattr(tup, attnum, tupleDesc);
    } else {
        if (att_isnull(attnum - @as(c_int, 1), tup.*.t_data.*.t_bits())) {
            isnull.* = @as(c_int, 1) != 0;
            return @intCast(Datum, @ptrToInt(@intToPtr(?*anyopaque, @as(c_int, 0))));
        } else return nocachegetattr(tup, attnum, tupleDesc);
    }
    return 0;
}
pub fn heap_getattr(arg_tup: HeapTuple, arg_attnum: c_int, arg_tupleDesc: TupleDesc, arg_isnull: [*c]bool) callconv(.C) Datum {
    var tup = arg_tup;
    var attnum = arg_attnum;
    var tupleDesc = arg_tupleDesc;
    var isnull = arg_isnull;
    if (attnum > @as(c_int, 0)) {
        if (attnum > (@bitCast(c_int, @as(c_uint, tup.*.t_data.*.t_infomask2)) & @as(c_int, 2047))) return getmissingattr(tupleDesc, attnum, isnull) else return fastgetattr(tup, attnum, tupleDesc, isnull);
    } else return heap_getsysattr(tup, attnum, tupleDesc, isnull);
    return 0;
}
pub const struct_dlist_head = extern struct {
    head: dlist_node,
};
pub const dlist_head = struct_dlist_head;
pub const struct_dlist_iter = extern struct {
    cur: [*c]dlist_node,
    end: [*c]dlist_node,
};
pub const dlist_iter = struct_dlist_iter;
pub const struct_dlist_mutable_iter = extern struct {
    cur: [*c]dlist_node,
    next: [*c]dlist_node,
    end: [*c]dlist_node,
};
pub const dlist_mutable_iter = struct_dlist_mutable_iter;
pub const struct_dclist_head = extern struct {
    dlist: dlist_head,
    count: uint32,
};
pub const dclist_head = struct_dclist_head;
pub const slist_node = struct_slist_node;
pub const struct_slist_node = extern struct {
    next: [*c]slist_node,
};
pub const struct_slist_head = extern struct {
    head: slist_node,
};
pub const slist_head = struct_slist_head;
pub const struct_slist_iter = extern struct {
    cur: [*c]slist_node,
};
pub const slist_iter = struct_slist_iter;
pub const struct_slist_mutable_iter = extern struct {
    cur: [*c]slist_node,
    next: [*c]slist_node,
    prev: [*c]slist_node,
};
pub const slist_mutable_iter = struct_slist_mutable_iter;
pub extern fn slist_delete(head: [*c]slist_head, node: [*c]const slist_node) void;
pub fn dlist_init(arg_head: [*c]dlist_head) callconv(.C) void {
    var head = arg_head;
    head.*.head.next = blk: {
        const tmp = &head.*.head;
        head.*.head.prev = tmp;
        break :blk tmp;
    };
}
pub fn dlist_node_init(arg_node: [*c]dlist_node) callconv(.C) void {
    var node = arg_node;
    node.*.next = blk: {
        const tmp = null;
        node.*.prev = tmp;
        break :blk tmp;
    };
}
pub fn dlist_is_empty(arg_head: [*c]const dlist_head) callconv(.C) bool {
    var head = arg_head;
    _ = @TypeOf(head);
    return (head.*.head.next == @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), @intToPtr(?*anyopaque, @as(c_int, 0))))) or (head.*.head.next == @intToPtr([*c]dlist_node, @ptrToInt(&head.*.head)));
}
pub fn dlist_push_head(arg_head: [*c]dlist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    if (head.*.head.next == @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        dlist_init(head);
    }
    node.*.next = head.*.head.next;
    node.*.prev = &head.*.head;
    node.*.next.*.prev = node;
    head.*.head.next = node;
    _ = @TypeOf(head);
}
pub fn dlist_push_tail(arg_head: [*c]dlist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    if (head.*.head.next == @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        dlist_init(head);
    }
    node.*.next = &head.*.head;
    node.*.prev = head.*.head.prev;
    node.*.prev.*.next = node;
    head.*.head.prev = node;
    _ = @TypeOf(head);
}
pub fn dlist_insert_after(arg_after: [*c]dlist_node, arg_node: [*c]dlist_node) callconv(.C) void {
    var after = arg_after;
    var node = arg_node;
    node.*.prev = after;
    node.*.next = after.*.next;
    after.*.next = node;
    node.*.next.*.prev = node;
}
pub fn dlist_insert_before(arg_before: [*c]dlist_node, arg_node: [*c]dlist_node) callconv(.C) void {
    var before = arg_before;
    var node = arg_node;
    node.*.prev = before.*.prev;
    node.*.next = before;
    before.*.prev = node;
    node.*.prev.*.next = node;
}
pub fn dlist_delete(arg_node: [*c]dlist_node) callconv(.C) void {
    var node = arg_node;
    node.*.prev.*.next = node.*.next;
    node.*.next.*.prev = node.*.prev;
}
pub fn dlist_delete_thoroughly(arg_node: [*c]dlist_node) callconv(.C) void {
    var node = arg_node;
    node.*.prev.*.next = node.*.next;
    node.*.next.*.prev = node.*.prev;
    node.*.next = null;
    node.*.prev = null;
}
pub fn dlist_delete_from(arg_head: [*c]dlist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    _ = @TypeOf(head);
    dlist_delete(node);
}
pub fn dlist_delete_from_thoroughly(arg_head: [*c]dlist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    _ = @TypeOf(head);
    dlist_delete_thoroughly(node);
}
pub fn dlist_pop_head_node(arg_head: [*c]dlist_head) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    var node: [*c]dlist_node = undefined;
    _ = @as(c_int, 1);
    node = head.*.head.next;
    dlist_delete(node);
    return node;
}
pub fn dlist_move_head(arg_head: [*c]dlist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    if (head.*.head.next == node) return;
    dlist_delete(node);
    dlist_push_head(head, node);
    _ = @TypeOf(head);
}
pub fn dlist_move_tail(arg_head: [*c]dlist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    if (head.*.head.prev == node) return;
    dlist_delete(node);
    dlist_push_tail(head, node);
    _ = @TypeOf(head);
}
pub fn dlist_has_next(arg_head: [*c]const dlist_head, arg_node: [*c]const dlist_node) callconv(.C) bool {
    var head = arg_head;
    var node = arg_node;
    return node.*.next != @intToPtr([*c]dlist_node, @ptrToInt(&head.*.head));
}
pub fn dlist_has_prev(arg_head: [*c]const dlist_head, arg_node: [*c]const dlist_node) callconv(.C) bool {
    var head = arg_head;
    var node = arg_node;
    return node.*.prev != @intToPtr([*c]dlist_node, @ptrToInt(&head.*.head));
}
pub fn dlist_node_is_detached(arg_node: [*c]const dlist_node) callconv(.C) bool {
    var node = arg_node;
    _ = @as(c_int, 1);
    return node.*.next == @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), @intToPtr(?*anyopaque, @as(c_int, 0))));
}
pub fn dlist_next_node(arg_head: [*c]dlist_head, arg_node: [*c]dlist_node) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    _ = @TypeOf(head);
    var node = arg_node;
    _ = @as(c_int, 1);
    return node.*.next;
}
pub fn dlist_prev_node(arg_head: [*c]dlist_head, arg_node: [*c]dlist_node) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    _ = @TypeOf(head);
    var node = arg_node;
    _ = @as(c_int, 1);
    return node.*.prev;
}
pub fn dlist_head_element_off(arg_head: [*c]dlist_head, arg_off: usize) callconv(.C) ?*anyopaque {
    var head = arg_head;
    var off = arg_off;
    _ = @as(c_int, 1);
    return @ptrCast(?*anyopaque, @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), head.*.head.next)) - off);
}
pub fn dlist_head_node(arg_head: [*c]dlist_head) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    return @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), dlist_head_element_off(head, @bitCast(usize, @as(c_long, @as(c_int, 0))))));
}
pub fn dlist_tail_element_off(arg_head: [*c]dlist_head, arg_off: usize) callconv(.C) ?*anyopaque {
    var head = arg_head;
    var off = arg_off;
    _ = @as(c_int, 1);
    return @ptrCast(?*anyopaque, @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), head.*.head.prev)) - off);
}
pub fn dlist_tail_node(arg_head: [*c]dlist_head) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    return @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), dlist_tail_element_off(head, @bitCast(usize, @as(c_long, @as(c_int, 0))))));
}
pub fn dclist_init(arg_head: [*c]dclist_head) callconv(.C) void {
    var head = arg_head;
    dlist_init(&head.*.dlist);
    head.*.count = 0;
}
pub fn dclist_is_empty(arg_head: [*c]const dclist_head) callconv(.C) bool {
    var head = arg_head;
    _ = @as(c_int, 1);
    return head.*.count == @bitCast(c_uint, @as(c_int, 0));
}
pub fn dclist_push_head(arg_head: [*c]dclist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    if (head.*.dlist.head.next == @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        dclist_init(head);
    }
    dlist_push_head(&head.*.dlist, node);
    head.*.count +%= 1;
    _ = @as(c_int, 1);
}
pub fn dclist_push_tail(arg_head: [*c]dclist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    if (head.*.dlist.head.next == @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        dclist_init(head);
    }
    dlist_push_tail(&head.*.dlist, node);
    head.*.count +%= 1;
    _ = @as(c_int, 1);
}
pub fn dclist_insert_after(arg_head: [*c]dclist_head, arg_after: [*c]dlist_node, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var after = arg_after;
    var node = arg_node;
    _ = &head.*.dlist;
    _ = @as(c_int, 1);
    dlist_insert_after(after, node);
    head.*.count +%= 1;
    _ = @as(c_int, 1);
}
pub fn dclist_insert_before(arg_head: [*c]dclist_head, arg_before: [*c]dlist_node, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var before = arg_before;
    var node = arg_node;
    _ = &head.*.dlist;
    _ = @as(c_int, 1);
    dlist_insert_before(before, node);
    head.*.count +%= 1;
    _ = @as(c_int, 1);
}
pub fn dclist_delete_from(arg_head: [*c]dclist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    _ = @as(c_int, 1);
    dlist_delete_from(&head.*.dlist, node);
    head.*.count -%= 1;
}
pub fn dclist_delete_from_thoroughly(arg_head: [*c]dclist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    _ = @as(c_int, 1);
    dlist_delete_from_thoroughly(&head.*.dlist, node);
    head.*.count -%= 1;
}
pub fn dclist_pop_head_node(arg_head: [*c]dclist_head) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    var node: [*c]dlist_node = undefined;
    _ = @as(c_int, 1);
    node = dlist_pop_head_node(&head.*.dlist);
    head.*.count -%= 1;
    return node;
}
pub fn dclist_move_head(arg_head: [*c]dclist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    _ = &head.*.dlist;
    _ = @as(c_int, 1);
    dlist_move_head(&head.*.dlist, node);
}
pub fn dclist_move_tail(arg_head: [*c]dclist_head, arg_node: [*c]dlist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    _ = &head.*.dlist;
    _ = @as(c_int, 1);
    dlist_move_tail(&head.*.dlist, node);
}
pub fn dclist_has_next(arg_head: [*c]const dclist_head, arg_node: [*c]const dlist_node) callconv(.C) bool {
    var head = arg_head;
    var node = arg_node;
    _ = &head.*.dlist;
    _ = @as(c_int, 1);
    return dlist_has_next(&head.*.dlist, node);
}
pub fn dclist_has_prev(arg_head: [*c]const dclist_head, arg_node: [*c]const dlist_node) callconv(.C) bool {
    var head = arg_head;
    var node = arg_node;
    _ = &head.*.dlist;
    _ = @as(c_int, 1);
    return dlist_has_prev(&head.*.dlist, node);
}
pub fn dclist_next_node(arg_head: [*c]dclist_head, arg_node: [*c]dlist_node) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    var node = arg_node;
    _ = @as(c_int, 1);
    return dlist_next_node(&head.*.dlist, node);
}
pub fn dclist_prev_node(arg_head: [*c]dclist_head, arg_node: [*c]dlist_node) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    var node = arg_node;
    _ = @as(c_int, 1);
    return dlist_prev_node(&head.*.dlist, node);
}
pub fn dclist_head_element_off(arg_head: [*c]dclist_head, arg_off: usize) callconv(.C) ?*anyopaque {
    var head = arg_head;
    var off = arg_off;
    _ = @as(c_int, 1);
    return @ptrCast(?*anyopaque, @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), head.*.dlist.head.next)) - off);
}
pub fn dclist_head_node(arg_head: [*c]dclist_head) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    _ = @as(c_int, 1);
    return @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), dlist_head_element_off(&head.*.dlist, @bitCast(usize, @as(c_long, @as(c_int, 0))))));
}
pub fn dclist_tail_element_off(arg_head: [*c]dclist_head, arg_off: usize) callconv(.C) ?*anyopaque {
    var head = arg_head;
    var off = arg_off;
    _ = @as(c_int, 1);
    return @ptrCast(?*anyopaque, @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), head.*.dlist.head.prev)) - off);
}
pub fn dclist_tail_node(arg_head: [*c]dclist_head) callconv(.C) [*c]dlist_node {
    var head = arg_head;
    _ = @as(c_int, 1);
    return @ptrCast([*c]dlist_node, @alignCast(@import("std").meta.alignment([*c]dlist_node), dlist_tail_element_off(&head.*.dlist, @bitCast(usize, @as(c_long, @as(c_int, 0))))));
}
pub fn dclist_count(arg_head: [*c]const dclist_head) callconv(.C) uint32 {
    var head = arg_head;
    _ = @as(c_int, 1);
    return head.*.count;
}
pub fn slist_init(arg_head: [*c]slist_head) callconv(.C) void {
    var head = arg_head;
    head.*.head.next = null;
}
pub fn slist_is_empty(arg_head: [*c]const slist_head) callconv(.C) bool {
    var head = arg_head;
    _ = @TypeOf(head);
    return head.*.head.next == @ptrCast([*c]slist_node, @alignCast(@import("std").meta.alignment([*c]slist_node), @intToPtr(?*anyopaque, @as(c_int, 0))));
}
pub fn slist_push_head(arg_head: [*c]slist_head, arg_node: [*c]slist_node) callconv(.C) void {
    var head = arg_head;
    var node = arg_node;
    node.*.next = head.*.head.next;
    head.*.head.next = node;
    _ = @TypeOf(head);
}
pub fn slist_insert_after(arg_after: [*c]slist_node, arg_node: [*c]slist_node) callconv(.C) void {
    var after = arg_after;
    var node = arg_node;
    node.*.next = after.*.next;
    after.*.next = node;
}
pub fn slist_pop_head_node(arg_head: [*c]slist_head) callconv(.C) [*c]slist_node {
    var head = arg_head;
    var node: [*c]slist_node = undefined;
    _ = @as(c_int, 1);
    node = head.*.head.next;
    head.*.head.next = node.*.next;
    _ = @TypeOf(head);
    return node;
}
pub fn slist_has_next(arg_head: [*c]const slist_head, arg_node: [*c]const slist_node) callconv(.C) bool {
    var head = arg_head;
    var node = arg_node;
    _ = @TypeOf(head);
    return node.*.next != @ptrCast([*c]slist_node, @alignCast(@import("std").meta.alignment([*c]slist_node), @intToPtr(?*anyopaque, @as(c_int, 0))));
}
pub fn slist_next_node(arg_head: [*c]slist_head, arg_node: [*c]slist_node) callconv(.C) [*c]slist_node {
    var head = arg_head;
    _ = @TypeOf(head);
    var node = arg_node;
    _ = @as(c_int, 1);
    return node.*.next;
}
pub fn slist_head_element_off(arg_head: [*c]slist_head, arg_off: usize) callconv(.C) ?*anyopaque {
    var head = arg_head;
    var off = arg_off;
    _ = @as(c_int, 1);
    return @ptrCast(?*anyopaque, @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), head.*.head.next)) - off);
}
pub fn slist_head_node(arg_head: [*c]slist_head) callconv(.C) [*c]slist_node {
    var head = arg_head;
    return @ptrCast([*c]slist_node, @alignCast(@import("std").meta.alignment([*c]slist_node), slist_head_element_off(head, @bitCast(usize, @as(c_long, @as(c_int, 0))))));
}
pub fn slist_delete_current(arg_iter: [*c]slist_mutable_iter) callconv(.C) void {
    var iter = arg_iter;
    iter.*.prev.*.next = iter.*.next;
    iter.*.cur = iter.*.prev;
}
pub const sig_atomic_t = __sig_atomic_t;
pub const union_sigval = extern union {
    sival_int: c_int,
    sival_ptr: ?*anyopaque,
};
pub const __sigval_t = union_sigval;
const struct_unnamed_14 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
};
const struct_unnamed_15 = extern struct {
    si_tid: c_int,
    si_overrun: c_int,
    si_sigval: __sigval_t,
};
const struct_unnamed_16 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
    si_sigval: __sigval_t,
};
const struct_unnamed_17 = extern struct {
    si_pid: __pid_t,
    si_uid: __uid_t,
    si_status: c_int,
    si_utime: __clock_t,
    si_stime: __clock_t,
};
const struct_unnamed_20 = extern struct {
    _lower: ?*anyopaque,
    _upper: ?*anyopaque,
};
const union_unnamed_19 = extern union {
    _addr_bnd: struct_unnamed_20,
    _pkey: __uint32_t,
};
const struct_unnamed_18 = extern struct {
    si_addr: ?*anyopaque,
    si_addr_lsb: c_short,
    _bounds: union_unnamed_19,
};
const struct_unnamed_21 = extern struct {
    si_band: c_long,
    si_fd: c_int,
};
const struct_unnamed_22 = extern struct {
    _call_addr: ?*anyopaque,
    _syscall: c_int,
    _arch: c_uint,
};
const union_unnamed_13 = extern union {
    _pad: [28]c_int,
    _kill: struct_unnamed_14,
    _timer: struct_unnamed_15,
    _rt: struct_unnamed_16,
    _sigchld: struct_unnamed_17,
    _sigfault: struct_unnamed_18,
    _sigpoll: struct_unnamed_21,
    _sigsys: struct_unnamed_22,
};
pub const siginfo_t = extern struct {
    si_signo: c_int,
    si_errno: c_int,
    si_code: c_int,
    __pad0: c_int,
    _sifields: union_unnamed_13,
};
pub const SI_ASYNCNL: c_int = -60;
pub const SI_DETHREAD: c_int = -7;
pub const SI_TKILL: c_int = -6;
pub const SI_SIGIO: c_int = -5;
pub const SI_ASYNCIO: c_int = -4;
pub const SI_MESGQ: c_int = -3;
pub const SI_TIMER: c_int = -2;
pub const SI_QUEUE: c_int = -1;
pub const SI_USER: c_int = 0;
pub const SI_KERNEL: c_int = 128;
const enum_unnamed_23 = c_int;
pub const ILL_ILLOPC: c_int = 1;
pub const ILL_ILLOPN: c_int = 2;
pub const ILL_ILLADR: c_int = 3;
pub const ILL_ILLTRP: c_int = 4;
pub const ILL_PRVOPC: c_int = 5;
pub const ILL_PRVREG: c_int = 6;
pub const ILL_COPROC: c_int = 7;
pub const ILL_BADSTK: c_int = 8;
pub const ILL_BADIADDR: c_int = 9;
const enum_unnamed_24 = c_uint;
pub const FPE_INTDIV: c_int = 1;
pub const FPE_INTOVF: c_int = 2;
pub const FPE_FLTDIV: c_int = 3;
pub const FPE_FLTOVF: c_int = 4;
pub const FPE_FLTUND: c_int = 5;
pub const FPE_FLTRES: c_int = 6;
pub const FPE_FLTINV: c_int = 7;
pub const FPE_FLTSUB: c_int = 8;
pub const FPE_FLTUNK: c_int = 14;
pub const FPE_CONDTRAP: c_int = 15;
const enum_unnamed_25 = c_uint;
pub const SEGV_MAPERR: c_int = 1;
pub const SEGV_ACCERR: c_int = 2;
pub const SEGV_BNDERR: c_int = 3;
pub const SEGV_PKUERR: c_int = 4;
pub const SEGV_ACCADI: c_int = 5;
pub const SEGV_ADIDERR: c_int = 6;
pub const SEGV_ADIPERR: c_int = 7;
pub const SEGV_MTEAERR: c_int = 8;
pub const SEGV_MTESERR: c_int = 9;
const enum_unnamed_26 = c_uint;
pub const BUS_ADRALN: c_int = 1;
pub const BUS_ADRERR: c_int = 2;
pub const BUS_OBJERR: c_int = 3;
pub const BUS_MCEERR_AR: c_int = 4;
pub const BUS_MCEERR_AO: c_int = 5;
const enum_unnamed_27 = c_uint;
pub const CLD_EXITED: c_int = 1;
pub const CLD_KILLED: c_int = 2;
pub const CLD_DUMPED: c_int = 3;
pub const CLD_TRAPPED: c_int = 4;
pub const CLD_STOPPED: c_int = 5;
pub const CLD_CONTINUED: c_int = 6;
const enum_unnamed_28 = c_uint;
pub const POLL_IN: c_int = 1;
pub const POLL_OUT: c_int = 2;
pub const POLL_MSG: c_int = 3;
pub const POLL_ERR: c_int = 4;
pub const POLL_PRI: c_int = 5;
pub const POLL_HUP: c_int = 6;
const enum_unnamed_29 = c_uint;
pub const sigval_t = __sigval_t;
const struct_unnamed_31 = extern struct {
    _function: ?*const fn (__sigval_t) callconv(.C) void,
    _attribute: [*c]pthread_attr_t,
};
const union_unnamed_30 = extern union {
    _pad: [12]c_int,
    _tid: __pid_t,
    _sigev_thread: struct_unnamed_31,
};
pub const struct_sigevent = extern struct {
    sigev_value: __sigval_t,
    sigev_signo: c_int,
    sigev_notify: c_int,
    _sigev_un: union_unnamed_30,
};
pub const sigevent_t = struct_sigevent;
pub const SIGEV_SIGNAL: c_int = 0;
pub const SIGEV_NONE: c_int = 1;
pub const SIGEV_THREAD: c_int = 2;
pub const SIGEV_THREAD_ID: c_int = 4;
const enum_unnamed_32 = c_uint;
pub const __sighandler_t = ?*const fn (c_int) callconv(.C) void;
pub extern fn __sysv_signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn kill(__pid: __pid_t, __sig: c_int) c_int;
pub extern fn killpg(__pgrp: __pid_t, __sig: c_int) c_int;
pub extern fn raise(__sig: c_int) c_int;
pub extern fn ssignal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn gsignal(__sig: c_int) c_int;
pub extern fn psignal(__sig: c_int, __s: [*c]const u8) void;
pub extern fn psiginfo(__pinfo: [*c]const siginfo_t, __s: [*c]const u8) void;
pub extern fn sigblock(__mask: c_int) c_int;
pub extern fn sigsetmask(__mask: c_int) c_int;
pub extern fn siggetmask() c_int;
pub const sig_t = __sighandler_t;
pub extern fn sigemptyset(__set: [*c]sigset_t) c_int;
pub extern fn sigfillset(__set: [*c]sigset_t) c_int;
pub extern fn sigaddset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigdelset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigismember(__set: [*c]const sigset_t, __signo: c_int) c_int;
const union_unnamed_33 = extern union {
    sa_handler: __sighandler_t,
    sa_sigaction: ?*const fn (c_int, [*c]siginfo_t, ?*anyopaque) callconv(.C) void,
};
pub const struct_sigaction = extern struct {
    __sigaction_handler: union_unnamed_33,
    sa_mask: __sigset_t,
    sa_flags: c_int,
    sa_restorer: ?*const fn () callconv(.C) void,
};
pub extern fn sigprocmask(__how: c_int, noalias __set: [*c]const sigset_t, noalias __oset: [*c]sigset_t) c_int;
pub extern fn sigsuspend(__set: [*c]const sigset_t) c_int;
pub extern fn sigaction(__sig: c_int, noalias __act: [*c]const struct_sigaction, noalias __oact: [*c]struct_sigaction) c_int;
pub extern fn sigpending(__set: [*c]sigset_t) c_int;
pub extern fn sigwait(noalias __set: [*c]const sigset_t, noalias __sig: [*c]c_int) c_int;
pub extern fn sigwaitinfo(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t) c_int;
pub extern fn sigtimedwait(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t, noalias __timeout: [*c]const struct_timespec) c_int;
pub extern fn sigqueue(__pid: __pid_t, __sig: c_int, __val: union_sigval) c_int;
pub const struct__fpx_sw_bytes = extern struct {
    magic1: __uint32_t,
    extended_size: __uint32_t,
    xstate_bv: __uint64_t,
    xstate_size: __uint32_t,
    __glibc_reserved1: [7]__uint32_t,
};
pub const struct__fpreg = extern struct {
    significand: [4]c_ushort,
    exponent: c_ushort,
};
pub const struct__fpxreg = extern struct {
    significand: [4]c_ushort,
    exponent: c_ushort,
    __glibc_reserved1: [3]c_ushort,
};
pub const struct__xmmreg = extern struct {
    element: [4]__uint32_t,
};
pub const struct__fpstate = extern struct {
    cwd: __uint16_t,
    swd: __uint16_t,
    ftw: __uint16_t,
    fop: __uint16_t,
    rip: __uint64_t,
    rdp: __uint64_t,
    mxcsr: __uint32_t,
    mxcr_mask: __uint32_t,
    _st: [8]struct__fpxreg,
    _xmm: [16]struct__xmmreg,
    __glibc_reserved1: [24]__uint32_t,
};
const union_unnamed_34 = extern union {
    fpstate: [*c]struct__fpstate,
    __fpstate_word: __uint64_t,
};
pub const struct_sigcontext = extern struct {
    r8: __uint64_t,
    r9: __uint64_t,
    r10: __uint64_t,
    r11: __uint64_t,
    r12: __uint64_t,
    r13: __uint64_t,
    r14: __uint64_t,
    r15: __uint64_t,
    rdi: __uint64_t,
    rsi: __uint64_t,
    rbp: __uint64_t,
    rbx: __uint64_t,
    rdx: __uint64_t,
    rax: __uint64_t,
    rcx: __uint64_t,
    rsp: __uint64_t,
    rip: __uint64_t,
    eflags: __uint64_t,
    cs: c_ushort,
    gs: c_ushort,
    fs: c_ushort,
    __pad0: c_ushort,
    err: __uint64_t,
    trapno: __uint64_t,
    oldmask: __uint64_t,
    cr2: __uint64_t,
    unnamed_0: union_unnamed_34,
    __reserved1: [8]__uint64_t,
};
pub const struct__xsave_hdr = extern struct {
    xstate_bv: __uint64_t,
    __glibc_reserved1: [2]__uint64_t,
    __glibc_reserved2: [5]__uint64_t,
};
pub const struct__ymmh_state = extern struct {
    ymmh_space: [64]__uint32_t,
};
pub const struct__xstate = extern struct {
    fpstate: struct__fpstate,
    xstate_hdr: struct__xsave_hdr,
    ymmh: struct__ymmh_state,
};
pub extern fn sigreturn(__scp: [*c]struct_sigcontext) c_int;
pub const stack_t = extern struct {
    ss_sp: ?*anyopaque,
    ss_flags: c_int,
    ss_size: usize,
};
pub const greg_t = c_longlong;
pub const gregset_t = [23]greg_t;
pub const struct__libc_fpxreg = extern struct {
    significand: [4]c_ushort,
    exponent: c_ushort,
    __glibc_reserved1: [3]c_ushort,
};
pub const struct__libc_xmmreg = extern struct {
    element: [4]__uint32_t,
};
pub const struct__libc_fpstate = extern struct {
    cwd: __uint16_t,
    swd: __uint16_t,
    ftw: __uint16_t,
    fop: __uint16_t,
    rip: __uint64_t,
    rdp: __uint64_t,
    mxcsr: __uint32_t,
    mxcr_mask: __uint32_t,
    _st: [8]struct__libc_fpxreg,
    _xmm: [16]struct__libc_xmmreg,
    __glibc_reserved1: [24]__uint32_t,
};
pub const fpregset_t = [*c]struct__libc_fpstate;
pub const mcontext_t = extern struct {
    gregs: gregset_t,
    fpregs: fpregset_t,
    __reserved1: [8]c_ulonglong,
};
pub const struct_ucontext_t = extern struct {
    uc_flags: c_ulong,
    uc_link: [*c]struct_ucontext_t,
    uc_stack: stack_t,
    uc_mcontext: mcontext_t,
    uc_sigmask: sigset_t,
    __fpregs_mem: struct__libc_fpstate,
    __ssp: [4]c_ulonglong,
};
pub const ucontext_t = struct_ucontext_t;
pub extern fn siginterrupt(__sig: c_int, __interrupt: c_int) c_int;
pub const SS_ONSTACK: c_int = 1;
pub const SS_DISABLE: c_int = 2;
const enum_unnamed_35 = c_uint;
pub extern fn sigaltstack(noalias __ss: [*c]const stack_t, noalias __oss: [*c]stack_t) c_int;
pub const struct_sigstack = extern struct {
    ss_sp: ?*anyopaque,
    ss_onstack: c_int,
};
pub extern fn sigstack(__ss: [*c]struct_sigstack, __oss: [*c]struct_sigstack) c_int;
pub extern fn pthread_sigmask(__how: c_int, noalias __newmask: [*c]const __sigset_t, noalias __oldmask: [*c]__sigset_t) c_int;
pub extern fn pthread_kill(__threadid: pthread_t, __signo: c_int) c_int;
pub extern fn __libc_current_sigrtmin() c_int;
pub extern fn __libc_current_sigrtmax() c_int;
pub const SharedInvalCatcacheMsg = extern struct {
    id: int8,
    dbId: Oid,
    hashValue: uint32,
};
pub const SharedInvalCatalogMsg = extern struct {
    id: int8,
    dbId: Oid,
    catId: Oid,
};
pub const SharedInvalRelcacheMsg = extern struct {
    id: int8,
    dbId: Oid,
    relId: Oid,
};
pub const SharedInvalSmgrMsg = extern struct {
    id: int8,
    backend_hi: int8,
    backend_lo: uint16,
    rlocator: RelFileLocator,
};
pub const SharedInvalRelmapMsg = extern struct {
    id: int8,
    dbId: Oid,
};
pub const SharedInvalSnapshotMsg = extern struct {
    id: int8,
    dbId: Oid,
    relId: Oid,
};
pub const SharedInvalidationMessage = extern union {
    id: int8,
    cc: SharedInvalCatcacheMsg,
    cat: SharedInvalCatalogMsg,
    rc: SharedInvalRelcacheMsg,
    sm: SharedInvalSmgrMsg,
    rm: SharedInvalRelmapMsg,
    sn: SharedInvalSnapshotMsg,
};
pub extern var SharedInvalidMessageCounter: uint64;
pub extern var catchupInterruptPending: sig_atomic_t;
pub extern fn SendSharedInvalidMessages(msgs: [*c]const SharedInvalidationMessage, n: c_int) void;
pub extern fn ReceiveSharedInvalidMessages(invalFunction: ?*const fn ([*c]SharedInvalidationMessage) callconv(.C) void, resetFunction: ?*const fn () callconv(.C) void) void;
pub extern fn HandleCatchupInterrupt() void;
pub extern fn ProcessCatchupInterrupt() void;
pub extern fn xactGetCommittedInvalidationMessages(msgs: [*c][*c]SharedInvalidationMessage, RelcacheInitFileInval: [*c]bool) c_int;
pub extern fn ProcessCommittedInvalidationMessages(msgs: [*c]SharedInvalidationMessage, nmsgs: c_int, RelcacheInitFileInval: bool, dbid: Oid, tsid: Oid) void;
pub extern fn LocalExecuteInvalidationMessage(msg: [*c]SharedInvalidationMessage) void;
pub const HashValueFunc = ?*const fn (?*const anyopaque, Size) callconv(.C) uint32;
pub const HashCompareFunc = ?*const fn (?*const anyopaque, ?*const anyopaque, Size) callconv(.C) c_int;
pub const HashCopyFunc = ?*const fn (?*anyopaque, ?*const anyopaque, Size) callconv(.C) ?*anyopaque;
pub const HashAllocFunc = ?*const fn (Size) callconv(.C) ?*anyopaque;
pub const struct_HASHELEMENT = extern struct {
    link: [*c]struct_HASHELEMENT,
    hashvalue: uint32,
};
pub const HASHELEMENT = struct_HASHELEMENT;
pub const struct_HASHHDR = opaque {};
pub const HASHHDR = struct_HASHHDR;
pub const struct_HTAB = opaque {};
pub const HTAB = struct_HTAB;
pub const struct_HASHCTL = extern struct {
    num_partitions: c_long,
    ssize: c_long,
    dsize: c_long,
    max_dsize: c_long,
    keysize: Size,
    entrysize: Size,
    hash: HashValueFunc,
    match: HashCompareFunc,
    keycopy: HashCopyFunc,
    alloc: HashAllocFunc,
    hcxt: MemoryContext,
    hctl: ?*HASHHDR,
};
pub const HASHCTL = struct_HASHCTL;
pub const HASH_FIND: c_int = 0;
pub const HASH_ENTER: c_int = 1;
pub const HASH_REMOVE: c_int = 2;
pub const HASH_ENTER_NULL: c_int = 3;
pub const HASHACTION = c_uint;
pub const HASH_SEQ_STATUS = extern struct {
    hashp: ?*HTAB,
    curBucket: uint32,
    curEntry: [*c]HASHELEMENT,
};
pub extern fn hash_create(tabname: [*c]const u8, nelem: c_long, info: [*c]const HASHCTL, flags: c_int) ?*HTAB;
pub extern fn hash_destroy(hashp: ?*HTAB) void;
pub extern fn hash_stats(where: [*c]const u8, hashp: ?*HTAB) void;
pub extern fn hash_search(hashp: ?*HTAB, keyPtr: ?*const anyopaque, action: HASHACTION, foundPtr: [*c]bool) ?*anyopaque;
pub extern fn get_hash_value(hashp: ?*HTAB, keyPtr: ?*const anyopaque) uint32;
pub extern fn hash_search_with_hash_value(hashp: ?*HTAB, keyPtr: ?*const anyopaque, hashvalue: uint32, action: HASHACTION, foundPtr: [*c]bool) ?*anyopaque;
pub extern fn hash_update_hash_key(hashp: ?*HTAB, existingEntry: ?*anyopaque, newKeyPtr: ?*const anyopaque) bool;
pub extern fn hash_get_num_entries(hashp: ?*HTAB) c_long;
pub extern fn hash_seq_init(status: [*c]HASH_SEQ_STATUS, hashp: ?*HTAB) void;
pub extern fn hash_seq_search(status: [*c]HASH_SEQ_STATUS) ?*anyopaque;
pub extern fn hash_seq_term(status: [*c]HASH_SEQ_STATUS) void;
pub extern fn hash_freeze(hashp: ?*HTAB) void;
pub extern fn hash_estimate_size(num_entries: c_long, entrysize: Size) Size;
pub extern fn hash_select_dirsize(num_entries: c_long) c_long;
pub extern fn hash_get_shared_size(info: [*c]HASHCTL, flags: c_int) Size;
pub extern fn AtEOXact_HashTables(isCommit: bool) void;
pub extern fn AtEOSubXact_HashTables(isCommit: bool, nestDepth: c_int) void;
pub const struct_pairingheap_node = extern struct {
    first_child: [*c]struct_pairingheap_node,
    next_sibling: [*c]struct_pairingheap_node,
    prev_or_parent: [*c]struct_pairingheap_node,
};
pub const pairingheap_node = struct_pairingheap_node;
pub const pairingheap_comparator = ?*const fn ([*c]const pairingheap_node, [*c]const pairingheap_node, ?*anyopaque) callconv(.C) c_int;
pub const struct_pairingheap = extern struct {
    ph_compare: pairingheap_comparator,
    ph_arg: ?*anyopaque,
    ph_root: [*c]pairingheap_node,
};
pub const pairingheap = struct_pairingheap;
pub extern fn pairingheap_allocate(compare: pairingheap_comparator, arg: ?*anyopaque) [*c]pairingheap;
pub extern fn pairingheap_free(heap: [*c]pairingheap) void;
pub extern fn pairingheap_add(heap: [*c]pairingheap, node: [*c]pairingheap_node) void;
pub extern fn pairingheap_first(heap: [*c]pairingheap) [*c]pairingheap_node;
pub extern fn pairingheap_remove_first(heap: [*c]pairingheap) [*c]pairingheap_node;
pub extern fn pairingheap_remove(heap: [*c]pairingheap, node: [*c]pairingheap_node) void;
pub const SNAPSHOT_MVCC: c_int = 0;
pub const SNAPSHOT_SELF: c_int = 1;
pub const SNAPSHOT_ANY: c_int = 2;
pub const SNAPSHOT_TOAST: c_int = 3;
pub const SNAPSHOT_DIRTY: c_int = 4;
pub const SNAPSHOT_HISTORIC_MVCC: c_int = 5;
pub const SNAPSHOT_NON_VACUUMABLE: c_int = 6;
pub const enum_SnapshotType = c_uint;
pub const SnapshotType = enum_SnapshotType;
pub const struct_GlobalVisState = opaque {};
pub const struct_SnapshotData = extern struct {
    snapshot_type: SnapshotType,
    xmin: TransactionId,
    xmax: TransactionId,
    xip: [*c]TransactionId,
    xcnt: uint32,
    subxip: [*c]TransactionId,
    subxcnt: int32,
    suboverflowed: bool,
    takenDuringRecovery: bool,
    copied: bool,
    curcid: CommandId,
    speculativeToken: uint32,
    vistest: ?*struct_GlobalVisState,
    active_count: uint32,
    regd_count: uint32,
    ph_node: pairingheap_node,
    whenTaken: TimestampTz,
    lsn: XLogRecPtr,
    snapXactCompletionCount: uint64,
};
pub const Snapshot = [*c]struct_SnapshotData;
pub const SnapshotData = struct_SnapshotData;
pub const fmAggrefPtr = [*c]struct_Aggref;
pub const fmExprContextCallbackFunction = ?*const fn (Datum) callconv(.C) void;
pub const fmStringInfo = [*c]struct_StringInfoData;
pub const FunctionCallInfoBaseData = struct_FunctionCallInfoBaseData;
pub extern fn fmgr_info(functionId: Oid, finfo: [*c]FmgrInfo) void;
pub extern fn fmgr_info_cxt(functionId: Oid, finfo: [*c]FmgrInfo, mcxt: MemoryContext) void;
pub extern fn fmgr_info_copy(dstinfo: [*c]FmgrInfo, srcinfo: [*c]FmgrInfo, destcxt: MemoryContext) void;
pub extern fn fmgr_symbol(functionId: Oid, mod: [*c][*c]u8, @"fn": [*c][*c]u8) void;
pub extern fn pg_detoast_datum(datum: [*c]struct_varlena) [*c]struct_varlena;
pub extern fn pg_detoast_datum_copy(datum: [*c]struct_varlena) [*c]struct_varlena;
pub extern fn pg_detoast_datum_slice(datum: [*c]struct_varlena, first: int32, count: int32) [*c]struct_varlena;
pub extern fn pg_detoast_datum_packed(datum: [*c]struct_varlena) [*c]struct_varlena;
pub const Pg_finfo_record = extern struct {
    api_version: c_int,
};
pub const PGFInfoFunction = ?*const fn () callconv(.C) [*c]const Pg_finfo_record;
pub export fn _PG_init() void {}
pub extern fn _PG_fini() void;
pub const Pg_magic_struct = extern struct {
    len: c_int,
    version: c_int,
    funcmaxargs: c_int,
    indexmaxkeys: c_int,
    namedatalen: c_int,
    float8byval: c_int,
    abi_extra: [32]u8,
}; // ../../src/include/c.h:914:2: warning: ignoring StaticAssert declaration
pub const PGModuleMagicFunction = ?*const fn () callconv(.C) [*c]const Pg_magic_struct;
pub extern fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid, arg1: Datum) Datum;
pub extern fn DirectFunctionCall2Coll(func: PGFunction, collation: Oid, arg1: Datum, arg2: Datum) Datum;
pub extern fn DirectFunctionCall3Coll(func: PGFunction, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum) Datum;
pub extern fn DirectFunctionCall4Coll(func: PGFunction, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum) Datum;
pub extern fn DirectFunctionCall5Coll(func: PGFunction, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum) Datum;
pub extern fn DirectFunctionCall6Coll(func: PGFunction, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum) Datum;
pub extern fn DirectFunctionCall7Coll(func: PGFunction, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum) Datum;
pub extern fn DirectFunctionCall8Coll(func: PGFunction, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum, arg8: Datum) Datum;
pub extern fn DirectFunctionCall9Coll(func: PGFunction, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum, arg8: Datum, arg9: Datum) Datum;
pub extern fn CallerFInfoFunctionCall1(func: PGFunction, flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum) Datum;
pub extern fn CallerFInfoFunctionCall2(func: PGFunction, flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum) Datum;
pub extern fn FunctionCall0Coll(flinfo: [*c]FmgrInfo, collation: Oid) Datum;
pub extern fn FunctionCall1Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum) Datum;
pub extern fn FunctionCall2Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum) Datum;
pub extern fn FunctionCall3Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum) Datum;
pub extern fn FunctionCall4Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum) Datum;
pub extern fn FunctionCall5Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum) Datum;
pub extern fn FunctionCall6Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum) Datum;
pub extern fn FunctionCall7Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum) Datum;
pub extern fn FunctionCall8Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum, arg8: Datum) Datum;
pub extern fn FunctionCall9Coll(flinfo: [*c]FmgrInfo, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum, arg8: Datum, arg9: Datum) Datum;
pub extern fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) Datum;
pub extern fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum) Datum;
pub extern fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum) Datum;
pub extern fn OidFunctionCall3Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum) Datum;
pub extern fn OidFunctionCall4Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum) Datum;
pub extern fn OidFunctionCall5Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum) Datum;
pub extern fn OidFunctionCall6Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum) Datum;
pub extern fn OidFunctionCall7Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum) Datum;
pub extern fn OidFunctionCall8Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum, arg8: Datum) Datum;
pub extern fn OidFunctionCall9Coll(functionId: Oid, collation: Oid, arg1: Datum, arg2: Datum, arg3: Datum, arg4: Datum, arg5: Datum, arg6: Datum, arg7: Datum, arg8: Datum, arg9: Datum) Datum;
pub extern fn InputFunctionCall(flinfo: [*c]FmgrInfo, str: [*c]u8, typioparam: Oid, typmod: int32) Datum;
pub extern fn InputFunctionCallSafe(flinfo: [*c]FmgrInfo, str: [*c]u8, typioparam: Oid, typmod: int32, escontext: fmNodePtr, result: [*c]Datum) bool;
pub extern fn DirectInputFunctionCallSafe(func: PGFunction, str: [*c]u8, typioparam: Oid, typmod: int32, escontext: fmNodePtr, result: [*c]Datum) bool;
pub extern fn OidInputFunctionCall(functionId: Oid, str: [*c]u8, typioparam: Oid, typmod: int32) Datum;
pub extern fn OutputFunctionCall(flinfo: [*c]FmgrInfo, val: Datum) [*c]u8;
pub extern fn OidOutputFunctionCall(functionId: Oid, val: Datum) [*c]u8;
pub extern fn ReceiveFunctionCall(flinfo: [*c]FmgrInfo, buf: fmStringInfo, typioparam: Oid, typmod: int32) Datum;
pub extern fn OidReceiveFunctionCall(functionId: Oid, buf: fmStringInfo, typioparam: Oid, typmod: int32) Datum;
pub extern fn SendFunctionCall(flinfo: [*c]FmgrInfo, val: Datum) [*c]bytea;
pub extern fn OidSendFunctionCall(functionId: Oid, val: Datum) [*c]bytea;
pub extern fn fetch_finfo_record(filehandle: ?*anyopaque, funcname: [*c]const u8) [*c]const Pg_finfo_record;
pub extern fn fmgr_internal_function(proname: [*c]const u8) Oid;
pub extern fn get_fn_expr_rettype(flinfo: [*c]FmgrInfo) Oid;
pub extern fn get_fn_expr_argtype(flinfo: [*c]FmgrInfo, argnum: c_int) Oid;
pub extern fn get_call_expr_argtype(expr: fmNodePtr, argnum: c_int) Oid;
pub extern fn get_fn_expr_arg_stable(flinfo: [*c]FmgrInfo, argnum: c_int) bool;
pub extern fn get_call_expr_arg_stable(expr: fmNodePtr, argnum: c_int) bool;
pub extern fn get_fn_expr_variadic(flinfo: [*c]FmgrInfo) bool;
pub extern fn get_fn_opclass_options(flinfo: [*c]FmgrInfo) [*c]bytea;
pub extern fn has_fn_opclass_options(flinfo: [*c]FmgrInfo) bool;
pub extern fn set_fn_opclass_options(flinfo: [*c]FmgrInfo, options: [*c]bytea) void;
pub extern fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid) bool;
pub extern var Dynamic_library_path: [*c]u8;
pub extern fn load_external_function(filename: [*c]const u8, funcname: [*c]const u8, signalNotFound: bool, filehandle: [*c]?*anyopaque) ?*anyopaque;
pub extern fn lookup_external_function(filehandle: ?*anyopaque, funcname: [*c]const u8) ?*anyopaque;
pub extern fn load_file(filename: [*c]const u8, restricted: bool) void;
pub extern fn find_rendezvous_variable(varName: [*c]const u8) [*c]?*anyopaque;
pub extern fn EstimateLibraryStateSpace() Size;
pub extern fn SerializeLibraryState(maxsize: Size, start_address: [*c]u8) void;
pub extern fn RestoreLibraryState(start_address: [*c]u8) void;
pub extern fn AggCheckCallContext(fcinfo: FunctionCallInfo, aggcontext: [*c]MemoryContext) c_int;
pub extern fn AggGetAggref(fcinfo: FunctionCallInfo) fmAggrefPtr;
pub extern fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) MemoryContext;
pub extern fn AggStateIsShared(fcinfo: FunctionCallInfo) bool;
pub extern fn AggRegisterCallback(fcinfo: FunctionCallInfo, func: fmExprContextCallbackFunction, arg: Datum) void;
pub const FHET_START: c_int = 0;
pub const FHET_END: c_int = 1;
pub const FHET_ABORT: c_int = 2;
pub const enum_FmgrHookEventType = c_uint;
pub const FmgrHookEventType = enum_FmgrHookEventType;
pub const needs_fmgr_hook_type = ?*const fn (Oid) callconv(.C) bool;
pub const fmgr_hook_type = ?*const fn (FmgrHookEventType, [*c]FmgrInfo, [*c]Datum) callconv(.C) void;
pub extern var needs_fmgr_hook: needs_fmgr_hook_type;
pub extern var fmgr_hook: fmgr_hook_type;
pub fn DatumGetTimestamp(arg_X: Datum) callconv(.C) Timestamp {
    var X = arg_X;
    return @bitCast(Timestamp, DatumGetInt64(X));
}
pub fn DatumGetTimestampTz(arg_X: Datum) callconv(.C) TimestampTz {
    var X = arg_X;
    return @bitCast(TimestampTz, DatumGetInt64(X));
}
pub fn DatumGetIntervalP(arg_X: Datum) callconv(.C) [*c]Interval {
    var X = arg_X;
    return @ptrCast([*c]Interval, @alignCast(@import("std").meta.alignment([*c]Interval), DatumGetPointer(X)));
}
pub fn TimestampGetDatum(arg_X: Timestamp) callconv(.C) Datum {
    var X = arg_X;
    return Int64GetDatum(X);
}
pub fn TimestampTzGetDatum(arg_X: TimestampTz) callconv(.C) Datum {
    var X = arg_X;
    return Int64GetDatum(X);
}
pub fn IntervalPGetDatum(arg_X: [*c]const Interval) callconv(.C) Datum {
    var X = arg_X;
    return PointerGetDatum(@ptrCast(?*const anyopaque, X));
}
pub extern var PgStartTime: TimestampTz;
pub extern var PgReloadTime: TimestampTz;
pub extern fn anytimestamp_typmod_check(istz: bool, typmod: int32) int32;
pub extern fn GetCurrentTimestamp() TimestampTz;
pub extern fn GetSQLCurrentTimestamp(typmod: int32) TimestampTz;
pub extern fn GetSQLLocalTimestamp(typmod: int32) Timestamp;
pub extern fn TimestampDifference(start_time: TimestampTz, stop_time: TimestampTz, secs: [*c]c_long, microsecs: [*c]c_int) void;
pub extern fn TimestampDifferenceMilliseconds(start_time: TimestampTz, stop_time: TimestampTz) c_long;
pub extern fn TimestampDifferenceExceeds(start_time: TimestampTz, stop_time: TimestampTz, msec: c_int) bool;
pub extern fn time_t_to_timestamptz(tm: pg_time_t) TimestampTz;
pub extern fn timestamptz_to_time_t(t: TimestampTz) pg_time_t;
pub extern fn timestamptz_to_str(t: TimestampTz) [*c]const u8;
pub extern fn tm2timestamp(tm: [*c]struct_pg_tm, fsec: fsec_t, tzp: [*c]c_int, result: [*c]Timestamp) c_int;
pub extern fn timestamp2tm(dt: Timestamp, tzp: [*c]c_int, tm: [*c]struct_pg_tm, fsec: [*c]fsec_t, tzn: [*c][*c]const u8, attimezone: ?*pg_tz) c_int;
pub extern fn dt2time(jd: Timestamp, hour: [*c]c_int, min: [*c]c_int, sec: [*c]c_int, fsec: [*c]fsec_t) void;
pub extern fn interval2itm(span: Interval, itm: [*c]struct_pg_itm) void;
pub extern fn itm2interval(itm: [*c]struct_pg_itm, span: [*c]Interval) c_int;
pub extern fn itmin2interval(itm_in: [*c]struct_pg_itm_in, span: [*c]Interval) c_int;
pub extern fn SetEpochTimestamp() Timestamp;
pub extern fn GetEpochTime(tm: [*c]struct_pg_tm) void;
pub extern fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp) c_int;
pub extern fn timestamp2timestamptz_opt_overflow(timestamp: Timestamp, overflow: [*c]c_int) TimestampTz;
pub extern fn timestamp_cmp_timestamptz_internal(timestampVal: Timestamp, dt2: TimestampTz) int32;
pub extern fn isoweek2j(year: c_int, week: c_int) c_int;
pub extern fn isoweek2date(woy: c_int, year: [*c]c_int, mon: [*c]c_int, mday: [*c]c_int) void;
pub extern fn isoweekdate2date(isoweek: c_int, wday: c_int, year: [*c]c_int, mon: [*c]c_int, mday: [*c]c_int) void;
pub extern fn date2isoweek(year: c_int, mon: c_int, mday: c_int) c_int;
pub extern fn date2isoyear(year: c_int, mon: c_int, mday: c_int) c_int;
pub extern fn date2isoyearday(year: c_int, mon: c_int, mday: c_int) c_int;
pub extern fn TimestampTimestampTzRequiresRewrite() bool;
pub extern var logical_decoding_work_mem: c_int;
pub extern var logical_replication_mode: c_int;
pub const LOGICAL_REP_MODE_BUFFERED: c_int = 0;
pub const LOGICAL_REP_MODE_IMMEDIATE: c_int = 1;
pub const LogicalRepMode = c_uint;
pub const struct_ReorderBufferTupleBuf = extern struct {
    node: slist_node,
    tuple: HeapTupleData,
    alloc_tuple_size: Size,
};
pub const ReorderBufferTupleBuf = struct_ReorderBufferTupleBuf;
pub const REORDER_BUFFER_CHANGE_INSERT: c_int = 0;
pub const REORDER_BUFFER_CHANGE_UPDATE: c_int = 1;
pub const REORDER_BUFFER_CHANGE_DELETE: c_int = 2;
pub const REORDER_BUFFER_CHANGE_MESSAGE: c_int = 3;
pub const REORDER_BUFFER_CHANGE_INVALIDATION: c_int = 4;
pub const REORDER_BUFFER_CHANGE_INTERNAL_SNAPSHOT: c_int = 5;
pub const REORDER_BUFFER_CHANGE_INTERNAL_COMMAND_ID: c_int = 6;
pub const REORDER_BUFFER_CHANGE_INTERNAL_TUPLECID: c_int = 7;
pub const REORDER_BUFFER_CHANGE_INTERNAL_SPEC_INSERT: c_int = 8;
pub const REORDER_BUFFER_CHANGE_INTERNAL_SPEC_CONFIRM: c_int = 9;
pub const REORDER_BUFFER_CHANGE_INTERNAL_SPEC_ABORT: c_int = 10;
pub const REORDER_BUFFER_CHANGE_TRUNCATE: c_int = 11;
pub const enum_ReorderBufferChangeType = c_uint;
pub const ReorderBufferChangeType = enum_ReorderBufferChangeType;
const union_unnamed_36 = extern union {
    commit_time: TimestampTz,
    prepare_time: TimestampTz,
    abort_time: TimestampTz,
};
pub const struct_ReorderBufferTXN = extern struct {
    txn_flags: bits32,
    xid: TransactionId,
    toplevel_xid: TransactionId,
    gid: [*c]u8,
    first_lsn: XLogRecPtr,
    final_lsn: XLogRecPtr,
    end_lsn: XLogRecPtr,
    toptxn: [*c]struct_ReorderBufferTXN,
    restart_decoding_lsn: XLogRecPtr,
    origin_id: RepOriginId,
    origin_lsn: XLogRecPtr,
    xact_time: union_unnamed_36,
    base_snapshot: Snapshot,
    base_snapshot_lsn: XLogRecPtr,
    base_snapshot_node: dlist_node,
    snapshot_now: Snapshot,
    command_id: CommandId,
    nentries: uint64,
    nentries_mem: uint64,
    changes: dlist_head,
    tuplecids: dlist_head,
    ntuplecids: uint64,
    tuplecid_hash: ?*HTAB,
    toast_hash: ?*HTAB,
    subtxns: dlist_head,
    nsubtxns: uint32,
    ninvalidations: uint32,
    invalidations: [*c]SharedInvalidationMessage,
    node: dlist_node,
    catchange_node: dlist_node,
    size: Size,
    total_size: Size,
    concurrent_abort: bool,
    output_plugin_private: ?*anyopaque,
};
const struct_unnamed_38 = extern struct {
    rlocator: RelFileLocator,
    clear_toast_afterwards: bool,
    oldtuple: [*c]ReorderBufferTupleBuf,
    newtuple: [*c]ReorderBufferTupleBuf,
};
const struct_unnamed_39 = extern struct {
    nrelids: Size,
    cascade: bool,
    restart_seqs: bool,
    relids: [*c]Oid,
};
const struct_unnamed_40 = extern struct {
    prefix: [*c]u8,
    message_size: Size,
    message: [*c]u8,
};
const struct_unnamed_41 = extern struct {
    locator: RelFileLocator,
    tid: ItemPointerData,
    cmin: CommandId,
    cmax: CommandId,
    combocid: CommandId,
};
const struct_unnamed_42 = extern struct {
    ninvalidations: uint32,
    invalidations: [*c]SharedInvalidationMessage,
};
const union_unnamed_37 = extern union {
    tp: struct_unnamed_38,
    truncate: struct_unnamed_39,
    msg: struct_unnamed_40,
    snapshot: Snapshot,
    command_id: CommandId,
    tuplecid: struct_unnamed_41,
    inval: struct_unnamed_42,
};
pub const struct_ReorderBufferChange = extern struct {
    lsn: XLogRecPtr,
    action: ReorderBufferChangeType,
    txn: [*c]struct_ReorderBufferTXN,
    origin_id: RepOriginId,
    data: union_unnamed_37,
    node: dlist_node,
};
pub const ReorderBufferChange = struct_ReorderBufferChange;
pub const ReorderBufferTXN = struct_ReorderBufferTXN;
pub const ReorderBuffer = struct_ReorderBuffer;
pub const ReorderBufferBeginCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN) callconv(.C) void;
pub const ReorderBufferApplyChangeCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, Relation, [*c]ReorderBufferChange) callconv(.C) void;
pub const ReorderBufferApplyTruncateCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, c_int, [*c]Relation, [*c]ReorderBufferChange) callconv(.C) void;
pub const ReorderBufferCommitCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const ReorderBufferMessageCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr, bool, [*c]const u8, Size, [*c]const u8) callconv(.C) void;
pub const ReorderBufferPrepareCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const ReorderBufferCommitPreparedCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const ReorderBufferRollbackPreparedCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr, TimestampTz) callconv(.C) void;
pub const ReorderBufferStreamStartCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const ReorderBufferStreamStopCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const ReorderBufferStreamAbortCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const ReorderBufferStreamPrepareCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const ReorderBufferStreamCommitCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const ReorderBufferStreamChangeCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, Relation, [*c]ReorderBufferChange) callconv(.C) void;
pub const ReorderBufferStreamMessageCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr, bool, [*c]const u8, Size, [*c]const u8) callconv(.C) void;
pub const ReorderBufferStreamTruncateCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, c_int, [*c]Relation, [*c]ReorderBufferChange) callconv(.C) void;
pub const ReorderBufferUpdateProgressTxnCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const struct_ReorderBuffer = extern struct {
    by_txn: ?*HTAB,
    toplevel_by_lsn: dlist_head,
    txns_by_base_snapshot_lsn: dlist_head,
    catchange_txns: dclist_head,
    by_txn_last_xid: TransactionId,
    by_txn_last_txn: [*c]ReorderBufferTXN,
    begin: ReorderBufferBeginCB,
    apply_change: ReorderBufferApplyChangeCB,
    apply_truncate: ReorderBufferApplyTruncateCB,
    commit: ReorderBufferCommitCB,
    message: ReorderBufferMessageCB,
    begin_prepare: ReorderBufferBeginCB,
    prepare: ReorderBufferPrepareCB,
    commit_prepared: ReorderBufferCommitPreparedCB,
    rollback_prepared: ReorderBufferRollbackPreparedCB,
    stream_start: ReorderBufferStreamStartCB,
    stream_stop: ReorderBufferStreamStopCB,
    stream_abort: ReorderBufferStreamAbortCB,
    stream_prepare: ReorderBufferStreamPrepareCB,
    stream_commit: ReorderBufferStreamCommitCB,
    stream_change: ReorderBufferStreamChangeCB,
    stream_message: ReorderBufferStreamMessageCB,
    stream_truncate: ReorderBufferStreamTruncateCB,
    update_progress_txn: ReorderBufferUpdateProgressTxnCB,
    private_data: ?*anyopaque,
    output_rewrites: bool,
    context: MemoryContext,
    change_context: MemoryContext,
    txn_context: MemoryContext,
    tup_context: MemoryContext,
    current_restart_decoding_lsn: XLogRecPtr,
    outbuf: [*c]u8,
    outbufsize: Size,
    size: Size,
    spillTxns: int64,
    spillCount: int64,
    spillBytes: int64,
    streamTxns: int64,
    streamCount: int64,
    streamBytes: int64,
    totalTxns: int64,
    totalBytes: int64,
};
pub const ReorderBufferBeginPrepareCB = ?*const fn ([*c]ReorderBuffer, [*c]ReorderBufferTXN) callconv(.C) void;
pub extern fn ReorderBufferAllocate() [*c]ReorderBuffer;
pub extern fn ReorderBufferFree(rb: [*c]ReorderBuffer) void;
pub extern fn ReorderBufferGetTupleBuf(rb: [*c]ReorderBuffer, tuple_len: Size) [*c]ReorderBufferTupleBuf;
pub extern fn ReorderBufferReturnTupleBuf(rb: [*c]ReorderBuffer, tuple: [*c]ReorderBufferTupleBuf) void;
pub extern fn ReorderBufferGetChange(rb: [*c]ReorderBuffer) [*c]ReorderBufferChange;
pub extern fn ReorderBufferReturnChange(rb: [*c]ReorderBuffer, change: [*c]ReorderBufferChange, upd_mem: bool) void;
pub extern fn ReorderBufferGetRelids(rb: [*c]ReorderBuffer, nrelids: c_int) [*c]Oid;
pub extern fn ReorderBufferReturnRelids(rb: [*c]ReorderBuffer, relids: [*c]Oid) void;
pub extern fn ReorderBufferQueueChange(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr, change: [*c]ReorderBufferChange, toast_insert: bool) void;
pub extern fn ReorderBufferQueueMessage(rb: [*c]ReorderBuffer, xid: TransactionId, snap: Snapshot, lsn: XLogRecPtr, transactional: bool, prefix: [*c]const u8, message_size: Size, message: [*c]const u8) void;
pub extern fn ReorderBufferCommit(rb: [*c]ReorderBuffer, xid: TransactionId, commit_lsn: XLogRecPtr, end_lsn: XLogRecPtr, commit_time: TimestampTz, origin_id: RepOriginId, origin_lsn: XLogRecPtr) void;
pub extern fn ReorderBufferFinishPrepared(rb: [*c]ReorderBuffer, xid: TransactionId, commit_lsn: XLogRecPtr, end_lsn: XLogRecPtr, two_phase_at: XLogRecPtr, commit_time: TimestampTz, origin_id: RepOriginId, origin_lsn: XLogRecPtr, gid: [*c]u8, is_commit: bool) void;
pub extern fn ReorderBufferAssignChild(rb: [*c]ReorderBuffer, xid: TransactionId, subxid: TransactionId, lsn: XLogRecPtr) void;
pub extern fn ReorderBufferCommitChild(rb: [*c]ReorderBuffer, xid: TransactionId, subxid: TransactionId, commit_lsn: XLogRecPtr, end_lsn: XLogRecPtr) void;
pub extern fn ReorderBufferAbort(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr, abort_time: TimestampTz) void;
pub extern fn ReorderBufferAbortOld(rb: [*c]ReorderBuffer, oldestRunningXid: TransactionId) void;
pub extern fn ReorderBufferForget(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr) void;
pub extern fn ReorderBufferInvalidate(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr) void;
pub extern fn ReorderBufferSetBaseSnapshot(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr, snap: Snapshot) void;
pub extern fn ReorderBufferAddSnapshot(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr, snap: Snapshot) void;
pub extern fn ReorderBufferAddNewCommandId(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr, cid: CommandId) void;
pub extern fn ReorderBufferAddNewTupleCids(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr, locator: RelFileLocator, tid: ItemPointerData, cmin: CommandId, cmax: CommandId, combocid: CommandId) void;
pub extern fn ReorderBufferAddInvalidations(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr, nmsgs: Size, msgs: [*c]SharedInvalidationMessage) void;
pub extern fn ReorderBufferImmediateInvalidation(rb: [*c]ReorderBuffer, ninvalidations: uint32, invalidations: [*c]SharedInvalidationMessage) void;
pub extern fn ReorderBufferProcessXid(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr) void;
pub extern fn ReorderBufferXidSetCatalogChanges(rb: [*c]ReorderBuffer, xid: TransactionId, lsn: XLogRecPtr) void;
pub extern fn ReorderBufferXidHasCatalogChanges(rb: [*c]ReorderBuffer, xid: TransactionId) bool;
pub extern fn ReorderBufferXidHasBaseSnapshot(rb: [*c]ReorderBuffer, xid: TransactionId) bool;
pub extern fn ReorderBufferRememberPrepareInfo(rb: [*c]ReorderBuffer, xid: TransactionId, prepare_lsn: XLogRecPtr, end_lsn: XLogRecPtr, prepare_time: TimestampTz, origin_id: RepOriginId, origin_lsn: XLogRecPtr) bool;
pub extern fn ReorderBufferSkipPrepare(rb: [*c]ReorderBuffer, xid: TransactionId) void;
pub extern fn ReorderBufferPrepare(rb: [*c]ReorderBuffer, xid: TransactionId, gid: [*c]u8) void;
pub extern fn ReorderBufferGetOldestTXN(rb: [*c]ReorderBuffer) [*c]ReorderBufferTXN;
pub extern fn ReorderBufferGetOldestXmin(rb: [*c]ReorderBuffer) TransactionId;
pub extern fn ReorderBufferGetCatalogChangesXacts(rb: [*c]ReorderBuffer) [*c]TransactionId;
pub extern fn ReorderBufferSetRestartPoint(rb: [*c]ReorderBuffer, ptr: XLogRecPtr) void;
pub extern fn StartupReorderBuffer() void;
pub const slock_t = u8;
pub const RS_PERSISTENT: c_int = 0;
pub const RS_EPHEMERAL: c_int = 1;
pub const RS_TEMPORARY: c_int = 2;
pub const enum_ReplicationSlotPersistency = c_uint;
pub const ReplicationSlotPersistency = enum_ReplicationSlotPersistency;
pub const RS_INVAL_NONE: c_int = 0;
pub const RS_INVAL_WAL_REMOVED: c_int = 1;
pub const RS_INVAL_HORIZON: c_int = 2;
pub const RS_INVAL_WAL_LEVEL: c_int = 3;
pub const enum_ReplicationSlotInvalidationCause = c_uint;
pub const ReplicationSlotInvalidationCause = enum_ReplicationSlotInvalidationCause;
pub const struct_ReplicationSlotPersistentData = extern struct {
    name: NameData,
    database: Oid,
    persistency: ReplicationSlotPersistency,
    xmin: TransactionId,
    catalog_xmin: TransactionId,
    restart_lsn: XLogRecPtr,
    invalidated: ReplicationSlotInvalidationCause,
    confirmed_flush: XLogRecPtr,
    two_phase_at: XLogRecPtr,
    two_phase: bool,
    plugin: NameData,
};
pub const ReplicationSlotPersistentData = struct_ReplicationSlotPersistentData;
pub const struct_pg_atomic_uint32 = extern struct {
    value: uint32,
};
pub const pg_atomic_uint32 = struct_pg_atomic_uint32;
pub const struct_proclist_head = extern struct {
    head: c_int,
    tail: c_int,
};
pub const proclist_head = struct_proclist_head;
pub const struct_LWLock = extern struct {
    tranche: uint16,
    state: pg_atomic_uint32,
    waiters: proclist_head,
};
pub const LWLock = struct_LWLock;
pub const struct_ReplicationSlot = extern struct {
    mutex: slock_t,
    in_use: bool,
    active_pid: pid_t,
    just_dirtied: bool,
    dirty: bool,
    effective_xmin: TransactionId,
    effective_catalog_xmin: TransactionId,
    data: ReplicationSlotPersistentData,
    io_in_progress_lock: LWLock,
    active_cv: ConditionVariable,
    candidate_catalog_xmin: TransactionId,
    candidate_xmin_lsn: XLogRecPtr,
    candidate_restart_valid: XLogRecPtr,
    candidate_restart_lsn: XLogRecPtr,
};
pub const ReplicationSlot = struct_ReplicationSlot;
pub const struct_SnapBuild = opaque {};
pub const OUTPUT_PLUGIN_BINARY_OUTPUT: c_int = 0;
pub const OUTPUT_PLUGIN_TEXTUAL_OUTPUT: c_int = 1;
pub const enum_OutputPluginOutputType = c_uint;
pub const OutputPluginOutputType = enum_OutputPluginOutputType;
pub const struct_OutputPluginOptions = extern struct {
    output_type: OutputPluginOutputType,
    receive_rewrites: bool,
};
pub const OutputPluginOptions = struct_OutputPluginOptions;
pub const LogicalDecodeStartupCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]OutputPluginOptions, bool) callconv(.C) void;
pub const LogicalDecodeBeginCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN) callconv(.C) void;
pub const LogicalDecodeChangeCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, Relation, [*c]ReorderBufferChange) callconv(.C) void;
pub const LogicalDecodeTruncateCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, c_int, [*c]Relation, [*c]ReorderBufferChange) callconv(.C) void;
pub const LogicalDecodeCommitCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const LogicalDecodeMessageCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr, bool, [*c]const u8, Size, [*c]const u8) callconv(.C) void;
pub const LogicalDecodeFilterByOriginCB = ?*const fn ([*c]struct_LogicalDecodingContext, RepOriginId) callconv(.C) bool;
pub const LogicalDecodeShutdownCB = ?*const fn ([*c]struct_LogicalDecodingContext) callconv(.C) void;
pub const LogicalDecodeFilterPrepareCB = ?*const fn ([*c]struct_LogicalDecodingContext, TransactionId, [*c]const u8) callconv(.C) bool;
pub const LogicalDecodeBeginPrepareCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN) callconv(.C) void;
pub const LogicalDecodePrepareCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const LogicalDecodeCommitPreparedCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const LogicalDecodeRollbackPreparedCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr, TimestampTz) callconv(.C) void;
pub const LogicalDecodeStreamStartCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN) callconv(.C) void;
pub const LogicalDecodeStreamStopCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN) callconv(.C) void;
pub const LogicalDecodeStreamAbortCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const LogicalDecodeStreamPrepareCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const LogicalDecodeStreamCommitCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr) callconv(.C) void;
pub const LogicalDecodeStreamChangeCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, Relation, [*c]ReorderBufferChange) callconv(.C) void;
pub const LogicalDecodeStreamMessageCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, XLogRecPtr, bool, [*c]const u8, Size, [*c]const u8) callconv(.C) void;
pub const LogicalDecodeStreamTruncateCB = ?*const fn ([*c]struct_LogicalDecodingContext, [*c]ReorderBufferTXN, c_int, [*c]Relation, [*c]ReorderBufferChange) callconv(.C) void;
pub const struct_OutputPluginCallbacks = extern struct {
    startup_cb: LogicalDecodeStartupCB,
    begin_cb: LogicalDecodeBeginCB,
    change_cb: LogicalDecodeChangeCB,
    truncate_cb: LogicalDecodeTruncateCB,
    commit_cb: LogicalDecodeCommitCB,
    message_cb: LogicalDecodeMessageCB,
    filter_by_origin_cb: LogicalDecodeFilterByOriginCB,
    shutdown_cb: LogicalDecodeShutdownCB,
    filter_prepare_cb: LogicalDecodeFilterPrepareCB,
    begin_prepare_cb: LogicalDecodeBeginPrepareCB,
    prepare_cb: LogicalDecodePrepareCB,
    commit_prepared_cb: LogicalDecodeCommitPreparedCB,
    rollback_prepared_cb: LogicalDecodeRollbackPreparedCB,
    stream_start_cb: LogicalDecodeStreamStartCB,
    stream_stop_cb: LogicalDecodeStreamStopCB,
    stream_abort_cb: LogicalDecodeStreamAbortCB,
    stream_prepare_cb: LogicalDecodeStreamPrepareCB,
    stream_commit_cb: LogicalDecodeStreamCommitCB,
    stream_change_cb: LogicalDecodeStreamChangeCB,
    stream_message_cb: LogicalDecodeStreamMessageCB,
    stream_truncate_cb: LogicalDecodeStreamTruncateCB,
};
pub const OutputPluginCallbacks = struct_OutputPluginCallbacks;
pub const LogicalOutputPluginWriterWrite = ?*const fn ([*c]struct_LogicalDecodingContext, XLogRecPtr, TransactionId, bool) callconv(.C) void;
pub const LogicalOutputPluginWriterPrepareWrite = LogicalOutputPluginWriterWrite;
pub const LogicalOutputPluginWriterUpdateProgress = ?*const fn ([*c]struct_LogicalDecodingContext, XLogRecPtr, TransactionId, bool) callconv(.C) void;
pub const struct_LogicalDecodingContext = extern struct {
    context: MemoryContext,
    slot: [*c]ReplicationSlot,
    reader: [*c]XLogReaderState,
    reorder: [*c]struct_ReorderBuffer,
    snapshot_builder: ?*struct_SnapBuild,
    fast_forward: bool,
    callbacks: OutputPluginCallbacks,
    options: OutputPluginOptions,
    output_plugin_options: [*c]List,
    prepare_write: LogicalOutputPluginWriterPrepareWrite,
    write: LogicalOutputPluginWriterWrite,
    update_progress: LogicalOutputPluginWriterUpdateProgress,
    out: StringInfo,
    output_plugin_private: ?*anyopaque,
    output_writer_private: ?*anyopaque,
    streaming: bool,
    twophase: bool,
    twophase_opt_given: bool,
    accept_writes: bool,
    prepared_write: bool,
    write_location: XLogRecPtr,
    write_xid: TransactionId,
    end_xact: bool,
};
pub const LogicalOutputPluginInit = ?*const fn ([*c]struct_OutputPluginCallbacks) callconv(.C) void;
pub export fn _PG_output_plugin_init(arg_cb: [*c]struct_OutputPluginCallbacks) void {
    var cb = arg_cb;
    cb.*.startup_cb = &pg_decode_startup;
    cb.*.begin_cb = &pg_decode_begin_txn;
    cb.*.change_cb = &pg_decode_change;
    cb.*.truncate_cb = &pg_decode_truncate;
    cb.*.commit_cb = &pg_decode_commit_txn;
    cb.*.filter_by_origin_cb = &pg_decode_filter;
    cb.*.shutdown_cb = &pg_decode_shutdown;
    cb.*.message_cb = &pg_decode_message;
    cb.*.filter_prepare_cb = &pg_decode_filter_prepare;
    cb.*.begin_prepare_cb = &pg_decode_begin_prepare_txn;
    cb.*.prepare_cb = &pg_decode_prepare_txn;
    cb.*.commit_prepared_cb = &pg_decode_commit_prepared_txn;
    cb.*.rollback_prepared_cb = &pg_decode_rollback_prepared_txn;
    cb.*.stream_start_cb = &pg_decode_stream_start;
    cb.*.stream_stop_cb = &pg_decode_stream_stop;
    cb.*.stream_abort_cb = &pg_decode_stream_abort;
    cb.*.stream_prepare_cb = &pg_decode_stream_prepare;
    cb.*.stream_commit_cb = &pg_decode_stream_commit;
    cb.*.stream_change_cb = &pg_decode_stream_change;
    cb.*.stream_message_cb = &pg_decode_stream_message;
    cb.*.stream_truncate_cb = &pg_decode_stream_truncate;
}
pub extern fn OutputPluginPrepareWrite(ctx: [*c]struct_LogicalDecodingContext, last_write: bool) void;
pub extern fn OutputPluginWrite(ctx: [*c]struct_LogicalDecodingContext, last_write: bool) void;
pub extern fn OutputPluginUpdateProgress(ctx: [*c]struct_LogicalDecodingContext, skipped_xact: bool) void;
pub const struct_proclist_node = extern struct {
    next: c_int,
    prev: c_int,
};
pub const proclist_node = struct_proclist_node;
pub const struct_proclist_mutable_iter = extern struct {
    cur: c_int,
    next: c_int,
};
pub const proclist_mutable_iter = struct_proclist_mutable_iter; // ../../src/include/storage/s_lock.h:228:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/storage/s_lock.h:224:1: warning: unable to translate function, demoted to extern
pub extern fn tas(arg_lock: [*c]volatile slock_t) callconv(.C) c_int; // ../../src/include/storage/s_lock.h:246:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/storage/s_lock.h:240:1: warning: unable to translate function, demoted to extern
pub extern fn spin_delay() callconv(.C) void;
pub extern var dummy_spinlock: slock_t;
pub extern fn s_lock(lock: [*c]volatile slock_t, file: [*c]const u8, line: c_int, func: [*c]const u8) c_int;
pub extern fn set_spins_per_delay(shared_spins_per_delay: c_int) void;
pub extern fn update_spins_per_delay(shared_spins_per_delay: c_int) c_int;
pub const SpinDelayStatus = extern struct {
    spins: c_int,
    delays: c_int,
    cur_delay: c_int,
    file: [*c]const u8,
    line: c_int,
    func: [*c]const u8,
};
pub fn init_spin_delay(arg_status: [*c]SpinDelayStatus, arg_file: [*c]const u8, arg_line: c_int, arg_func: [*c]const u8) callconv(.C) void {
    var status = arg_status;
    var file = arg_file;
    var line = arg_line;
    var func = arg_func;
    status.*.spins = 0;
    status.*.delays = 0;
    status.*.cur_delay = 0;
    status.*.file = file;
    status.*.line = line;
    status.*.func = func;
}
pub extern fn perform_spin_delay(status: [*c]SpinDelayStatus) void;
pub extern fn finish_spin_delay(status: [*c]SpinDelayStatus) void;
pub extern fn SpinlockSemas() c_int;
pub extern fn SpinlockSemaSize() Size;
pub const ConditionVariable = extern struct {
    mutex: slock_t,
    wakeup: proclist_head,
};
pub const union_ConditionVariableMinimallyPadded = extern union {
    cv: ConditionVariable,
    pad: [16]u8,
};
pub const ConditionVariableMinimallyPadded = union_ConditionVariableMinimallyPadded;
pub extern fn ConditionVariableInit(cv: [*c]ConditionVariable) void;
pub extern fn ConditionVariableSleep(cv: [*c]ConditionVariable, wait_event_info: uint32) void;
pub extern fn ConditionVariableTimedSleep(cv: [*c]ConditionVariable, timeout: c_long, wait_event_info: uint32) bool;
pub extern fn ConditionVariableCancelSleep() void;
pub extern fn ConditionVariablePrepareToSleep(cv: [*c]ConditionVariable) void;
pub extern fn ConditionVariableSignal(cv: [*c]ConditionVariable) void;
pub extern fn ConditionVariableBroadcast(cv: [*c]ConditionVariable) void;
pub const struct_pg_atomic_flag = extern struct {
    value: u8,
};
pub const pg_atomic_flag = struct_pg_atomic_flag;
pub const struct_pg_atomic_uint64 = extern struct {
    value: uint64,
};
pub const pg_atomic_uint64 = struct_pg_atomic_uint64; // ../../src/include/port/atomics/arch-x86.h:114:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/port/atomics/arch-x86.h:112:1: warning: unable to translate function, demoted to extern
pub extern fn pg_spin_delay_impl() callconv(.C) void; // ../../src/include/port/atomics/arch-x86.h:145:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/port/atomics/arch-x86.h:141:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_test_set_flag_impl(arg_ptr: [*c]volatile pg_atomic_flag) callconv(.C) bool; // ../../src/include/port/atomics/arch-x86.h:162:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/port/atomics/arch-x86.h:156:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_clear_flag_impl(arg_ptr: [*c]volatile pg_atomic_flag) callconv(.C) void; // ../../src/include/port/atomics/arch-x86.h:177:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/port/atomics/arch-x86.h:168:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_compare_exchange_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_expected: [*c]uint32, arg_newval: uint32) callconv(.C) bool; // ../../src/include/port/atomics/arch-x86.h:192:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/port/atomics/arch-x86.h:189:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_fetch_add_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_add_: int32) callconv(.C) uint32; // ../../src/include/port/atomics/arch-x86.h:214:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/port/atomics/arch-x86.h:205:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_compare_exchange_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_expected: [*c]uint64, arg_newval: uint64) callconv(.C) bool; // ../../src/include/port/atomics/arch-x86.h:229:2: warning: TODO implement translation of stmt class GCCAsmStmtClass
// ../../src/include/port/atomics/arch-x86.h:226:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_fetch_add_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_add_: int64) callconv(.C) uint64;
pub fn pg_atomic_unlocked_test_flag_impl(arg_ptr: [*c]volatile pg_atomic_flag) callconv(.C) bool {
    var ptr = arg_ptr;
    return @bitCast(c_int, @as(c_uint, ptr.*.value)) == @as(c_int, 0);
}
pub fn pg_atomic_init_flag_impl(arg_ptr: [*c]volatile pg_atomic_flag) callconv(.C) void {
    var ptr = arg_ptr;
    pg_atomic_clear_flag_impl(ptr);
} // ../../src/include/port/atomics/generic-gcc.h:195:9: warning: TODO implement function '__sync_fetch_and_sub_4' in std.zig.c_builtins
// ../../src/include/port/atomics/generic-gcc.h:193:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_fetch_sub_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_sub_: int32) callconv(.C) uint32; // ../../src/include/port/atomics/generic-gcc.h:204:9: warning: TODO implement function '__sync_fetch_and_and_4' in std.zig.c_builtins
// ../../src/include/port/atomics/generic-gcc.h:202:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_fetch_and_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_and_: uint32) callconv(.C) uint32; // ../../src/include/port/atomics/generic-gcc.h:213:9: warning: TODO implement function '__sync_fetch_and_or_4' in std.zig.c_builtins
// ../../src/include/port/atomics/generic-gcc.h:211:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_fetch_or_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_or_: uint32) callconv(.C) uint32; // ../../src/include/port/atomics/generic-gcc.h:262:9: warning: TODO implement function '__sync_fetch_and_sub_8' in std.zig.c_builtins
// ../../src/include/port/atomics/generic-gcc.h:260:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_fetch_sub_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_sub_: int64) callconv(.C) uint64; // ../../src/include/port/atomics/generic-gcc.h:271:9: warning: TODO implement function '__sync_fetch_and_and_8' in std.zig.c_builtins
// ../../src/include/port/atomics/generic-gcc.h:269:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_fetch_and_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_and_: uint64) callconv(.C) uint64; // ../../src/include/port/atomics/generic-gcc.h:280:9: warning: TODO implement function '__sync_fetch_and_or_8' in std.zig.c_builtins
// ../../src/include/port/atomics/generic-gcc.h:278:1: warning: unable to translate function, demoted to extern
pub extern fn pg_atomic_fetch_or_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_or_: uint64) callconv(.C) uint64;
pub fn pg_atomic_read_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    return ptr.*.value;
}
pub fn pg_atomic_write_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_val: uint32) callconv(.C) void {
    var ptr = arg_ptr;
    var val = arg_val;
    ptr.*.value = val;
}
pub fn pg_atomic_unlocked_write_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_val: uint32) callconv(.C) void {
    var ptr = arg_ptr;
    var val = arg_val;
    ptr.*.value = val;
}
pub fn pg_atomic_init_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_val_: uint32) callconv(.C) void {
    var ptr = arg_ptr;
    var val_ = arg_val_;
    ptr.*.value = val_;
}
pub fn pg_atomic_exchange_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_xchg_: uint32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var xchg_ = arg_xchg_;
    var old: uint32 = undefined;
    old = ptr.*.value;
    while (!pg_atomic_compare_exchange_u32_impl(ptr, &old, xchg_)) {}
    return old;
}
pub fn pg_atomic_add_fetch_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_add_: int32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var add_ = arg_add_;
    return pg_atomic_fetch_add_u32_impl(ptr, add_) +% @bitCast(c_uint, add_);
}
pub fn pg_atomic_sub_fetch_u32_impl(arg_ptr: [*c]volatile pg_atomic_uint32, arg_sub_: int32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var sub_ = arg_sub_;
    return pg_atomic_fetch_sub_u32_impl(ptr, sub_) -% @bitCast(c_uint, sub_);
}
pub fn pg_atomic_exchange_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_xchg_: uint64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var xchg_ = arg_xchg_;
    var old: uint64 = undefined;
    old = ptr.*.value;
    while (!pg_atomic_compare_exchange_u64_impl(ptr, &old, xchg_)) {}
    return old;
}
pub fn pg_atomic_write_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_val: uint64) callconv(.C) void {
    var ptr = arg_ptr;
    var val = arg_val;
    _ = @as(c_int, 1);
    ptr.*.value = val;
}
pub fn pg_atomic_read_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    _ = @as(c_int, 1);
    return ptr.*.value;
}
pub fn pg_atomic_init_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_val_: uint64) callconv(.C) void {
    var ptr = arg_ptr;
    var val_ = arg_val_;
    ptr.*.value = val_;
}
pub fn pg_atomic_add_fetch_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_add_: int64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var add_ = arg_add_;
    return pg_atomic_fetch_add_u64_impl(ptr, add_) +% @bitCast(c_ulong, add_);
}
pub fn pg_atomic_sub_fetch_u64_impl(arg_ptr: [*c]volatile pg_atomic_uint64, arg_sub_: int64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var sub_ = arg_sub_;
    return pg_atomic_fetch_sub_u64_impl(ptr, sub_) -% @bitCast(c_ulong, sub_);
}
pub fn pg_atomic_init_flag(arg_ptr: [*c]volatile pg_atomic_flag) callconv(.C) void {
    var ptr = arg_ptr;
    pg_atomic_init_flag_impl(ptr);
}
pub fn pg_atomic_test_set_flag(arg_ptr: [*c]volatile pg_atomic_flag) callconv(.C) bool {
    var ptr = arg_ptr;
    return pg_atomic_test_set_flag_impl(ptr);
}
pub fn pg_atomic_unlocked_test_flag(arg_ptr: [*c]volatile pg_atomic_flag) callconv(.C) bool {
    var ptr = arg_ptr;
    return pg_atomic_unlocked_test_flag_impl(ptr);
}
pub fn pg_atomic_clear_flag(arg_ptr: [*c]volatile pg_atomic_flag) callconv(.C) void {
    var ptr = arg_ptr;
    pg_atomic_clear_flag_impl(ptr);
}
pub fn pg_atomic_init_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_val: uint32) callconv(.C) void {
    var ptr = arg_ptr;
    var val = arg_val;
    _ = @as(c_int, 1);
    pg_atomic_init_u32_impl(ptr, val);
}
pub fn pg_atomic_read_u32(arg_ptr: [*c]volatile pg_atomic_uint32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    _ = @as(c_int, 1);
    return pg_atomic_read_u32_impl(ptr);
}
pub fn pg_atomic_write_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_val: uint32) callconv(.C) void {
    var ptr = arg_ptr;
    var val = arg_val;
    _ = @as(c_int, 1);
    pg_atomic_write_u32_impl(ptr, val);
}
pub fn pg_atomic_unlocked_write_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_val: uint32) callconv(.C) void {
    var ptr = arg_ptr;
    var val = arg_val;
    _ = @as(c_int, 1);
    pg_atomic_unlocked_write_u32_impl(ptr, val);
}
pub fn pg_atomic_exchange_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_newval: uint32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var newval = arg_newval;
    _ = @as(c_int, 1);
    return pg_atomic_exchange_u32_impl(ptr, newval);
}
pub fn pg_atomic_compare_exchange_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_expected: [*c]uint32, arg_newval: uint32) callconv(.C) bool {
    var ptr = arg_ptr;
    var expected = arg_expected;
    var newval = arg_newval;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    return pg_atomic_compare_exchange_u32_impl(ptr, expected, newval);
}
pub fn pg_atomic_fetch_add_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_add_: int32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var add_ = arg_add_;
    _ = @as(c_int, 1);
    return pg_atomic_fetch_add_u32_impl(ptr, add_);
}
pub fn pg_atomic_fetch_sub_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_sub_: int32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var sub_ = arg_sub_;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    return pg_atomic_fetch_sub_u32_impl(ptr, sub_);
}
pub fn pg_atomic_fetch_and_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_and_: uint32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var and_ = arg_and_;
    _ = @as(c_int, 1);
    return pg_atomic_fetch_and_u32_impl(ptr, and_);
}
pub fn pg_atomic_fetch_or_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_or_: uint32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var or_ = arg_or_;
    _ = @as(c_int, 1);
    return pg_atomic_fetch_or_u32_impl(ptr, or_);
}
pub fn pg_atomic_add_fetch_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_add_: int32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var add_ = arg_add_;
    _ = @as(c_int, 1);
    return pg_atomic_add_fetch_u32_impl(ptr, add_);
}
pub fn pg_atomic_sub_fetch_u32(arg_ptr: [*c]volatile pg_atomic_uint32, arg_sub_: int32) callconv(.C) uint32 {
    var ptr = arg_ptr;
    var sub_ = arg_sub_;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    return pg_atomic_sub_fetch_u32_impl(ptr, sub_);
}
pub fn pg_atomic_init_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_val: uint64) callconv(.C) void {
    var ptr = arg_ptr;
    var val = arg_val;
    _ = @as(c_int, 1);
    pg_atomic_init_u64_impl(ptr, val);
}
pub fn pg_atomic_read_u64(arg_ptr: [*c]volatile pg_atomic_uint64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    _ = @as(c_int, 1);
    return pg_atomic_read_u64_impl(ptr);
}
pub fn pg_atomic_write_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_val: uint64) callconv(.C) void {
    var ptr = arg_ptr;
    var val = arg_val;
    _ = @as(c_int, 1);
    pg_atomic_write_u64_impl(ptr, val);
}
pub fn pg_atomic_exchange_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_newval: uint64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var newval = arg_newval;
    _ = @as(c_int, 1);
    return pg_atomic_exchange_u64_impl(ptr, newval);
}
pub fn pg_atomic_compare_exchange_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_expected: [*c]uint64, arg_newval: uint64) callconv(.C) bool {
    var ptr = arg_ptr;
    var expected = arg_expected;
    var newval = arg_newval;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    return pg_atomic_compare_exchange_u64_impl(ptr, expected, newval);
}
pub fn pg_atomic_fetch_add_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_add_: int64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var add_ = arg_add_;
    _ = @as(c_int, 1);
    return pg_atomic_fetch_add_u64_impl(ptr, add_);
}
pub fn pg_atomic_fetch_sub_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_sub_: int64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var sub_ = arg_sub_;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    return pg_atomic_fetch_sub_u64_impl(ptr, sub_);
}
pub fn pg_atomic_fetch_and_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_and_: uint64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var and_ = arg_and_;
    _ = @as(c_int, 1);
    return pg_atomic_fetch_and_u64_impl(ptr, and_);
}
pub fn pg_atomic_fetch_or_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_or_: uint64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var or_ = arg_or_;
    _ = @as(c_int, 1);
    return pg_atomic_fetch_or_u64_impl(ptr, or_);
}
pub fn pg_atomic_add_fetch_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_add_: int64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var add_ = arg_add_;
    _ = @as(c_int, 1);
    return pg_atomic_add_fetch_u64_impl(ptr, add_);
}
pub fn pg_atomic_sub_fetch_u64(arg_ptr: [*c]volatile pg_atomic_uint64, arg_sub_: int64) callconv(.C) uint64 {
    var ptr = arg_ptr;
    var sub_ = arg_sub_;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    return pg_atomic_sub_fetch_u64_impl(ptr, sub_);
}
pub const struct_PGPROC = opaque {};
pub const LW_WS_NOT_WAITING: c_int = 0;
pub const LW_WS_WAITING: c_int = 1;
pub const LW_WS_PENDING_WAKEUP: c_int = 2;
pub const enum_LWLockWaitState = c_uint;
pub const LWLockWaitState = enum_LWLockWaitState; // ../../src/include/c.h:914:2: warning: ignoring StaticAssert declaration
pub const union_LWLockPadded = extern union {
    lock: LWLock,
    pad: [128]u8,
};
pub const LWLockPadded = union_LWLockPadded;
pub extern var MainLWLockArray: [*c]LWLockPadded;
pub const struct_NamedLWLockTranche = extern struct {
    trancheId: c_int,
    trancheName: [*c]u8,
};
pub const NamedLWLockTranche = struct_NamedLWLockTranche;
pub extern var NamedLWLockTrancheArray: [*c]NamedLWLockTranche;
pub extern var NamedLWLockTrancheRequests: c_int;
pub const LW_EXCLUSIVE: c_int = 0;
pub const LW_SHARED: c_int = 1;
pub const LW_WAIT_UNTIL_FREE: c_int = 2;
pub const enum_LWLockMode = c_uint;
pub const LWLockMode = enum_LWLockMode;
pub extern fn LWLockAcquire(lock: [*c]LWLock, mode: LWLockMode) bool;
pub extern fn LWLockConditionalAcquire(lock: [*c]LWLock, mode: LWLockMode) bool;
pub extern fn LWLockAcquireOrWait(lock: [*c]LWLock, mode: LWLockMode) bool;
pub extern fn LWLockRelease(lock: [*c]LWLock) void;
pub extern fn LWLockReleaseClearVar(lock: [*c]LWLock, valptr: [*c]uint64, val: uint64) void;
pub extern fn LWLockReleaseAll() void;
pub extern fn LWLockHeldByMe(lock: [*c]LWLock) bool;
pub extern fn LWLockAnyHeldByMe(lock: [*c]LWLock, nlocks: c_int, stride: usize) bool;
pub extern fn LWLockHeldByMeInMode(lock: [*c]LWLock, mode: LWLockMode) bool;
pub extern fn LWLockWaitForVar(lock: [*c]LWLock, valptr: [*c]uint64, oldval: uint64, newval: [*c]uint64) bool;
pub extern fn LWLockUpdateVar(lock: [*c]LWLock, valptr: [*c]uint64, val: uint64) void;
pub extern fn LWLockShmemSize() Size;
pub extern fn CreateLWLocks() void;
pub extern fn InitLWLockAccess() void;
pub extern fn GetLWLockIdentifier(classId: uint32, eventId: uint16) [*c]const u8;
pub extern fn RequestNamedLWLockTranche(tranche_name: [*c]const u8, num_lwlocks: c_int) void;
pub extern fn GetNamedLWLockTranche(tranche_name: [*c]const u8) [*c]LWLockPadded;
pub extern fn LWLockNewTrancheId() c_int;
pub extern fn LWLockRegisterTranche(tranche_id: c_int, tranche_name: [*c]const u8) void;
pub extern fn LWLockInitialize(lock: [*c]LWLock, tranche_id: c_int) void;
pub const LWTRANCHE_XACT_BUFFER: c_int = 48;
pub const LWTRANCHE_COMMITTS_BUFFER: c_int = 49;
pub const LWTRANCHE_SUBTRANS_BUFFER: c_int = 50;
pub const LWTRANCHE_MULTIXACTOFFSET_BUFFER: c_int = 51;
pub const LWTRANCHE_MULTIXACTMEMBER_BUFFER: c_int = 52;
pub const LWTRANCHE_NOTIFY_BUFFER: c_int = 53;
pub const LWTRANCHE_SERIAL_BUFFER: c_int = 54;
pub const LWTRANCHE_WAL_INSERT: c_int = 55;
pub const LWTRANCHE_BUFFER_CONTENT: c_int = 56;
pub const LWTRANCHE_REPLICATION_ORIGIN_STATE: c_int = 57;
pub const LWTRANCHE_REPLICATION_SLOT_IO: c_int = 58;
pub const LWTRANCHE_LOCK_FASTPATH: c_int = 59;
pub const LWTRANCHE_BUFFER_MAPPING: c_int = 60;
pub const LWTRANCHE_LOCK_MANAGER: c_int = 61;
pub const LWTRANCHE_PREDICATE_LOCK_MANAGER: c_int = 62;
pub const LWTRANCHE_PARALLEL_HASH_JOIN: c_int = 63;
pub const LWTRANCHE_PARALLEL_QUERY_DSA: c_int = 64;
pub const LWTRANCHE_PER_SESSION_DSA: c_int = 65;
pub const LWTRANCHE_PER_SESSION_RECORD_TYPE: c_int = 66;
pub const LWTRANCHE_PER_SESSION_RECORD_TYPMOD: c_int = 67;
pub const LWTRANCHE_SHARED_TUPLESTORE: c_int = 68;
pub const LWTRANCHE_SHARED_TIDBITMAP: c_int = 69;
pub const LWTRANCHE_PARALLEL_APPEND: c_int = 70;
pub const LWTRANCHE_PER_XACT_PREDICATE_LIST: c_int = 71;
pub const LWTRANCHE_PGSTATS_DSA: c_int = 72;
pub const LWTRANCHE_PGSTATS_HASH: c_int = 73;
pub const LWTRANCHE_PGSTATS_DATA: c_int = 74;
pub const LWTRANCHE_LAUNCHER_DSA: c_int = 75;
pub const LWTRANCHE_LAUNCHER_HASH: c_int = 76;
pub const LWTRANCHE_FIRST_USER_DEFINED: c_int = 77;
pub const enum_BuiltinTrancheIds = c_uint;
pub const BuiltinTrancheIds = enum_BuiltinTrancheIds;
pub const LWLockId = [*c]LWLock;
pub extern fn InitShmemAccess(seghdr: ?*anyopaque) void;
pub extern fn InitShmemAllocation() void;
pub extern fn ShmemAlloc(size: Size) ?*anyopaque;
pub extern fn ShmemAllocNoError(size: Size) ?*anyopaque;
pub extern fn ShmemAllocUnlocked(size: Size) ?*anyopaque;
pub extern fn ShmemAddrIsValid(addr: ?*const anyopaque) bool;
pub extern fn InitShmemIndex() void;
pub extern fn ShmemInitHash(name: [*c]const u8, init_size: c_long, max_size: c_long, infoP: [*c]HASHCTL, hash_flags: c_int) ?*HTAB;
pub extern fn ShmemInitStruct(name: [*c]const u8, size: Size, foundPtr: [*c]bool) ?*anyopaque;
pub extern fn add_size(s1: Size, s2: Size) Size;
pub extern fn mul_size(s1: Size, s2: Size) Size;
pub extern fn RequestAddinShmemSpace(size: Size) void;
pub const ShmemIndexEnt = extern struct {
    key: [48]u8,
    location: ?*anyopaque,
    size: Size,
    allocated_size: Size,
};
pub const struct_iovec = extern struct {
    iov_base: ?*anyopaque,
    iov_len: usize,
};
pub const socklen_t = __socklen_t;
pub const SOCK_STREAM: c_int = 1;
pub const SOCK_DGRAM: c_int = 2;
pub const SOCK_RAW: c_int = 3;
pub const SOCK_RDM: c_int = 4;
pub const SOCK_SEQPACKET: c_int = 5;
pub const SOCK_DCCP: c_int = 6;
pub const SOCK_PACKET: c_int = 10;
pub const SOCK_CLOEXEC: c_int = 524288;
pub const SOCK_NONBLOCK: c_int = 2048;
pub const enum___socket_type = c_uint;
pub const sa_family_t = c_ushort;
pub const struct_sockaddr = extern struct {
    sa_family: sa_family_t,
    sa_data: [14]u8,
};
pub const struct_sockaddr_storage = extern struct {
    ss_family: sa_family_t,
    __ss_padding: [118]u8,
    __ss_align: c_ulong,
};
pub const MSG_OOB: c_int = 1;
pub const MSG_PEEK: c_int = 2;
pub const MSG_DONTROUTE: c_int = 4;
pub const MSG_CTRUNC: c_int = 8;
pub const MSG_PROXY: c_int = 16;
pub const MSG_TRUNC: c_int = 32;
pub const MSG_DONTWAIT: c_int = 64;
pub const MSG_EOR: c_int = 128;
pub const MSG_WAITALL: c_int = 256;
pub const MSG_FIN: c_int = 512;
pub const MSG_SYN: c_int = 1024;
pub const MSG_CONFIRM: c_int = 2048;
pub const MSG_RST: c_int = 4096;
pub const MSG_ERRQUEUE: c_int = 8192;
pub const MSG_NOSIGNAL: c_int = 16384;
pub const MSG_MORE: c_int = 32768;
pub const MSG_WAITFORONE: c_int = 65536;
pub const MSG_BATCH: c_int = 262144;
pub const MSG_ZEROCOPY: c_int = 67108864;
pub const MSG_FASTOPEN: c_int = 536870912;
pub const MSG_CMSG_CLOEXEC: c_int = 1073741824;
const enum_unnamed_43 = c_uint;
pub const struct_msghdr = extern struct {
    msg_name: ?*anyopaque,
    msg_namelen: socklen_t,
    msg_iov: [*c]struct_iovec,
    msg_iovlen: usize,
    msg_control: ?*anyopaque,
    msg_controllen: usize,
    msg_flags: c_int,
};
pub const struct_cmsghdr = extern struct {
    cmsg_len: usize align(8),
    cmsg_level: c_int,
    cmsg_type: c_int,
    pub fn __cmsg_data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @ptrCast(ReturnType, @alignCast(@alignOf(u8), @ptrCast(Intermediate, self) + 16));
    }
};
pub extern fn __cmsg_nxthdr(__mhdr: [*c]struct_msghdr, __cmsg: [*c]struct_cmsghdr) [*c]struct_cmsghdr;
pub const SCM_RIGHTS: c_int = 1;
const enum_unnamed_44 = c_uint;
pub const __kernel_fd_set = extern struct {
    fds_bits: [16]c_ulong,
};
pub const __kernel_sighandler_t = ?*const fn (c_int) callconv(.C) void;
pub const __kernel_key_t = c_int;
pub const __kernel_mqd_t = c_int;
pub const __kernel_old_uid_t = c_ushort;
pub const __kernel_old_gid_t = c_ushort;
pub const __kernel_old_dev_t = c_ulong;
pub const __kernel_long_t = c_long;
pub const __kernel_ulong_t = c_ulong;
pub const __kernel_ino_t = __kernel_ulong_t;
pub const __kernel_mode_t = c_uint;
pub const __kernel_pid_t = c_int;
pub const __kernel_ipc_pid_t = c_int;
pub const __kernel_uid_t = c_uint;
pub const __kernel_gid_t = c_uint;
pub const __kernel_suseconds_t = __kernel_long_t;
pub const __kernel_daddr_t = c_int;
pub const __kernel_uid32_t = c_uint;
pub const __kernel_gid32_t = c_uint;
pub const __kernel_size_t = __kernel_ulong_t;
pub const __kernel_ssize_t = __kernel_long_t;
pub const __kernel_ptrdiff_t = __kernel_long_t;
pub const __kernel_fsid_t = extern struct {
    val: [2]c_int,
};
pub const __kernel_off_t = __kernel_long_t;
pub const __kernel_loff_t = c_longlong;
pub const __kernel_old_time_t = __kernel_long_t;
pub const __kernel_time_t = __kernel_long_t;
pub const __kernel_time64_t = c_longlong;
pub const __kernel_clock_t = __kernel_long_t;
pub const __kernel_timer_t = c_int;
pub const __kernel_clockid_t = c_int;
pub const __kernel_caddr_t = [*c]u8;
pub const __kernel_uid16_t = c_ushort;
pub const __kernel_gid16_t = c_ushort;
pub const struct_linger = extern struct {
    l_onoff: c_int,
    l_linger: c_int,
};
pub const struct_osockaddr = extern struct {
    sa_family: c_ushort,
    sa_data: [14]u8,
};
pub const SHUT_RD: c_int = 0;
pub const SHUT_WR: c_int = 1;
pub const SHUT_RDWR: c_int = 2;
const enum_unnamed_45 = c_uint;
pub extern fn socket(__domain: c_int, __type: c_int, __protocol: c_int) c_int;
pub extern fn socketpair(__domain: c_int, __type: c_int, __protocol: c_int, __fds: [*c]c_int) c_int;
pub extern fn bind(__fd: c_int, __addr: [*c]const struct_sockaddr, __len: socklen_t) c_int;
pub extern fn getsockname(__fd: c_int, noalias __addr: [*c]struct_sockaddr, noalias __len: [*c]socklen_t) c_int;
pub extern fn connect(__fd: c_int, __addr: [*c]const struct_sockaddr, __len: socklen_t) c_int;
pub extern fn getpeername(__fd: c_int, noalias __addr: [*c]struct_sockaddr, noalias __len: [*c]socklen_t) c_int;
pub extern fn send(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __flags: c_int) isize;
pub extern fn recv(__fd: c_int, __buf: ?*anyopaque, __n: usize, __flags: c_int) isize;
pub extern fn sendto(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __flags: c_int, __addr: [*c]const struct_sockaddr, __addr_len: socklen_t) isize;
pub extern fn recvfrom(__fd: c_int, noalias __buf: ?*anyopaque, __n: usize, __flags: c_int, noalias __addr: [*c]struct_sockaddr, noalias __addr_len: [*c]socklen_t) isize;
pub extern fn sendmsg(__fd: c_int, __message: [*c]const struct_msghdr, __flags: c_int) isize;
pub extern fn recvmsg(__fd: c_int, __message: [*c]struct_msghdr, __flags: c_int) isize;
pub extern fn getsockopt(__fd: c_int, __level: c_int, __optname: c_int, noalias __optval: ?*anyopaque, noalias __optlen: [*c]socklen_t) c_int;
pub extern fn setsockopt(__fd: c_int, __level: c_int, __optname: c_int, __optval: ?*const anyopaque, __optlen: socklen_t) c_int;
pub extern fn listen(__fd: c_int, __n: c_int) c_int;
pub extern fn accept(__fd: c_int, noalias __addr: [*c]struct_sockaddr, noalias __addr_len: [*c]socklen_t) c_int;
pub extern fn shutdown(__fd: c_int, __how: c_int) c_int;
pub extern fn sockatmark(__fd: c_int) c_int;
pub extern fn isfdtype(__fd: c_int, __fdtype: c_int) c_int;
pub const in_addr_t = u32;
pub const struct_in_addr = extern struct {
    s_addr: in_addr_t,
};
pub const struct_ip_opts = extern struct {
    ip_dst: struct_in_addr,
    ip_opts: [40]u8,
};
pub const struct_in_pktinfo = extern struct {
    ipi_ifindex: c_int,
    ipi_spec_dst: struct_in_addr,
    ipi_addr: struct_in_addr,
};
pub const IPPROTO_IP: c_int = 0;
pub const IPPROTO_ICMP: c_int = 1;
pub const IPPROTO_IGMP: c_int = 2;
pub const IPPROTO_IPIP: c_int = 4;
pub const IPPROTO_TCP: c_int = 6;
pub const IPPROTO_EGP: c_int = 8;
pub const IPPROTO_PUP: c_int = 12;
pub const IPPROTO_UDP: c_int = 17;
pub const IPPROTO_IDP: c_int = 22;
pub const IPPROTO_TP: c_int = 29;
pub const IPPROTO_DCCP: c_int = 33;
pub const IPPROTO_IPV6: c_int = 41;
pub const IPPROTO_RSVP: c_int = 46;
pub const IPPROTO_GRE: c_int = 47;
pub const IPPROTO_ESP: c_int = 50;
pub const IPPROTO_AH: c_int = 51;
pub const IPPROTO_MTP: c_int = 92;
pub const IPPROTO_BEETPH: c_int = 94;
pub const IPPROTO_ENCAP: c_int = 98;
pub const IPPROTO_PIM: c_int = 103;
pub const IPPROTO_COMP: c_int = 108;
pub const IPPROTO_L2TP: c_int = 115;
pub const IPPROTO_SCTP: c_int = 132;
pub const IPPROTO_UDPLITE: c_int = 136;
pub const IPPROTO_MPLS: c_int = 137;
pub const IPPROTO_ETHERNET: c_int = 143;
pub const IPPROTO_RAW: c_int = 255;
pub const IPPROTO_MPTCP: c_int = 262;
pub const IPPROTO_MAX: c_int = 263;
const enum_unnamed_46 = c_uint;
pub const IPPROTO_HOPOPTS: c_int = 0;
pub const IPPROTO_ROUTING: c_int = 43;
pub const IPPROTO_FRAGMENT: c_int = 44;
pub const IPPROTO_ICMPV6: c_int = 58;
pub const IPPROTO_NONE: c_int = 59;
pub const IPPROTO_DSTOPTS: c_int = 60;
pub const IPPROTO_MH: c_int = 135;
const enum_unnamed_47 = c_uint;
pub const in_port_t = u16;
pub const IPPORT_ECHO: c_int = 7;
pub const IPPORT_DISCARD: c_int = 9;
pub const IPPORT_SYSTAT: c_int = 11;
pub const IPPORT_DAYTIME: c_int = 13;
pub const IPPORT_NETSTAT: c_int = 15;
pub const IPPORT_FTP: c_int = 21;
pub const IPPORT_TELNET: c_int = 23;
pub const IPPORT_SMTP: c_int = 25;
pub const IPPORT_TIMESERVER: c_int = 37;
pub const IPPORT_NAMESERVER: c_int = 42;
pub const IPPORT_WHOIS: c_int = 43;
pub const IPPORT_MTP: c_int = 57;
pub const IPPORT_TFTP: c_int = 69;
pub const IPPORT_RJE: c_int = 77;
pub const IPPORT_FINGER: c_int = 79;
pub const IPPORT_TTYLINK: c_int = 87;
pub const IPPORT_SUPDUP: c_int = 95;
pub const IPPORT_EXECSERVER: c_int = 512;
pub const IPPORT_LOGINSERVER: c_int = 513;
pub const IPPORT_CMDSERVER: c_int = 514;
pub const IPPORT_EFSSERVER: c_int = 520;
pub const IPPORT_BIFFUDP: c_int = 512;
pub const IPPORT_WHOSERVER: c_int = 513;
pub const IPPORT_ROUTESERVER: c_int = 520;
pub const IPPORT_RESERVED: c_int = 1024;
pub const IPPORT_USERRESERVED: c_int = 5000;
const enum_unnamed_48 = c_uint;
const union_unnamed_49 = extern union {
    __u6_addr8: [16]u8,
    __u6_addr16: [8]u16,
    __u6_addr32: [4]u32,
};
pub const struct_in6_addr = extern struct {
    __in6_u: union_unnamed_49,
};
pub extern const in6addr_any: struct_in6_addr;
pub extern const in6addr_loopback: struct_in6_addr;
pub const struct_sockaddr_in = extern struct {
    sin_family: sa_family_t,
    sin_port: in_port_t,
    sin_addr: struct_in_addr,
    sin_zero: [8]u8,
};
pub const struct_sockaddr_in6 = extern struct {
    sin6_family: sa_family_t,
    sin6_port: in_port_t,
    sin6_flowinfo: u32,
    sin6_addr: struct_in6_addr,
    sin6_scope_id: u32,
};
pub const struct_ip_mreq = extern struct {
    imr_multiaddr: struct_in_addr,
    imr_interface: struct_in_addr,
};
pub const struct_ip_mreqn = extern struct {
    imr_multiaddr: struct_in_addr,
    imr_address: struct_in_addr,
    imr_ifindex: c_int,
};
pub const struct_ip_mreq_source = extern struct {
    imr_multiaddr: struct_in_addr,
    imr_interface: struct_in_addr,
    imr_sourceaddr: struct_in_addr,
};
pub const struct_ipv6_mreq = extern struct {
    ipv6mr_multiaddr: struct_in6_addr,
    ipv6mr_interface: c_uint,
};
pub const struct_group_req = extern struct {
    gr_interface: u32,
    gr_group: struct_sockaddr_storage,
};
pub const struct_group_source_req = extern struct {
    gsr_interface: u32,
    gsr_group: struct_sockaddr_storage,
    gsr_source: struct_sockaddr_storage,
};
pub const struct_ip_msfilter = extern struct {
    imsf_multiaddr: struct_in_addr,
    imsf_interface: struct_in_addr,
    imsf_fmode: u32,
    imsf_numsrc: u32,
    imsf_slist: [1]struct_in_addr,
};
pub const struct_group_filter = extern struct {
    gf_interface: u32,
    gf_group: struct_sockaddr_storage,
    gf_fmode: u32,
    gf_numsrc: u32,
    gf_slist: [1]struct_sockaddr_storage,
};
pub extern fn ntohl(__netlong: u32) u32;
pub extern fn ntohs(__netshort: u16) u16;
pub extern fn htonl(__hostlong: u32) u32;
pub extern fn htons(__hostshort: u16) u16;
pub extern fn bindresvport(__sockfd: c_int, __sock_in: [*c]struct_sockaddr_in) c_int;
pub extern fn bindresvport6(__sockfd: c_int, __sock_in: [*c]struct_sockaddr_in6) c_int;
pub const struct_rpcent = extern struct {
    r_name: [*c]u8,
    r_aliases: [*c][*c]u8,
    r_number: c_int,
};
pub extern fn setrpcent(__stayopen: c_int) void;
pub extern fn endrpcent() void;
pub extern fn getrpcbyname(__name: [*c]const u8) [*c]struct_rpcent;
pub extern fn getrpcbynumber(__number: c_int) [*c]struct_rpcent;
pub extern fn getrpcent() [*c]struct_rpcent;
pub extern fn getrpcbyname_r(__name: [*c]const u8, __result_buf: [*c]struct_rpcent, __buffer: [*c]u8, __buflen: usize, __result: [*c][*c]struct_rpcent) c_int;
pub extern fn getrpcbynumber_r(__number: c_int, __result_buf: [*c]struct_rpcent, __buffer: [*c]u8, __buflen: usize, __result: [*c][*c]struct_rpcent) c_int;
pub extern fn getrpcent_r(__result_buf: [*c]struct_rpcent, __buffer: [*c]u8, __buflen: usize, __result: [*c][*c]struct_rpcent) c_int;
pub const struct_netent = extern struct {
    n_name: [*c]u8,
    n_aliases: [*c][*c]u8,
    n_addrtype: c_int,
    n_net: u32,
};
pub extern fn __h_errno_location() [*c]c_int;
pub extern fn herror(__str: [*c]const u8) void;
pub extern fn hstrerror(__err_num: c_int) [*c]const u8;
pub const struct_hostent = extern struct {
    h_name: [*c]u8,
    h_aliases: [*c][*c]u8,
    h_addrtype: c_int,
    h_length: c_int,
    h_addr_list: [*c][*c]u8,
};
pub extern fn sethostent(__stay_open: c_int) void;
pub extern fn endhostent() void;
pub extern fn gethostent() [*c]struct_hostent;
pub extern fn gethostbyaddr(__addr: ?*const anyopaque, __len: __socklen_t, __type: c_int) [*c]struct_hostent;
pub extern fn gethostbyname(__name: [*c]const u8) [*c]struct_hostent;
pub extern fn gethostbyname2(__name: [*c]const u8, __af: c_int) [*c]struct_hostent;
pub extern fn gethostent_r(noalias __result_buf: [*c]struct_hostent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_hostent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn gethostbyaddr_r(noalias __addr: ?*const anyopaque, __len: __socklen_t, __type: c_int, noalias __result_buf: [*c]struct_hostent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_hostent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn gethostbyname_r(noalias __name: [*c]const u8, noalias __result_buf: [*c]struct_hostent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_hostent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn gethostbyname2_r(noalias __name: [*c]const u8, __af: c_int, noalias __result_buf: [*c]struct_hostent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_hostent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn setnetent(__stay_open: c_int) void;
pub extern fn endnetent() void;
pub extern fn getnetent() [*c]struct_netent;
pub extern fn getnetbyaddr(__net: u32, __type: c_int) [*c]struct_netent;
pub extern fn getnetbyname(__name: [*c]const u8) [*c]struct_netent;
pub extern fn getnetent_r(noalias __result_buf: [*c]struct_netent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_netent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn getnetbyaddr_r(__net: u32, __type: c_int, noalias __result_buf: [*c]struct_netent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_netent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn getnetbyname_r(noalias __name: [*c]const u8, noalias __result_buf: [*c]struct_netent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_netent, noalias __h_errnop: [*c]c_int) c_int;
pub const struct_servent = extern struct {
    s_name: [*c]u8,
    s_aliases: [*c][*c]u8,
    s_port: c_int,
    s_proto: [*c]u8,
};
pub extern fn setservent(__stay_open: c_int) void;
pub extern fn endservent() void;
pub extern fn getservent() [*c]struct_servent;
pub extern fn getservbyname(__name: [*c]const u8, __proto: [*c]const u8) [*c]struct_servent;
pub extern fn getservbyport(__port: c_int, __proto: [*c]const u8) [*c]struct_servent;
pub extern fn getservent_r(noalias __result_buf: [*c]struct_servent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_servent) c_int;
pub extern fn getservbyname_r(noalias __name: [*c]const u8, noalias __proto: [*c]const u8, noalias __result_buf: [*c]struct_servent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_servent) c_int;
pub extern fn getservbyport_r(__port: c_int, noalias __proto: [*c]const u8, noalias __result_buf: [*c]struct_servent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_servent) c_int;
pub const struct_protoent = extern struct {
    p_name: [*c]u8,
    p_aliases: [*c][*c]u8,
    p_proto: c_int,
};
pub extern fn setprotoent(__stay_open: c_int) void;
pub extern fn endprotoent() void;
pub extern fn getprotoent() [*c]struct_protoent;
pub extern fn getprotobyname(__name: [*c]const u8) [*c]struct_protoent;
pub extern fn getprotobynumber(__proto: c_int) [*c]struct_protoent;
pub extern fn getprotoent_r(noalias __result_buf: [*c]struct_protoent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_protoent) c_int;
pub extern fn getprotobyname_r(noalias __name: [*c]const u8, noalias __result_buf: [*c]struct_protoent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_protoent) c_int;
pub extern fn getprotobynumber_r(__proto: c_int, noalias __result_buf: [*c]struct_protoent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_protoent) c_int;
pub extern fn setnetgrent(__netgroup: [*c]const u8) c_int;
pub extern fn endnetgrent() void;
pub extern fn getnetgrent(noalias __hostp: [*c][*c]u8, noalias __userp: [*c][*c]u8, noalias __domainp: [*c][*c]u8) c_int;
pub extern fn innetgr(__netgroup: [*c]const u8, __host: [*c]const u8, __user: [*c]const u8, __domain: [*c]const u8) c_int;
pub extern fn getnetgrent_r(noalias __hostp: [*c][*c]u8, noalias __userp: [*c][*c]u8, noalias __domainp: [*c][*c]u8, noalias __buffer: [*c]u8, __buflen: usize) c_int;
pub extern fn rcmd(noalias __ahost: [*c][*c]u8, __rport: c_ushort, noalias __locuser: [*c]const u8, noalias __remuser: [*c]const u8, noalias __cmd: [*c]const u8, noalias __fd2p: [*c]c_int) c_int;
pub extern fn rcmd_af(noalias __ahost: [*c][*c]u8, __rport: c_ushort, noalias __locuser: [*c]const u8, noalias __remuser: [*c]const u8, noalias __cmd: [*c]const u8, noalias __fd2p: [*c]c_int, __af: sa_family_t) c_int;
pub extern fn rexec(noalias __ahost: [*c][*c]u8, __rport: c_int, noalias __name: [*c]const u8, noalias __pass: [*c]const u8, noalias __cmd: [*c]const u8, noalias __fd2p: [*c]c_int) c_int;
pub extern fn rexec_af(noalias __ahost: [*c][*c]u8, __rport: c_int, noalias __name: [*c]const u8, noalias __pass: [*c]const u8, noalias __cmd: [*c]const u8, noalias __fd2p: [*c]c_int, __af: sa_family_t) c_int;
pub extern fn ruserok(__rhost: [*c]const u8, __suser: c_int, __remuser: [*c]const u8, __locuser: [*c]const u8) c_int;
pub extern fn ruserok_af(__rhost: [*c]const u8, __suser: c_int, __remuser: [*c]const u8, __locuser: [*c]const u8, __af: sa_family_t) c_int;
pub extern fn iruserok(__raddr: u32, __suser: c_int, __remuser: [*c]const u8, __locuser: [*c]const u8) c_int;
pub extern fn iruserok_af(__raddr: ?*const anyopaque, __suser: c_int, __remuser: [*c]const u8, __locuser: [*c]const u8, __af: sa_family_t) c_int;
pub extern fn rresvport(__alport: [*c]c_int) c_int;
pub extern fn rresvport_af(__alport: [*c]c_int, __af: sa_family_t) c_int;
pub const struct_addrinfo = extern struct {
    ai_flags: c_int,
    ai_family: c_int,
    ai_socktype: c_int,
    ai_protocol: c_int,
    ai_addrlen: socklen_t,
    ai_addr: [*c]struct_sockaddr,
    ai_canonname: [*c]u8,
    ai_next: [*c]struct_addrinfo,
};
pub extern fn getaddrinfo(noalias __name: [*c]const u8, noalias __service: [*c]const u8, noalias __req: [*c]const struct_addrinfo, noalias __pai: [*c][*c]struct_addrinfo) c_int;
pub extern fn freeaddrinfo(__ai: [*c]struct_addrinfo) void;
pub extern fn gai_strerror(__ecode: c_int) [*c]const u8;
pub extern fn getnameinfo(noalias __sa: [*c]const struct_sockaddr, __salen: socklen_t, noalias __host: [*c]u8, __hostlen: socklen_t, noalias __serv: [*c]u8, __servlen: socklen_t, __flags: c_int) c_int;
pub extern var DefaultXactIsoLevel: c_int;
pub extern var XactIsoLevel: c_int;
pub extern var DefaultXactReadOnly: bool;
pub extern var XactReadOnly: bool;
pub extern var xact_is_sampled: bool;
pub extern var DefaultXactDeferrable: bool;
pub extern var XactDeferrable: bool;
pub const SYNCHRONOUS_COMMIT_OFF: c_int = 0;
pub const SYNCHRONOUS_COMMIT_LOCAL_FLUSH: c_int = 1;
pub const SYNCHRONOUS_COMMIT_REMOTE_WRITE: c_int = 2;
pub const SYNCHRONOUS_COMMIT_REMOTE_FLUSH: c_int = 3;
pub const SYNCHRONOUS_COMMIT_REMOTE_APPLY: c_int = 4;
pub const SyncCommitLevel = c_uint;
pub extern var synchronous_commit: c_int;
pub extern var CheckXidAlive: TransactionId;
pub extern var bsysscan: bool;
pub extern var MyXactFlags: c_int;
pub const XACT_EVENT_COMMIT: c_int = 0;
pub const XACT_EVENT_PARALLEL_COMMIT: c_int = 1;
pub const XACT_EVENT_ABORT: c_int = 2;
pub const XACT_EVENT_PARALLEL_ABORT: c_int = 3;
pub const XACT_EVENT_PREPARE: c_int = 4;
pub const XACT_EVENT_PRE_COMMIT: c_int = 5;
pub const XACT_EVENT_PARALLEL_PRE_COMMIT: c_int = 6;
pub const XACT_EVENT_PRE_PREPARE: c_int = 7;
pub const XactEvent = c_uint;
pub const XactCallback = ?*const fn (XactEvent, ?*anyopaque) callconv(.C) void;
pub const SUBXACT_EVENT_START_SUB: c_int = 0;
pub const SUBXACT_EVENT_COMMIT_SUB: c_int = 1;
pub const SUBXACT_EVENT_ABORT_SUB: c_int = 2;
pub const SUBXACT_EVENT_PRE_COMMIT_SUB: c_int = 3;
pub const SubXactEvent = c_uint;
pub const SubXactCallback = ?*const fn (SubXactEvent, SubTransactionId, SubTransactionId, ?*anyopaque) callconv(.C) void;
pub const struct_SavedTransactionCharacteristics = extern struct {
    save_XactIsoLevel: c_int,
    save_XactReadOnly: bool,
    save_XactDeferrable: bool,
};
pub const SavedTransactionCharacteristics = struct_SavedTransactionCharacteristics;
pub const struct_xl_xact_assignment = extern struct {
    xtop: TransactionId align(4),
    nsubxacts: c_int,
    pub fn xsub(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), TransactionId) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), TransactionId);
        return @ptrCast(ReturnType, @alignCast(@alignOf(TransactionId), @ptrCast(Intermediate, self) + 8));
    }
};
pub const xl_xact_assignment = struct_xl_xact_assignment;
pub const struct_xl_xact_xinfo = extern struct {
    xinfo: uint32,
};
pub const xl_xact_xinfo = struct_xl_xact_xinfo;
pub const struct_xl_xact_dbinfo = extern struct {
    dbId: Oid,
    tsId: Oid,
};
pub const xl_xact_dbinfo = struct_xl_xact_dbinfo;
pub const struct_xl_xact_subxacts = extern struct {
    nsubxacts: c_int align(4),
    pub fn subxacts(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), TransactionId) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), TransactionId);
        return @ptrCast(ReturnType, @alignCast(@alignOf(TransactionId), @ptrCast(Intermediate, self) + 4));
    }
};
pub const xl_xact_subxacts = struct_xl_xact_subxacts;
pub const struct_xl_xact_relfilelocators = extern struct {
    nrels: c_int align(4),
    pub fn xlocators(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), RelFileLocator) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), RelFileLocator);
        return @ptrCast(ReturnType, @alignCast(@alignOf(RelFileLocator), @ptrCast(Intermediate, self) + 4));
    }
};
pub const xl_xact_relfilelocators = struct_xl_xact_relfilelocators;
pub const struct_xl_xact_stats_item = extern struct {
    kind: c_int,
    dboid: Oid,
    objoid: Oid,
};
pub const xl_xact_stats_item = struct_xl_xact_stats_item;
pub const struct_xl_xact_stats_items = extern struct {
    nitems: c_int align(4),
    pub fn items(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), xl_xact_stats_item) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), xl_xact_stats_item);
        return @ptrCast(ReturnType, @alignCast(@alignOf(xl_xact_stats_item), @ptrCast(Intermediate, self) + 4));
    }
};
pub const xl_xact_stats_items = struct_xl_xact_stats_items;
pub const struct_xl_xact_invals = extern struct {
    nmsgs: c_int align(4),
    pub fn msgs(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), SharedInvalidationMessage) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), SharedInvalidationMessage);
        return @ptrCast(ReturnType, @alignCast(@alignOf(SharedInvalidationMessage), @ptrCast(Intermediate, self) + 4));
    }
};
pub const xl_xact_invals = struct_xl_xact_invals;
pub const struct_xl_xact_twophase = extern struct {
    xid: TransactionId,
};
pub const xl_xact_twophase = struct_xl_xact_twophase;
pub const struct_xl_xact_origin = extern struct {
    origin_lsn: XLogRecPtr,
    origin_timestamp: TimestampTz,
};
pub const xl_xact_origin = struct_xl_xact_origin;
pub const struct_xl_xact_commit = extern struct {
    xact_time: TimestampTz,
};
pub const xl_xact_commit = struct_xl_xact_commit;
pub const struct_xl_xact_abort = extern struct {
    xact_time: TimestampTz,
};
pub const xl_xact_abort = struct_xl_xact_abort;
pub const struct_xl_xact_prepare = extern struct {
    magic: uint32,
    total_len: uint32,
    xid: TransactionId,
    database: Oid,
    prepared_at: TimestampTz,
    owner: Oid,
    nsubxacts: int32,
    ncommitrels: int32,
    nabortrels: int32,
    ncommitstats: int32,
    nabortstats: int32,
    ninvalmsgs: int32,
    initfileinval: bool,
    gidlen: uint16,
    origin_lsn: XLogRecPtr,
    origin_timestamp: TimestampTz,
};
pub const xl_xact_prepare = struct_xl_xact_prepare;
pub const struct_xl_xact_parsed_commit = extern struct {
    xact_time: TimestampTz,
    xinfo: uint32,
    dbId: Oid,
    tsId: Oid,
    nsubxacts: c_int,
    subxacts: [*c]TransactionId,
    nrels: c_int,
    xlocators: [*c]RelFileLocator,
    nstats: c_int,
    stats: [*c]xl_xact_stats_item,
    nmsgs: c_int,
    msgs: [*c]SharedInvalidationMessage,
    twophase_xid: TransactionId,
    twophase_gid: [200]u8,
    nabortrels: c_int,
    abortlocators: [*c]RelFileLocator,
    nabortstats: c_int,
    abortstats: [*c]xl_xact_stats_item,
    origin_lsn: XLogRecPtr,
    origin_timestamp: TimestampTz,
};
pub const xl_xact_parsed_commit = struct_xl_xact_parsed_commit;
pub const xl_xact_parsed_prepare = xl_xact_parsed_commit;
pub const struct_xl_xact_parsed_abort = extern struct {
    xact_time: TimestampTz,
    xinfo: uint32,
    dbId: Oid,
    tsId: Oid,
    nsubxacts: c_int,
    subxacts: [*c]TransactionId,
    nrels: c_int,
    xlocators: [*c]RelFileLocator,
    nstats: c_int,
    stats: [*c]xl_xact_stats_item,
    twophase_xid: TransactionId,
    twophase_gid: [200]u8,
    origin_lsn: XLogRecPtr,
    origin_timestamp: TimestampTz,
};
pub const xl_xact_parsed_abort = struct_xl_xact_parsed_abort;
pub extern fn IsTransactionState() bool;
pub extern fn IsAbortedTransactionBlockState() bool;
pub extern fn GetTopTransactionId() TransactionId;
pub extern fn GetTopTransactionIdIfAny() TransactionId;
pub extern fn GetCurrentTransactionId() TransactionId;
pub extern fn GetCurrentTransactionIdIfAny() TransactionId;
pub extern fn GetStableLatestTransactionId() TransactionId;
pub extern fn GetCurrentSubTransactionId() SubTransactionId;
pub extern fn GetTopFullTransactionId() FullTransactionId;
pub extern fn GetTopFullTransactionIdIfAny() FullTransactionId;
pub extern fn GetCurrentFullTransactionId() FullTransactionId;
pub extern fn GetCurrentFullTransactionIdIfAny() FullTransactionId;
pub extern fn MarkCurrentTransactionIdLoggedIfAny() void;
pub extern fn SubTransactionIsActive(subxid: SubTransactionId) bool;
pub extern fn GetCurrentCommandId(used: bool) CommandId;
pub extern fn SetParallelStartTimestamps(xact_ts: TimestampTz, stmt_ts: TimestampTz) void;
pub extern fn GetCurrentTransactionStartTimestamp() TimestampTz;
pub extern fn GetCurrentStatementStartTimestamp() TimestampTz;
pub extern fn GetCurrentTransactionStopTimestamp() TimestampTz;
pub extern fn SetCurrentStatementStartTimestamp() void;
pub extern fn GetCurrentTransactionNestLevel() c_int;
pub extern fn TransactionIdIsCurrentTransactionId(xid: TransactionId) bool;
pub extern fn CommandCounterIncrement() void;
pub extern fn ForceSyncCommit() void;
pub extern fn StartTransactionCommand() void;
pub extern fn SaveTransactionCharacteristics(s: [*c]SavedTransactionCharacteristics) void;
pub extern fn RestoreTransactionCharacteristics(s: [*c]const SavedTransactionCharacteristics) void;
pub extern fn CommitTransactionCommand() void;
pub extern fn AbortCurrentTransaction() void;
pub extern fn BeginTransactionBlock() void;
pub extern fn EndTransactionBlock(chain: bool) bool;
pub extern fn PrepareTransactionBlock(gid: [*c]const u8) bool;
pub extern fn UserAbortTransactionBlock(chain: bool) void;
pub extern fn BeginImplicitTransactionBlock() void;
pub extern fn EndImplicitTransactionBlock() void;
pub extern fn ReleaseSavepoint(name: [*c]const u8) void;
pub extern fn DefineSavepoint(name: [*c]const u8) void;
pub extern fn RollbackToSavepoint(name: [*c]const u8) void;
pub extern fn BeginInternalSubTransaction(name: [*c]const u8) void;
pub extern fn ReleaseCurrentSubTransaction() void;
pub extern fn RollbackAndReleaseCurrentSubTransaction() void;
pub extern fn IsSubTransaction() bool;
pub extern fn EstimateTransactionStateSpace() Size;
pub extern fn SerializeTransactionState(maxsize: Size, start_address: [*c]u8) void;
pub extern fn StartParallelWorkerTransaction(tstatespace: [*c]u8) void;
pub extern fn EndParallelWorkerTransaction() void;
pub extern fn IsTransactionBlock() bool;
pub extern fn IsTransactionOrTransactionBlock() bool;
pub extern fn TransactionBlockStatusCode() u8;
pub extern fn AbortOutOfAnyTransaction() void;
pub extern fn PreventInTransactionBlock(isTopLevel: bool, stmtType: [*c]const u8) void;
pub extern fn RequireTransactionBlock(isTopLevel: bool, stmtType: [*c]const u8) void;
pub extern fn WarnNoTransactionBlock(isTopLevel: bool, stmtType: [*c]const u8) void;
pub extern fn IsInTransactionBlock(isTopLevel: bool) bool;
pub extern fn RegisterXactCallback(callback: XactCallback, arg: ?*anyopaque) void;
pub extern fn UnregisterXactCallback(callback: XactCallback, arg: ?*anyopaque) void;
pub extern fn RegisterSubXactCallback(callback: SubXactCallback, arg: ?*anyopaque) void;
pub extern fn UnregisterSubXactCallback(callback: SubXactCallback, arg: ?*anyopaque) void;
pub extern fn IsSubxactTopXidLogPending() bool;
pub extern fn MarkSubxactTopXidLogged() void;
pub extern fn xactGetCommittedChildren(ptr: [*c][*c]TransactionId) c_int;
pub extern fn XactLogCommitRecord(commit_time: TimestampTz, nsubxacts: c_int, subxacts: [*c]TransactionId, nrels: c_int, rels: [*c]RelFileLocator, ndroppedstats: c_int, droppedstats: [*c]xl_xact_stats_item, nmsgs: c_int, msgs: [*c]SharedInvalidationMessage, relcacheInval: bool, xactflags: c_int, twophase_xid: TransactionId, twophase_gid: [*c]const u8) XLogRecPtr;
pub extern fn XactLogAbortRecord(abort_time: TimestampTz, nsubxacts: c_int, subxacts: [*c]TransactionId, nrels: c_int, rels: [*c]RelFileLocator, ndroppedstats: c_int, droppedstats: [*c]xl_xact_stats_item, xactflags: c_int, twophase_xid: TransactionId, twophase_gid: [*c]const u8) XLogRecPtr;
pub extern fn xact_redo(record: [*c]XLogReaderState) void;
pub extern fn xact_desc(buf: StringInfo, record: [*c]XLogReaderState) void;
pub extern fn xact_identify(info: uint8) [*c]const u8;
pub extern fn ParseCommitRecord(info: uint8, xlrec: [*c]xl_xact_commit, parsed: [*c]xl_xact_parsed_commit) void;
pub extern fn ParseAbortRecord(info: uint8, xlrec: [*c]xl_xact_abort, parsed: [*c]xl_xact_parsed_abort) void;
pub extern fn ParsePrepareRecord(info: uint8, xlrec: [*c]xl_xact_prepare, parsed: [*c]xl_xact_parsed_prepare) void;
pub extern fn EnterParallelMode() void;
pub extern fn ExitParallelMode() void;
pub extern fn IsInParallelMode() bool;
pub const TupleTableSlotOps = struct_TupleTableSlotOps;
pub const struct_TupleTableSlot = extern struct {
    type: NodeTag,
    tts_flags: uint16,
    tts_nvalid: AttrNumber,
    tts_ops: [*c]const TupleTableSlotOps,
    tts_tupleDescriptor: TupleDesc,
    tts_values: [*c]Datum,
    tts_isnull: [*c]bool,
    tts_mcxt: MemoryContext,
    tts_tid: ItemPointerData,
    tts_tableOid: Oid,
};
pub const TupleTableSlot = struct_TupleTableSlot;
pub const struct_TupleTableSlotOps = extern struct {
    base_slot_size: usize,
    init: ?*const fn ([*c]TupleTableSlot) callconv(.C) void,
    release: ?*const fn ([*c]TupleTableSlot) callconv(.C) void,
    clear: ?*const fn ([*c]TupleTableSlot) callconv(.C) void,
    getsomeattrs: ?*const fn ([*c]TupleTableSlot, c_int) callconv(.C) void,
    getsysattr: ?*const fn ([*c]TupleTableSlot, c_int, [*c]bool) callconv(.C) Datum,
    materialize: ?*const fn ([*c]TupleTableSlot) callconv(.C) void,
    copyslot: ?*const fn ([*c]TupleTableSlot, [*c]TupleTableSlot) callconv(.C) void,
    get_heap_tuple: ?*const fn ([*c]TupleTableSlot) callconv(.C) HeapTuple,
    get_minimal_tuple: ?*const fn ([*c]TupleTableSlot) callconv(.C) MinimalTuple,
    copy_heap_tuple: ?*const fn ([*c]TupleTableSlot) callconv(.C) HeapTuple,
    copy_minimal_tuple: ?*const fn ([*c]TupleTableSlot) callconv(.C) MinimalTuple,
};
pub extern const TTSOpsVirtual: TupleTableSlotOps;
pub extern const TTSOpsHeapTuple: TupleTableSlotOps;
pub extern const TTSOpsMinimalTuple: TupleTableSlotOps;
pub extern const TTSOpsBufferHeapTuple: TupleTableSlotOps;
pub const struct_VirtualTupleTableSlot = extern struct {
    base: TupleTableSlot,
    data: [*c]u8,
};
pub const VirtualTupleTableSlot = struct_VirtualTupleTableSlot;
pub const struct_HeapTupleTableSlot = extern struct {
    base: TupleTableSlot,
    tuple: HeapTuple,
    off: uint32,
    tupdata: HeapTupleData,
};
pub const HeapTupleTableSlot = struct_HeapTupleTableSlot;
pub const struct_BufferHeapTupleTableSlot = extern struct {
    base: HeapTupleTableSlot,
    buffer: Buffer,
};
pub const BufferHeapTupleTableSlot = struct_BufferHeapTupleTableSlot;
pub const struct_MinimalTupleTableSlot = extern struct {
    base: TupleTableSlot,
    tuple: HeapTuple,
    mintuple: MinimalTuple,
    minhdr: HeapTupleData,
    off: uint32,
};
pub const MinimalTupleTableSlot = struct_MinimalTupleTableSlot;
pub extern fn MakeTupleTableSlot(tupleDesc: TupleDesc, tts_ops: [*c]const TupleTableSlotOps) [*c]TupleTableSlot;
pub extern fn ExecAllocTableSlot(tupleTable: [*c][*c]List, desc: TupleDesc, tts_ops: [*c]const TupleTableSlotOps) [*c]TupleTableSlot;
pub extern fn ExecResetTupleTable(tupleTable: [*c]List, shouldFree: bool) void;
pub extern fn MakeSingleTupleTableSlot(tupdesc: TupleDesc, tts_ops: [*c]const TupleTableSlotOps) [*c]TupleTableSlot;
pub extern fn ExecDropSingleTupleTableSlot(slot: [*c]TupleTableSlot) void;
pub extern fn ExecSetSlotDescriptor(slot: [*c]TupleTableSlot, tupdesc: TupleDesc) void;
pub extern fn ExecStoreHeapTuple(tuple: HeapTuple, slot: [*c]TupleTableSlot, shouldFree: bool) [*c]TupleTableSlot;
pub extern fn ExecForceStoreHeapTuple(tuple: HeapTuple, slot: [*c]TupleTableSlot, shouldFree: bool) void;
pub extern fn ExecStoreBufferHeapTuple(tuple: HeapTuple, slot: [*c]TupleTableSlot, buffer: Buffer) [*c]TupleTableSlot;
pub extern fn ExecStorePinnedBufferHeapTuple(tuple: HeapTuple, slot: [*c]TupleTableSlot, buffer: Buffer) [*c]TupleTableSlot;
pub extern fn ExecStoreMinimalTuple(mtup: MinimalTuple, slot: [*c]TupleTableSlot, shouldFree: bool) [*c]TupleTableSlot;
pub extern fn ExecForceStoreMinimalTuple(mtup: MinimalTuple, slot: [*c]TupleTableSlot, shouldFree: bool) void;
pub extern fn ExecStoreVirtualTuple(slot: [*c]TupleTableSlot) [*c]TupleTableSlot;
pub extern fn ExecStoreAllNullTuple(slot: [*c]TupleTableSlot) [*c]TupleTableSlot;
pub extern fn ExecStoreHeapTupleDatum(data: Datum, slot: [*c]TupleTableSlot) void;
pub extern fn ExecFetchSlotHeapTuple(slot: [*c]TupleTableSlot, materialize: bool, shouldFree: [*c]bool) HeapTuple;
pub extern fn ExecFetchSlotMinimalTuple(slot: [*c]TupleTableSlot, shouldFree: [*c]bool) MinimalTuple;
pub extern fn ExecFetchSlotHeapTupleDatum(slot: [*c]TupleTableSlot) Datum;
pub extern fn slot_getmissingattrs(slot: [*c]TupleTableSlot, startAttNum: c_int, lastAttNum: c_int) void;
pub extern fn slot_getsomeattrs_int(slot: [*c]TupleTableSlot, attnum: c_int) void;
pub fn slot_getsomeattrs(arg_slot: [*c]TupleTableSlot, arg_attnum: c_int) callconv(.C) void {
    var slot = arg_slot;
    var attnum = arg_attnum;
    if (@bitCast(c_int, @as(c_int, slot.*.tts_nvalid)) < attnum) {
        slot_getsomeattrs_int(slot, attnum);
    }
}
pub fn slot_getallattrs(arg_slot: [*c]TupleTableSlot) callconv(.C) void {
    var slot = arg_slot;
    slot_getsomeattrs(slot, slot.*.tts_tupleDescriptor.*.natts);
}
pub fn slot_attisnull(arg_slot: [*c]TupleTableSlot, arg_attnum: c_int) callconv(.C) bool {
    var slot = arg_slot;
    var attnum = arg_attnum;
    _ = @as(c_int, 1);
    if (attnum > @bitCast(c_int, @as(c_int, slot.*.tts_nvalid))) {
        slot_getsomeattrs(slot, attnum);
    }
    return (blk: {
        const tmp = attnum - @as(c_int, 1);
        if (tmp >= 0) break :blk slot.*.tts_isnull + @intCast(usize, tmp) else break :blk slot.*.tts_isnull - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
    }).*;
}
pub fn slot_getattr(arg_slot: [*c]TupleTableSlot, arg_attnum: c_int, arg_isnull: [*c]bool) callconv(.C) Datum {
    var slot = arg_slot;
    var attnum = arg_attnum;
    var isnull = arg_isnull;
    _ = @as(c_int, 1);
    if (attnum > @bitCast(c_int, @as(c_int, slot.*.tts_nvalid))) {
        slot_getsomeattrs(slot, attnum);
    }
    isnull.* = (blk: {
        const tmp = attnum - @as(c_int, 1);
        if (tmp >= 0) break :blk slot.*.tts_isnull + @intCast(usize, tmp) else break :blk slot.*.tts_isnull - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
    }).*;
    return (blk: {
        const tmp = attnum - @as(c_int, 1);
        if (tmp >= 0) break :blk slot.*.tts_values + @intCast(usize, tmp) else break :blk slot.*.tts_values - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
    }).*;
}
pub fn slot_getsysattr(arg_slot: [*c]TupleTableSlot, arg_attnum: c_int, arg_isnull: [*c]bool) callconv(.C) Datum {
    var slot = arg_slot;
    var attnum = arg_attnum;
    var isnull = arg_isnull;
    _ = @as(c_int, 1);
    if (attnum == -@as(c_int, 6)) {
        isnull.* = @as(c_int, 0) != 0;
        return ObjectIdGetDatum(slot.*.tts_tableOid);
    } else if (attnum == -@as(c_int, 1)) {
        isnull.* = @as(c_int, 0) != 0;
        return PointerGetDatum(@ptrCast(?*const anyopaque, &slot.*.tts_tid));
    }
    return slot.*.tts_ops.*.getsysattr.?(slot, attnum, isnull);
}
pub fn ExecClearTuple(arg_slot: [*c]TupleTableSlot) callconv(.C) [*c]TupleTableSlot {
    var slot = arg_slot;
    slot.*.tts_ops.*.clear.?(slot);
    return slot;
}
pub fn ExecMaterializeSlot(arg_slot: [*c]TupleTableSlot) callconv(.C) void {
    var slot = arg_slot;
    slot.*.tts_ops.*.materialize.?(slot);
}
pub fn ExecCopySlotHeapTuple(arg_slot: [*c]TupleTableSlot) callconv(.C) HeapTuple {
    var slot = arg_slot;
    _ = @as(c_int, 1);
    return slot.*.tts_ops.*.copy_heap_tuple.?(slot);
}
pub fn ExecCopySlotMinimalTuple(arg_slot: [*c]TupleTableSlot) callconv(.C) MinimalTuple {
    var slot = arg_slot;
    return slot.*.tts_ops.*.copy_minimal_tuple.?(slot);
}
pub fn ExecCopySlot(arg_dstslot: [*c]TupleTableSlot, arg_srcslot: [*c]TupleTableSlot) callconv(.C) [*c]TupleTableSlot {
    var dstslot = arg_dstslot;
    var srcslot = arg_srcslot;
    _ = @as(c_int, 1);
    _ = @as(c_int, 1);
    dstslot.*.tts_ops.*.copyslot.?(dstslot, srcslot);
    return dstslot;
}
pub extern fn errdetail_relkind_not_supported(relkind: u8) c_int;
pub extern fn IsSystemRelation(relation: Relation) bool;
pub extern fn IsToastRelation(relation: Relation) bool;
pub extern fn IsCatalogRelation(relation: Relation) bool;
pub extern fn IsSystemClass(relid: Oid, reltuple: Form_pg_class) bool;
pub extern fn IsToastClass(reltuple: Form_pg_class) bool;
pub extern fn IsCatalogRelationOid(relid: Oid) bool;
pub extern fn IsCatalogNamespace(namespaceId: Oid) bool;
pub extern fn IsToastNamespace(namespaceId: Oid) bool;
pub extern fn IsReservedName(name: [*c]const u8) bool;
pub extern fn IsSharedRelation(relationId: Oid) bool;
pub extern fn IsPinnedObject(classId: Oid, objectId: Oid) bool;
pub extern fn GetNewOidWithIndex(relation: Relation, indexId: Oid, oidcolumn: AttrNumber) Oid;
pub extern fn GetNewRelFileNumber(reltablespace: Oid, pg_class: Relation, relpersistence: u8) RelFileNumber;
pub const struct_FormData_pg_publication = extern struct {
    oid: Oid,
    pubname: NameData,
    pubowner: Oid,
    puballtables: bool,
    pubinsert: bool,
    pubupdate: bool,
    pubdelete: bool,
    pubtruncate: bool,
    pubviaroot: bool,
};
pub const FormData_pg_publication = struct_FormData_pg_publication;
pub const Form_pg_publication = [*c]FormData_pg_publication;
pub const struct_Publication = extern struct {
    oid: Oid,
    name: [*c]u8,
    alltables: bool,
    pubviaroot: bool,
    pubactions: PublicationActions,
};
pub const Publication = struct_Publication;
pub const struct_PublicationRelInfo = extern struct {
    relation: Relation,
    whereClause: [*c]Node,
    columns: [*c]List,
};
pub const PublicationRelInfo = struct_PublicationRelInfo;
pub extern fn GetPublication(pubid: Oid) [*c]Publication;
pub extern fn GetPublicationByName(pubname: [*c]const u8, missing_ok: bool) [*c]Publication;
pub extern fn GetRelationPublications(relid: Oid) [*c]List;
pub const PUBLICATION_PART_ROOT: c_int = 0;
pub const PUBLICATION_PART_LEAF: c_int = 1;
pub const PUBLICATION_PART_ALL: c_int = 2;
pub const enum_PublicationPartOpt = c_uint;
pub const PublicationPartOpt = enum_PublicationPartOpt;
pub extern fn GetPublicationRelations(pubid: Oid, pub_partopt: PublicationPartOpt) [*c]List;
pub extern fn GetAllTablesPublications() [*c]List;
pub extern fn GetAllTablesPublicationRelations(pubviaroot: bool) [*c]List;
pub extern fn GetPublicationSchemas(pubid: Oid) [*c]List;
pub extern fn GetSchemaPublications(schemaid: Oid) [*c]List;
pub extern fn GetSchemaPublicationRelations(schemaid: Oid, pub_partopt: PublicationPartOpt) [*c]List;
pub extern fn GetAllSchemaPublicationRelations(pubid: Oid, pub_partopt: PublicationPartOpt) [*c]List;
pub extern fn GetPubPartitionOptionRelations(result: [*c]List, pub_partopt: PublicationPartOpt, relid: Oid) [*c]List;
pub extern fn GetTopMostAncestorInPublication(puboid: Oid, ancestors: [*c]List, ancestor_level: [*c]c_int) Oid;
pub extern fn is_publishable_relation(rel: Relation) bool;
pub extern fn is_schema_publication(pubid: Oid) bool;
pub extern fn publication_add_relation(pubid: Oid, pri: [*c]PublicationRelInfo, if_not_exists: bool) ObjectAddress;
pub extern fn publication_add_schema(pubid: Oid, schemaid: Oid, if_not_exists: bool) ObjectAddress;
pub extern fn pub_collist_to_bitmapset(columns: [*c]Bitmapset, pubcols: Datum, mcxt: MemoryContext) [*c]Bitmapset;
pub extern fn smgrinit() void;
pub extern fn smgropen(rlocator: RelFileLocator, backend: BackendId) SMgrRelation;
pub extern fn smgrexists(reln: SMgrRelation, forknum: ForkNumber) bool;
pub extern fn smgrsetowner(owner: [*c]SMgrRelation, reln: SMgrRelation) void;
pub extern fn smgrclearowner(owner: [*c]SMgrRelation, reln: SMgrRelation) void;
pub extern fn smgrclose(reln: SMgrRelation) void;
pub extern fn smgrcloseall() void;
pub extern fn smgrcloserellocator(rlocator: RelFileLocatorBackend) void;
pub extern fn smgrrelease(reln: SMgrRelation) void;
pub extern fn smgrreleaseall() void;
pub extern fn smgrcreate(reln: SMgrRelation, forknum: ForkNumber, isRedo: bool) void;
pub extern fn smgrdosyncall(rels: [*c]SMgrRelation, nrels: c_int) void;
pub extern fn smgrdounlinkall(rels: [*c]SMgrRelation, nrels: c_int, isRedo: bool) void;
pub extern fn smgrextend(reln: SMgrRelation, forknum: ForkNumber, blocknum: BlockNumber, buffer: ?*const anyopaque, skipFsync: bool) void;
pub extern fn smgrzeroextend(reln: SMgrRelation, forknum: ForkNumber, blocknum: BlockNumber, nblocks: c_int, skipFsync: bool) void;
pub extern fn smgrprefetch(reln: SMgrRelation, forknum: ForkNumber, blocknum: BlockNumber) bool;
pub extern fn smgrread(reln: SMgrRelation, forknum: ForkNumber, blocknum: BlockNumber, buffer: ?*anyopaque) void;
pub extern fn smgrwrite(reln: SMgrRelation, forknum: ForkNumber, blocknum: BlockNumber, buffer: ?*const anyopaque, skipFsync: bool) void;
pub extern fn smgrwriteback(reln: SMgrRelation, forknum: ForkNumber, blocknum: BlockNumber, nblocks: BlockNumber) void;
pub extern fn smgrnblocks(reln: SMgrRelation, forknum: ForkNumber) BlockNumber;
pub extern fn smgrnblocks_cached(reln: SMgrRelation, forknum: ForkNumber) BlockNumber;
pub extern fn smgrtruncate(reln: SMgrRelation, forknum: [*c]ForkNumber, nforks: c_int, nblocks: [*c]BlockNumber) void;
pub extern fn smgrimmedsync(reln: SMgrRelation, forknum: ForkNumber) void;
pub extern fn AtEOXact_SMgr() void;
pub extern fn ProcessBarrierSmgrRelease() bool;
pub const LockInfo = [*c]LockInfoData;
pub const RelationData = struct_RelationData;
pub const struct_ForeignKeyCacheInfo = extern struct {
    type: NodeTag,
    conoid: Oid,
    conrelid: Oid,
    confrelid: Oid,
    nkeys: c_int,
    conkey: [32]AttrNumber,
    confkey: [32]AttrNumber,
    conpfeqop: [32]Oid,
};
pub const ForeignKeyCacheInfo = struct_ForeignKeyCacheInfo;
pub const struct_AutoVacOpts = extern struct {
    enabled: bool,
    vacuum_threshold: c_int,
    vacuum_ins_threshold: c_int,
    analyze_threshold: c_int,
    vacuum_cost_limit: c_int,
    freeze_min_age: c_int,
    freeze_max_age: c_int,
    freeze_table_age: c_int,
    multixact_freeze_min_age: c_int,
    multixact_freeze_max_age: c_int,
    multixact_freeze_table_age: c_int,
    log_min_duration: c_int,
    vacuum_cost_delay: float8,
    vacuum_scale_factor: float8,
    vacuum_ins_scale_factor: float8,
    analyze_scale_factor: float8,
};
pub const AutoVacOpts = struct_AutoVacOpts;
pub const STDRD_OPTION_VACUUM_INDEX_CLEANUP_AUTO: c_int = 0;
pub const STDRD_OPTION_VACUUM_INDEX_CLEANUP_OFF: c_int = 1;
pub const STDRD_OPTION_VACUUM_INDEX_CLEANUP_ON: c_int = 2;
pub const enum_StdRdOptIndexCleanup = c_uint;
pub const StdRdOptIndexCleanup = enum_StdRdOptIndexCleanup;
pub const struct_StdRdOptions = extern struct {
    vl_len_: int32,
    fillfactor: c_int,
    toast_tuple_target: c_int,
    autovacuum: AutoVacOpts,
    user_catalog_table: bool,
    parallel_workers: c_int,
    vacuum_index_cleanup: StdRdOptIndexCleanup,
    vacuum_truncate: bool,
};
pub const StdRdOptions = struct_StdRdOptions;
pub const VIEW_OPTION_CHECK_OPTION_NOT_SET: c_int = 0;
pub const VIEW_OPTION_CHECK_OPTION_LOCAL: c_int = 1;
pub const VIEW_OPTION_CHECK_OPTION_CASCADED: c_int = 2;
pub const enum_ViewOptCheckOption = c_uint;
pub const ViewOptCheckOption = enum_ViewOptCheckOption;
pub const struct_ViewOptions = extern struct {
    vl_len_: int32,
    security_barrier: bool,
    security_invoker: bool,
    check_option: ViewOptCheckOption,
};
pub const ViewOptions = struct_ViewOptions;
pub fn RelationGetSmgr(arg_rel: Relation) callconv(.C) SMgrRelation {
    var rel = arg_rel;
    if (__builtin_expect(@bitCast(c_long, @as(c_long, @boolToInt(@boolToInt(rel.*.rd_smgr == @ptrCast(SMgrRelation, @alignCast(@import("std").meta.alignment(SMgrRelation), @intToPtr(?*anyopaque, @as(c_int, 0))))) != @as(c_int, 0)))), @bitCast(c_long, @as(c_long, @as(c_int, 0)))) != 0) {
        smgrsetowner(&rel.*.rd_smgr, smgropen(rel.*.rd_locator, rel.*.rd_backend));
    }
    return rel.*.rd_smgr;
}
pub fn RelationCloseSmgr(arg_relation: Relation) callconv(.C) void {
    var relation = arg_relation;
    if (relation.*.rd_smgr != @ptrCast(SMgrRelation, @alignCast(@import("std").meta.alignment(SMgrRelation), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        smgrclose(relation.*.rd_smgr);
    }
    _ = @as(c_int, 1);
}
pub extern fn RelationIncrementReferenceCount(rel: Relation) void;
pub extern fn RelationDecrementReferenceCount(rel: Relation) void;
pub const LOGICAL_REP_MSG_BEGIN: c_int = 66;
pub const LOGICAL_REP_MSG_COMMIT: c_int = 67;
pub const LOGICAL_REP_MSG_ORIGIN: c_int = 79;
pub const LOGICAL_REP_MSG_INSERT: c_int = 73;
pub const LOGICAL_REP_MSG_UPDATE: c_int = 85;
pub const LOGICAL_REP_MSG_DELETE: c_int = 68;
pub const LOGICAL_REP_MSG_TRUNCATE: c_int = 84;
pub const LOGICAL_REP_MSG_RELATION: c_int = 82;
pub const LOGICAL_REP_MSG_TYPE: c_int = 89;
pub const LOGICAL_REP_MSG_MESSAGE: c_int = 77;
pub const LOGICAL_REP_MSG_BEGIN_PREPARE: c_int = 98;
pub const LOGICAL_REP_MSG_PREPARE: c_int = 80;
pub const LOGICAL_REP_MSG_COMMIT_PREPARED: c_int = 75;
pub const LOGICAL_REP_MSG_ROLLBACK_PREPARED: c_int = 114;
pub const LOGICAL_REP_MSG_STREAM_START: c_int = 83;
pub const LOGICAL_REP_MSG_STREAM_STOP: c_int = 69;
pub const LOGICAL_REP_MSG_STREAM_COMMIT: c_int = 99;
pub const LOGICAL_REP_MSG_STREAM_ABORT: c_int = 65;
pub const LOGICAL_REP_MSG_STREAM_PREPARE: c_int = 112;
pub const enum_LogicalRepMsgType = c_uint;
pub const LogicalRepMsgType = enum_LogicalRepMsgType;
pub const struct_LogicalRepTupleData = extern struct {
    colvalues: [*c]StringInfoData,
    colstatus: [*c]u8,
    ncols: c_int,
};
pub const LogicalRepTupleData = struct_LogicalRepTupleData;
pub const LogicalRepRelId = uint32;
pub const struct_LogicalRepRelation = extern struct {
    remoteid: LogicalRepRelId,
    nspname: [*c]u8,
    relname: [*c]u8,
    natts: c_int,
    attnames: [*c][*c]u8,
    atttyps: [*c]Oid,
    replident: u8,
    relkind: u8,
    attkeys: [*c]Bitmapset,
};
pub const LogicalRepRelation = struct_LogicalRepRelation;
pub const struct_LogicalRepTyp = extern struct {
    remoteid: Oid,
    nspname: [*c]u8,
    typname: [*c]u8,
};
pub const LogicalRepTyp = struct_LogicalRepTyp;
pub const struct_LogicalRepBeginData = extern struct {
    final_lsn: XLogRecPtr,
    committime: TimestampTz,
    xid: TransactionId,
};
pub const LogicalRepBeginData = struct_LogicalRepBeginData;
pub const struct_LogicalRepCommitData = extern struct {
    commit_lsn: XLogRecPtr,
    end_lsn: XLogRecPtr,
    committime: TimestampTz,
};
pub const LogicalRepCommitData = struct_LogicalRepCommitData;
pub const struct_LogicalRepPreparedTxnData = extern struct {
    prepare_lsn: XLogRecPtr,
    end_lsn: XLogRecPtr,
    prepare_time: TimestampTz,
    xid: TransactionId,
    gid: [200]u8,
};
pub const LogicalRepPreparedTxnData = struct_LogicalRepPreparedTxnData;
pub const struct_LogicalRepCommitPreparedTxnData = extern struct {
    commit_lsn: XLogRecPtr,
    end_lsn: XLogRecPtr,
    commit_time: TimestampTz,
    xid: TransactionId,
    gid: [200]u8,
};
pub const LogicalRepCommitPreparedTxnData = struct_LogicalRepCommitPreparedTxnData;
pub const struct_LogicalRepRollbackPreparedTxnData = extern struct {
    prepare_end_lsn: XLogRecPtr,
    rollback_end_lsn: XLogRecPtr,
    prepare_time: TimestampTz,
    rollback_time: TimestampTz,
    xid: TransactionId,
    gid: [200]u8,
};
pub const LogicalRepRollbackPreparedTxnData = struct_LogicalRepRollbackPreparedTxnData;
pub const struct_LogicalRepStreamAbortData = extern struct {
    xid: TransactionId,
    subxid: TransactionId,
    abort_lsn: XLogRecPtr,
    abort_time: TimestampTz,
};
pub const LogicalRepStreamAbortData = struct_LogicalRepStreamAbortData;
pub extern fn logicalrep_write_begin(out: StringInfo, txn: [*c]ReorderBufferTXN) void;
pub extern fn logicalrep_read_begin(in: StringInfo, begin_data: [*c]LogicalRepBeginData) void;
pub extern fn logicalrep_write_commit(out: StringInfo, txn: [*c]ReorderBufferTXN, commit_lsn: XLogRecPtr) void;
pub extern fn logicalrep_read_commit(in: StringInfo, commit_data: [*c]LogicalRepCommitData) void;
pub extern fn logicalrep_write_begin_prepare(out: StringInfo, txn: [*c]ReorderBufferTXN) void;
pub extern fn logicalrep_read_begin_prepare(in: StringInfo, begin_data: [*c]LogicalRepPreparedTxnData) void;
pub extern fn logicalrep_write_prepare(out: StringInfo, txn: [*c]ReorderBufferTXN, prepare_lsn: XLogRecPtr) void;
pub extern fn logicalrep_read_prepare(in: StringInfo, prepare_data: [*c]LogicalRepPreparedTxnData) void;
pub extern fn logicalrep_write_commit_prepared(out: StringInfo, txn: [*c]ReorderBufferTXN, commit_lsn: XLogRecPtr) void;
pub extern fn logicalrep_read_commit_prepared(in: StringInfo, prepare_data: [*c]LogicalRepCommitPreparedTxnData) void;
pub extern fn logicalrep_write_rollback_prepared(out: StringInfo, txn: [*c]ReorderBufferTXN, prepare_end_lsn: XLogRecPtr, prepare_time: TimestampTz) void;
pub extern fn logicalrep_read_rollback_prepared(in: StringInfo, rollback_data: [*c]LogicalRepRollbackPreparedTxnData) void;
pub extern fn logicalrep_write_stream_prepare(out: StringInfo, txn: [*c]ReorderBufferTXN, prepare_lsn: XLogRecPtr) void;
pub extern fn logicalrep_read_stream_prepare(in: StringInfo, prepare_data: [*c]LogicalRepPreparedTxnData) void;
pub extern fn logicalrep_write_origin(out: StringInfo, origin: [*c]const u8, origin_lsn: XLogRecPtr) void;
pub extern fn logicalrep_read_origin(in: StringInfo, origin_lsn: [*c]XLogRecPtr) [*c]u8;
pub extern fn logicalrep_write_insert(out: StringInfo, xid: TransactionId, rel: Relation, newslot: [*c]TupleTableSlot, binary: bool, columns: [*c]Bitmapset) void;
pub extern fn logicalrep_read_insert(in: StringInfo, newtup: [*c]LogicalRepTupleData) LogicalRepRelId;
pub extern fn logicalrep_write_update(out: StringInfo, xid: TransactionId, rel: Relation, oldslot: [*c]TupleTableSlot, newslot: [*c]TupleTableSlot, binary: bool, columns: [*c]Bitmapset) void;
pub extern fn logicalrep_read_update(in: StringInfo, has_oldtuple: [*c]bool, oldtup: [*c]LogicalRepTupleData, newtup: [*c]LogicalRepTupleData) LogicalRepRelId;
pub extern fn logicalrep_write_delete(out: StringInfo, xid: TransactionId, rel: Relation, oldslot: [*c]TupleTableSlot, binary: bool, columns: [*c]Bitmapset) void;
pub extern fn logicalrep_read_delete(in: StringInfo, oldtup: [*c]LogicalRepTupleData) LogicalRepRelId;
pub extern fn logicalrep_write_truncate(out: StringInfo, xid: TransactionId, nrelids: c_int, relids: [*c]Oid, cascade: bool, restart_seqs: bool) void;
pub extern fn logicalrep_read_truncate(in: StringInfo, cascade: [*c]bool, restart_seqs: [*c]bool) [*c]List;
pub extern fn logicalrep_write_message(out: StringInfo, xid: TransactionId, lsn: XLogRecPtr, transactional: bool, prefix: [*c]const u8, sz: Size, message: [*c]const u8) void;
pub extern fn logicalrep_write_rel(out: StringInfo, xid: TransactionId, rel: Relation, columns: [*c]Bitmapset) void;
pub extern fn logicalrep_read_rel(in: StringInfo) [*c]LogicalRepRelation;
pub extern fn logicalrep_write_typ(out: StringInfo, xid: TransactionId, typoid: Oid) void;
pub extern fn logicalrep_read_typ(in: StringInfo, ltyp: [*c]LogicalRepTyp) void;
pub extern fn logicalrep_write_stream_start(out: StringInfo, xid: TransactionId, first_segment: bool) void;
pub extern fn logicalrep_read_stream_start(in: StringInfo, first_segment: [*c]bool) TransactionId;
pub extern fn logicalrep_write_stream_stop(out: StringInfo) void;
pub extern fn logicalrep_write_stream_commit(out: StringInfo, txn: [*c]ReorderBufferTXN, commit_lsn: XLogRecPtr) void;
pub extern fn logicalrep_read_stream_commit(in: StringInfo, commit_data: [*c]LogicalRepCommitData) TransactionId;
pub extern fn logicalrep_write_stream_abort(out: StringInfo, xid: TransactionId, subxid: TransactionId, abort_lsn: XLogRecPtr, abort_time: TimestampTz, write_abort_info: bool) void;
pub extern fn logicalrep_read_stream_abort(in: StringInfo, abort_data: [*c]LogicalRepStreamAbortData, read_abort_info: bool) void;
pub extern fn logicalrep_message_type(action: LogicalRepMsgType) [*c]u8;
pub const CRS_EXPORT_SNAPSHOT: c_int = 0;
pub const CRS_NOEXPORT_SNAPSHOT: c_int = 1;
pub const CRS_USE_SNAPSHOT: c_int = 2;
pub const CRSSnapshotAction = c_uint;
pub extern var am_walsender: bool;
pub extern var am_cascading_walsender: bool;
pub extern var am_db_walsender: bool;
pub extern var wake_wal_senders: bool;
pub extern var max_wal_senders: c_int;
pub extern var wal_sender_timeout: c_int;
pub extern var log_replication_commands: bool;
pub extern fn InitWalSender() void;
pub extern fn exec_replication_command(cmd_string: [*c]const u8) bool;
pub extern fn WalSndErrorCleanup() void;
pub extern fn WalSndResourceCleanup(isCommit: bool) void;
pub extern fn WalSndSignals() void;
pub extern fn WalSndShmemSize() Size;
pub extern fn WalSndShmemInit() void;
pub extern fn WalSndWakeup(physical: bool, logical: bool) void;
pub extern fn WalSndInitStopping() void;
pub extern fn WalSndWaitStopping() void;
pub extern fn HandleWalSndInitStopping() void;
pub extern fn WalSndRqstFileReload() void;
pub fn WalSndWakeupProcessRequests(arg_physical: bool, arg_logical: bool) callconv(.C) void {
    var physical = arg_physical;
    var logical = arg_logical;
    if (wake_wal_senders) {
        wake_wal_senders = @as(c_int, 0) != 0;
        if (max_wal_senders > @as(c_int, 0)) {
            WalSndWakeup(physical, logical);
        }
    }
}
pub const struct_Latch = extern struct {
    is_set: sig_atomic_t,
    maybe_sleeping: sig_atomic_t,
    is_shared: bool,
    owner_pid: c_int,
};
pub const Latch = struct_Latch;
pub const struct_WaitEvent = extern struct {
    pos: c_int,
    events: uint32,
    fd: pgsocket,
    user_data: ?*anyopaque,
};
pub const WaitEvent = struct_WaitEvent;
pub const struct_WaitEventSet = opaque {};
pub const WaitEventSet = struct_WaitEventSet;
pub extern fn InitializeLatchSupport() void;
pub extern fn InitLatch(latch: [*c]Latch) void;
pub extern fn InitSharedLatch(latch: [*c]Latch) void;
pub extern fn OwnLatch(latch: [*c]Latch) void;
pub extern fn DisownLatch(latch: [*c]Latch) void;
pub extern fn SetLatch(latch: [*c]Latch) void;
pub extern fn ResetLatch(latch: [*c]Latch) void;
pub extern fn ShutdownLatchSupport() void;
pub extern fn CreateWaitEventSet(context: MemoryContext, nevents: c_int) ?*WaitEventSet;
pub extern fn FreeWaitEventSet(set: ?*WaitEventSet) void;
pub extern fn FreeWaitEventSetAfterFork(set: ?*WaitEventSet) void;
pub extern fn AddWaitEventToSet(set: ?*WaitEventSet, events: uint32, fd: pgsocket, latch: [*c]Latch, user_data: ?*anyopaque) c_int;
pub extern fn ModifyWaitEvent(set: ?*WaitEventSet, pos: c_int, events: uint32, latch: [*c]Latch) void;
pub extern fn WaitEventSetWait(set: ?*WaitEventSet, timeout: c_long, occurred_events: [*c]WaitEvent, nevents: c_int, wait_event_info: uint32) c_int;
pub extern fn WaitLatch(latch: [*c]Latch, wakeEvents: c_int, timeout: c_long, wait_event_info: uint32) c_int;
pub extern fn WaitLatchOrSocket(latch: [*c]Latch, wakeEvents: c_int, sock: pgsocket, timeout: c_long, wait_event_info: uint32) c_int;
pub extern fn InitializeLatchWaitSet() void;
pub extern fn GetNumRegisteredWaitEvents(set: ?*WaitEventSet) c_int;
pub extern fn WaitEventSetCanReportClosed() bool;
pub const struct_Tuplestorestate = opaque {};
pub const Tuplestorestate = struct_Tuplestorestate;
pub extern fn tuplestore_begin_heap(randomAccess: bool, interXact: bool, maxKBytes: c_int) ?*Tuplestorestate;
pub extern fn tuplestore_set_eflags(state: ?*Tuplestorestate, eflags: c_int) void;
pub extern fn tuplestore_puttupleslot(state: ?*Tuplestorestate, slot: [*c]TupleTableSlot) void;
pub extern fn tuplestore_puttuple(state: ?*Tuplestorestate, tuple: HeapTuple) void;
pub extern fn tuplestore_putvalues(state: ?*Tuplestorestate, tdesc: TupleDesc, values: [*c]Datum, isnull: [*c]bool) void;
pub extern fn tuplestore_alloc_read_pointer(state: ?*Tuplestorestate, eflags: c_int) c_int;
pub extern fn tuplestore_select_read_pointer(state: ?*Tuplestorestate, ptr: c_int) void;
pub extern fn tuplestore_copy_read_pointer(state: ?*Tuplestorestate, srcptr: c_int, destptr: c_int) void;
pub extern fn tuplestore_trim(state: ?*Tuplestorestate) void;
pub extern fn tuplestore_in_memory(state: ?*Tuplestorestate) bool;
pub extern fn tuplestore_gettupleslot(state: ?*Tuplestorestate, forward: bool, copy: bool, slot: [*c]TupleTableSlot) bool;
pub extern fn tuplestore_advance(state: ?*Tuplestorestate, forward: bool) bool;
pub extern fn tuplestore_skiptuples(state: ?*Tuplestorestate, ntuples: int64, forward: bool) bool;
pub extern fn tuplestore_tuple_count(state: ?*Tuplestorestate) int64;
pub extern fn tuplestore_ateof(state: ?*Tuplestorestate) bool;
pub extern fn tuplestore_rescan(state: ?*Tuplestorestate) void;
pub extern fn tuplestore_clear(state: ?*Tuplestorestate) void;
pub extern fn tuplestore_end(state: ?*Tuplestorestate) void;
pub extern var wal_receiver_status_interval: c_int;
pub extern var wal_receiver_timeout: c_int;
pub extern var hot_standby_feedback: bool;
pub const WALRCV_STOPPED: c_int = 0;
pub const WALRCV_STARTING: c_int = 1;
pub const WALRCV_STREAMING: c_int = 2;
pub const WALRCV_WAITING: c_int = 3;
pub const WALRCV_RESTARTING: c_int = 4;
pub const WALRCV_STOPPING: c_int = 5;
pub const WalRcvState = c_uint;
pub const WalRcvData = extern struct {
    pid: pid_t,
    walRcvState: WalRcvState,
    walRcvStoppedCV: ConditionVariable,
    startTime: pg_time_t,
    receiveStart: XLogRecPtr,
    receiveStartTLI: TimeLineID,
    flushedUpto: XLogRecPtr,
    receivedTLI: TimeLineID,
    latestChunkStart: XLogRecPtr,
    lastMsgSendTime: TimestampTz,
    lastMsgReceiptTime: TimestampTz,
    latestWalEnd: XLogRecPtr,
    latestWalEndTime: TimestampTz,
    conninfo: [1024]u8,
    sender_host: [1025]u8,
    sender_port: c_int,
    slotname: [64]u8,
    is_temp_slot: bool,
    ready_to_display: bool,
    latch: [*c]Latch,
    mutex: slock_t,
    writtenUpto: pg_atomic_uint64,
    force_reply: sig_atomic_t,
};
pub extern var WalRcv: [*c]WalRcvData;
const struct_unnamed_51 = extern struct {
    startpointTLI: TimeLineID,
};
const struct_unnamed_52 = extern struct {
    proto_version: uint32,
    publication_names: [*c]List,
    binary: bool,
    streaming_str: [*c]u8,
    twophase: bool,
    origin: [*c]u8,
};
const union_unnamed_50 = extern union {
    physical: struct_unnamed_51,
    logical: struct_unnamed_52,
};
pub const WalRcvStreamOptions = extern struct {
    logical: bool,
    slotname: [*c]u8,
    startpoint: XLogRecPtr,
    proto: union_unnamed_50,
};
pub const struct_WalReceiverConn = opaque {};
pub const WalReceiverConn = struct_WalReceiverConn;
pub const WALRCV_ERROR: c_int = 0;
pub const WALRCV_OK_COMMAND: c_int = 1;
pub const WALRCV_OK_TUPLES: c_int = 2;
pub const WALRCV_OK_COPY_IN: c_int = 3;
pub const WALRCV_OK_COPY_OUT: c_int = 4;
pub const WALRCV_OK_COPY_BOTH: c_int = 5;
pub const WalRcvExecStatus = c_uint;
pub const struct_WalRcvExecResult = extern struct {
    status: WalRcvExecStatus,
    sqlstate: c_int,
    err: [*c]u8,
    tuplestore: ?*Tuplestorestate,
    tupledesc: TupleDesc,
};
pub const WalRcvExecResult = struct_WalRcvExecResult;
pub const walrcv_connect_fn = ?*const fn ([*c]const u8, bool, bool, [*c]const u8, [*c][*c]u8) callconv(.C) ?*WalReceiverConn;
pub const walrcv_check_conninfo_fn = ?*const fn ([*c]const u8, bool) callconv(.C) void;
pub const walrcv_get_conninfo_fn = ?*const fn (?*WalReceiverConn) callconv(.C) [*c]u8;
pub const walrcv_get_senderinfo_fn = ?*const fn (?*WalReceiverConn, [*c][*c]u8, [*c]c_int) callconv(.C) void;
pub const walrcv_identify_system_fn = ?*const fn (?*WalReceiverConn, [*c]TimeLineID) callconv(.C) [*c]u8;
pub const walrcv_server_version_fn = ?*const fn (?*WalReceiverConn) callconv(.C) c_int;
pub const walrcv_readtimelinehistoryfile_fn = ?*const fn (?*WalReceiverConn, TimeLineID, [*c][*c]u8, [*c][*c]u8, [*c]c_int) callconv(.C) void;
pub const walrcv_startstreaming_fn = ?*const fn (?*WalReceiverConn, [*c]const WalRcvStreamOptions) callconv(.C) bool;
pub const walrcv_endstreaming_fn = ?*const fn (?*WalReceiverConn, [*c]TimeLineID) callconv(.C) void;
pub const walrcv_receive_fn = ?*const fn (?*WalReceiverConn, [*c][*c]u8, [*c]pgsocket) callconv(.C) c_int;
pub const walrcv_send_fn = ?*const fn (?*WalReceiverConn, [*c]const u8, c_int) callconv(.C) void;
pub const walrcv_create_slot_fn = ?*const fn (?*WalReceiverConn, [*c]const u8, bool, bool, CRSSnapshotAction, [*c]XLogRecPtr) callconv(.C) [*c]u8;
pub const walrcv_get_backend_pid_fn = ?*const fn (?*WalReceiverConn) callconv(.C) pid_t;
pub const walrcv_exec_fn = ?*const fn (?*WalReceiverConn, [*c]const u8, c_int, [*c]const Oid) callconv(.C) [*c]WalRcvExecResult;
pub const walrcv_disconnect_fn = ?*const fn (?*WalReceiverConn) callconv(.C) void;
pub const struct_WalReceiverFunctionsType = extern struct {
    walrcv_connect: walrcv_connect_fn,
    walrcv_check_conninfo: walrcv_check_conninfo_fn,
    walrcv_get_conninfo: walrcv_get_conninfo_fn,
    walrcv_get_senderinfo: walrcv_get_senderinfo_fn,
    walrcv_identify_system: walrcv_identify_system_fn,
    walrcv_server_version: walrcv_server_version_fn,
    walrcv_readtimelinehistoryfile: walrcv_readtimelinehistoryfile_fn,
    walrcv_startstreaming: walrcv_startstreaming_fn,
    walrcv_endstreaming: walrcv_endstreaming_fn,
    walrcv_receive: walrcv_receive_fn,
    walrcv_send: walrcv_send_fn,
    walrcv_create_slot: walrcv_create_slot_fn,
    walrcv_get_backend_pid: walrcv_get_backend_pid_fn,
    walrcv_exec: walrcv_exec_fn,
    walrcv_disconnect: walrcv_disconnect_fn,
};
pub const WalReceiverFunctionsType = struct_WalReceiverFunctionsType;
pub extern var WalReceiverFunctions: [*c]WalReceiverFunctionsType;
pub fn walrcv_clear_result(arg_walres: [*c]WalRcvExecResult) callconv(.C) void {
    var walres = arg_walres;
    if (!(walres != null)) return;
    if (walres.*.err != null) {
        pfree(@ptrCast(?*anyopaque, walres.*.err));
    }
    if (walres.*.tuplestore != null) {
        tuplestore_end(walres.*.tuplestore);
    }
    if (walres.*.tupledesc != null) {
        FreeTupleDesc(walres.*.tupledesc);
    }
    pfree(@ptrCast(?*anyopaque, walres));
}
pub extern fn WalReceiverMain() noreturn;
pub extern fn ProcessWalRcvInterrupts() void;
pub extern fn WalRcvForceReply() void;
pub extern fn WalRcvShmemSize() Size;
pub extern fn WalRcvShmemInit() void;
pub extern fn ShutdownWalRcv() void;
pub extern fn WalRcvStreaming() bool;
pub extern fn WalRcvRunning() bool;
pub extern fn RequestXLogStreaming(tli: TimeLineID, recptr: XLogRecPtr, conninfo: [*c]const u8, slotname: [*c]const u8, create_temp_slot: bool) void;
pub extern fn GetWalRcvFlushRecPtr(latestChunkStart: [*c]XLogRecPtr, receiveTLI: [*c]TimeLineID) XLogRecPtr;
pub extern fn GetWalRcvWriteRecPtr() XLogRecPtr;
pub extern fn GetReplicationApplyDelay() c_int;
pub extern fn GetReplicationTransferLatency() c_int;
pub const struct_ReplicationSlotCtlData = extern struct {
    replication_slots: [1]ReplicationSlot,
};
pub const ReplicationSlotCtlData = struct_ReplicationSlotCtlData;
pub extern var ReplicationSlotCtl: [*c]ReplicationSlotCtlData;
pub extern var MyReplicationSlot: [*c]ReplicationSlot;
pub extern var max_replication_slots: c_int;
pub extern fn ReplicationSlotsShmemSize() Size;
pub extern fn ReplicationSlotsShmemInit() void;
pub extern fn ReplicationSlotCreate(name: [*c]const u8, db_specific: bool, persistency: ReplicationSlotPersistency, two_phase: bool) void;
pub extern fn ReplicationSlotPersist() void;
pub extern fn ReplicationSlotDrop(name: [*c]const u8, nowait: bool) void;
pub extern fn ReplicationSlotAcquire(name: [*c]const u8, nowait: bool) void;
pub extern fn ReplicationSlotRelease() void;
pub extern fn ReplicationSlotCleanup() void;
pub extern fn ReplicationSlotSave() void;
pub extern fn ReplicationSlotMarkDirty() void;
pub extern fn ReplicationSlotInitialize() void;
pub extern fn ReplicationSlotValidateName(name: [*c]const u8, elevel: c_int) bool;
pub extern fn ReplicationSlotReserveWal() void;
pub extern fn ReplicationSlotsComputeRequiredXmin(already_locked: bool) void;
pub extern fn ReplicationSlotsComputeRequiredLSN() void;
pub extern fn ReplicationSlotsComputeLogicalRestartLSN() XLogRecPtr;
pub extern fn ReplicationSlotsCountDBSlots(dboid: Oid, nslots: [*c]c_int, nactive: [*c]c_int) bool;
pub extern fn ReplicationSlotsDropDBSlots(dboid: Oid) void;
pub extern fn InvalidateObsoleteReplicationSlots(cause: ReplicationSlotInvalidationCause, oldestSegno: XLogSegNo, dboid: Oid, snapshotConflictHorizon: TransactionId) bool;
pub extern fn SearchNamedReplicationSlot(name: [*c]const u8, need_lock: bool) [*c]ReplicationSlot;
pub extern fn ReplicationSlotIndex(slot: [*c]ReplicationSlot) c_int;
pub extern fn ReplicationSlotName(index: c_int, name: Name) bool;
pub extern fn ReplicationSlotNameForTablesync(suboid: Oid, relid: Oid, syncslotname: [*c]u8, szslot: Size) void;
pub extern fn ReplicationSlotDropAtPubNode(wrconn: ?*WalReceiverConn, slotname: [*c]u8, missing_ok: bool) void;
pub extern fn StartupReplicationSlots() void;
pub extern fn CheckPointReplicationSlots() void;
pub extern fn CheckSlotRequirements() void;
pub extern fn CheckSlotPermissions() void;
pub const LogicalDecodingContext = struct_LogicalDecodingContext;
pub extern fn CheckLogicalDecodingRequirements() void;
pub extern fn CreateInitDecodingContext(plugin: [*c]const u8, output_plugin_options: [*c]List, need_full_snapshot: bool, restart_lsn: XLogRecPtr, xl_routine: [*c]XLogReaderRoutine, prepare_write: LogicalOutputPluginWriterPrepareWrite, do_write: LogicalOutputPluginWriterWrite, update_progress: LogicalOutputPluginWriterUpdateProgress) [*c]LogicalDecodingContext;
pub extern fn CreateDecodingContext(start_lsn: XLogRecPtr, output_plugin_options: [*c]List, fast_forward: bool, xl_routine: [*c]XLogReaderRoutine, prepare_write: LogicalOutputPluginWriterPrepareWrite, do_write: LogicalOutputPluginWriterWrite, update_progress: LogicalOutputPluginWriterUpdateProgress) [*c]LogicalDecodingContext;
pub extern fn DecodingContextFindStartpoint(ctx: [*c]LogicalDecodingContext) void;
pub extern fn DecodingContextReady(ctx: [*c]LogicalDecodingContext) bool;
pub extern fn FreeDecodingContext(ctx: [*c]LogicalDecodingContext) void;
pub extern fn LogicalIncreaseXminForSlot(current_lsn: XLogRecPtr, xmin: TransactionId) void;
pub extern fn LogicalIncreaseRestartDecodingForSlot(current_lsn: XLogRecPtr, restart_lsn: XLogRecPtr) void;
pub extern fn LogicalConfirmReceivedLocation(lsn: XLogRecPtr) void;
pub extern fn filter_prepare_cb_wrapper(ctx: [*c]LogicalDecodingContext, xid: TransactionId, gid: [*c]const u8) bool;
pub extern fn filter_by_origin_cb_wrapper(ctx: [*c]LogicalDecodingContext, origin_id: RepOriginId) bool;
pub extern fn ResetLogicalStreamingState() void;
pub extern fn UpdateDecodingStats(ctx: [*c]LogicalDecodingContext) void;
pub const struct_FormData_pg_replication_origin = extern struct {
    roident: Oid,
    roname: text,
};
pub const FormData_pg_replication_origin = struct_FormData_pg_replication_origin;
pub const Form_pg_replication_origin = [*c]FormData_pg_replication_origin;
pub const struct_xl_replorigin_set = extern struct {
    remote_lsn: XLogRecPtr,
    node_id: RepOriginId,
    force: bool,
};
pub const xl_replorigin_set = struct_xl_replorigin_set;
pub const struct_xl_replorigin_drop = extern struct {
    node_id: RepOriginId,
};
pub const xl_replorigin_drop = struct_xl_replorigin_drop;
pub extern var replorigin_session_origin: RepOriginId;
pub extern var replorigin_session_origin_lsn: XLogRecPtr;
pub extern var replorigin_session_origin_timestamp: TimestampTz;
pub extern fn replorigin_by_name(roname: [*c]const u8, missing_ok: bool) RepOriginId;
pub extern fn replorigin_create(roname: [*c]const u8) RepOriginId;
pub extern fn replorigin_drop_by_name(name: [*c]const u8, missing_ok: bool, nowait: bool) void;
pub extern fn replorigin_by_oid(roident: RepOriginId, missing_ok: bool, roname: [*c][*c]u8) bool;
pub extern fn replorigin_advance(node: RepOriginId, remote_commit: XLogRecPtr, local_commit: XLogRecPtr, go_backward: bool, wal_log: bool) void;
pub extern fn replorigin_get_progress(node: RepOriginId, flush: bool) XLogRecPtr;
pub extern fn replorigin_session_advance(remote_commit: XLogRecPtr, local_commit: XLogRecPtr) void;
pub extern fn replorigin_session_setup(node: RepOriginId, acquired_by: c_int) void;
pub extern fn replorigin_session_reset() void;
pub extern fn replorigin_session_get_progress(flush: bool) XLogRecPtr;
pub extern fn CheckPointReplicationOrigin() void;
pub extern fn StartupReplicationOrigin() void;
pub extern fn replorigin_redo(record: [*c]XLogReaderState) void;
pub extern fn replorigin_desc(buf: StringInfo, record: [*c]XLogReaderState) void;
pub extern fn replorigin_identify(info: uint8) [*c]const u8;
pub extern fn ReplicationOriginShmemSize() Size;
pub extern fn ReplicationOriginShmemInit() void;
pub extern fn heap_tableam_handler(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaout(fcinfo: FunctionCallInfo) Datum;
pub extern fn charout(fcinfo: FunctionCallInfo) Datum;
pub extern fn namein(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameout(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2in(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2out(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2vectorin(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2vectorout(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4in(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4out(fcinfo: FunctionCallInfo) Datum;
pub extern fn regprocin(fcinfo: FunctionCallInfo) Datum;
pub extern fn regprocout(fcinfo: FunctionCallInfo) Datum;
pub extern fn textin(fcinfo: FunctionCallInfo) Datum;
pub extern fn textout(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidin(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidout(fcinfo: FunctionCallInfo) Datum;
pub extern fn xidin(fcinfo: FunctionCallInfo) Datum;
pub extern fn xidout(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidin(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidout(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorin(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorout(fcinfo: FunctionCallInfo) Datum;
pub extern fn boollt(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolgt(fcinfo: FunctionCallInfo) Datum;
pub extern fn booleq(fcinfo: FunctionCallInfo) Datum;
pub extern fn chareq(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameeq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn texteq(fcinfo: FunctionCallInfo) Datum;
pub extern fn xideq(fcinfo: FunctionCallInfo) Datum;
pub extern fn cideq(fcinfo: FunctionCallInfo) Datum;
pub extern fn charne(fcinfo: FunctionCallInfo) Datum;
pub extern fn charle(fcinfo: FunctionCallInfo) Datum;
pub extern fn chargt(fcinfo: FunctionCallInfo) Datum;
pub extern fn charge(fcinfo: FunctionCallInfo) Datum;
pub extern fn chartoi4(fcinfo: FunctionCallInfo) Datum;
pub extern fn i4tochar(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameregexeq(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolne(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ddl_command_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ddl_command_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ddl_command_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn pgsql_version(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ddl_command_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn eqsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn neqsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn scalarltsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn scalargtsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn eqjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn neqjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn scalarltjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn scalargtjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn unknownin(fcinfo: FunctionCallInfo) Datum;
pub extern fn unknownout(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_above_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_below_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_overlap(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_above(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_left(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_right(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_below(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn on_pb(fcinfo: FunctionCallInfo) Datum;
pub extern fn on_ppath(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_center(fcinfo: FunctionCallInfo) Datum;
pub extern fn areasel(fcinfo: FunctionCallInfo) Datum;
pub extern fn areajoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2div(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4div(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2mod(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4mod(fcinfo: FunctionCallInfo) Datum;
pub extern fn textne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24div(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42div(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn int24mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn int42mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn oideq(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidne(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_same(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_contain(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_left(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_overleft(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_overright(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_right(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_contained(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_contain_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_node_tree_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_node_tree_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_node_tree_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_node_tree_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4in(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4out(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4div(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4um(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4abs(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4um(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2um(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8in(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8out(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8div(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8um(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8abs(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_center(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_center(fcinfo: FunctionCallInfo) Datum;
pub extern fn dround(fcinfo: FunctionCallInfo) Datum;
pub extern fn dtrunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsqrt(fcinfo: FunctionCallInfo) Datum;
pub extern fn dcbrt(fcinfo: FunctionCallInfo) Datum;
pub extern fn dpow(fcinfo: FunctionCallInfo) Datum;
pub extern fn dexp(fcinfo: FunctionCallInfo) Datum;
pub extern fn dlog1(fcinfo: FunctionCallInfo) Datum;
pub extern fn i2tod(fcinfo: FunctionCallInfo) Datum;
pub extern fn i2tof(fcinfo: FunctionCallInfo) Datum;
pub extern fn dtoi2(fcinfo: FunctionCallInfo) Datum;
pub extern fn ftoi2(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameeqtext(fcinfo: FunctionCallInfo) Datum;
pub extern fn namelttext(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameletext(fcinfo: FunctionCallInfo) Datum;
pub extern fn namegetext(fcinfo: FunctionCallInfo) Datum;
pub extern fn namegttext(fcinfo: FunctionCallInfo) Datum;
pub extern fn namenetext(fcinfo: FunctionCallInfo) Datum;
pub extern fn btnametextcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn texteqname(fcinfo: FunctionCallInfo) Datum;
pub extern fn textltname(fcinfo: FunctionCallInfo) Datum;
pub extern fn textlename(fcinfo: FunctionCallInfo) Datum;
pub extern fn textgename(fcinfo: FunctionCallInfo) Datum;
pub extern fn textgtname(fcinfo: FunctionCallInfo) Datum;
pub extern fn textnename(fcinfo: FunctionCallInfo) Datum;
pub extern fn bttextnamecmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameconcatoid(fcinfo: FunctionCallInfo) Datum;
pub extern fn table_am_handler_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn table_am_handler_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn timeofday(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_nextoid(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn inter_sl(fcinfo: FunctionCallInfo) Datum;
pub extern fn inter_lb(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48div(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84div(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4le(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8le(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48le(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float48ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84le(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float84ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn ftod(fcinfo: FunctionCallInfo) Datum;
pub extern fn dtof(fcinfo: FunctionCallInfo) Datum;
pub extern fn i2toi4(fcinfo: FunctionCallInfo) Datum;
pub extern fn i4toi2(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_jit_available(fcinfo: FunctionCallInfo) Datum;
pub extern fn i4tod(fcinfo: FunctionCallInfo) Datum;
pub extern fn dtoi4(fcinfo: FunctionCallInfo) Datum;
pub extern fn i4tof(fcinfo: FunctionCallInfo) Datum;
pub extern fn ftoi4(fcinfo: FunctionCallInfo) Datum;
pub extern fn width_bucket_float8(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn index_am_handler_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn index_am_handler_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashmacaddr8(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_aclitem(fcinfo: FunctionCallInfo) Datum;
pub extern fn bthandler(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashhandler(fcinfo: FunctionCallInfo) Datum;
pub extern fn gisthandler(fcinfo: FunctionCallInfo) Datum;
pub extern fn ginhandler(fcinfo: FunctionCallInfo) Datum;
pub extern fn spghandler(fcinfo: FunctionCallInfo) Datum;
pub extern fn brinhandler(fcinfo: FunctionCallInfo) Datum;
pub extern fn scalarlesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn scalargesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn amvalidate(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_same(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_contain(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_left(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_overleft(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_overright(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_right(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_contained(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_overlap(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint2cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint4cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btfloat4cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btfloat8cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btoidcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_bp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btcharcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btnamecmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn bttextcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_interpt(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_ps(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_pb(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_sb(fcinfo: FunctionCallInfo) Datum;
pub extern fn close_ps(fcinfo: FunctionCallInfo) Datum;
pub extern fn close_pb(fcinfo: FunctionCallInfo) Datum;
pub extern fn close_sb(fcinfo: FunctionCallInfo) Datum;
pub extern fn on_ps(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_ppath(fcinfo: FunctionCallInfo) Datum;
pub extern fn on_sb(fcinfo: FunctionCallInfo) Datum;
pub extern fn inter_sb(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_to_array_null(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_append(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_prepend(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_sp(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_bs(fcinfo: FunctionCallInfo) Datum;
pub extern fn btarraycmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_cat(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_to_text_null(fcinfo: FunctionCallInfo) Datum;
pub extern fn scalarlejoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_to_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_to_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn scalargejoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashmacaddr(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashtext(fcinfo: FunctionCallInfo) Datum;
pub extern fn rtrim1(fcinfo: FunctionCallInfo) Datum;
pub extern fn btoidvectorcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn name_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn name_bpchar(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_pathp(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashinet(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashint4extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_num_nulls(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_num_nonnulls(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashint2extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashint8extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashfloat4extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashfloat8extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashoidextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashcharextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashnameextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashtextextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashint2(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashint4(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashfloat4(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashfloat8(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashoid(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashchar(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashname(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashvarlena(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashoidvector(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8in(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8out(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8um(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8div(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48(fcinfo: FunctionCallInfo) Datum;
pub extern fn i8tod(fcinfo: FunctionCallInfo) Datum;
pub extern fn dtoi8(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_abbrev(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidr_abbrev(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_set_masklen(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorne(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidr_set_masklen(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_indexam_has_property(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_index_has_property(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_index_column_has_property(fcinfo: FunctionCallInfo) Datum;
pub extern fn i8tof(fcinfo: FunctionCallInfo) Datum;
pub extern fn ftoi8(fcinfo: FunctionCallInfo) Datum;
pub extern fn namelt(fcinfo: FunctionCallInfo) Datum;
pub extern fn namele(fcinfo: FunctionCallInfo) Datum;
pub extern fn namegt(fcinfo: FunctionCallInfo) Datum;
pub extern fn namege(fcinfo: FunctionCallInfo) Datum;
pub extern fn namene(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar(fcinfo: FunctionCallInfo) Datum;
pub extern fn varchar(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_indexam_progress_phasename(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorlt(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorle(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectoreq(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorge(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorgt(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_network(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_netmask(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_masklen(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_broadcast(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_host(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_lp(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_ls(fcinfo: FunctionCallInfo) Datum;
pub extern fn current_user(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_family(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_create(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidlt(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidle(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaoctetlen(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaGetByte(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaSetByte(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaGetBit(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaSetBit(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_sl(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_cpoly(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_show(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn session_user(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_dims(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_ndims(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaoverlay(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaoverlay_no_len(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_trunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_import(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_export(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4inc(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_import_with_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashvarlenaextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashoidvectorextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_aclitem_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashmacaddrextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashinetextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_numeric_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashmacaddr8extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_array_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_polyc(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_client_encoding(fcinfo: FunctionCallInfo) Datum;
pub extern fn current_query(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82div(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint8cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_mul_flt4(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_div_flt4(fcinfo: FunctionCallInfo) Datum;
pub extern fn flt4_mul_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn textpos(fcinfo: FunctionCallInfo) Datum;
pub extern fn textlike(fcinfo: FunctionCallInfo) Datum;
pub extern fn textnlike(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn namelike(fcinfo: FunctionCallInfo) Datum;
pub extern fn namenlike(fcinfo: FunctionCallInfo) Datum;
pub extern fn char_bpchar(fcinfo: FunctionCallInfo) Datum;
pub extern fn current_database(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_mul_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2_mul_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_mul_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_div_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_mul_int2(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_div_int2(fcinfo: FunctionCallInfo) Datum;
pub extern fn lower(fcinfo: FunctionCallInfo) Datum;
pub extern fn upper(fcinfo: FunctionCallInfo) Datum;
pub extern fn initcap(fcinfo: FunctionCallInfo) Datum;
pub extern fn lpad(fcinfo: FunctionCallInfo) Datum;
pub extern fn rpad(fcinfo: FunctionCallInfo) Datum;
pub extern fn ltrim(fcinfo: FunctionCallInfo) Datum;
pub extern fn rtrim(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_substr(fcinfo: FunctionCallInfo) Datum;
pub extern fn translate(fcinfo: FunctionCallInfo) Datum;
pub extern fn ltrim1(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_substr_no_len(fcinfo: FunctionCallInfo) Datum;
pub extern fn btrim(fcinfo: FunctionCallInfo) Datum;
pub extern fn btrim1(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_mul_flt8(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_div_flt8(fcinfo: FunctionCallInfo) Datum;
pub extern fn cashlarger(fcinfo: FunctionCallInfo) Datum;
pub extern fn cashsmaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn flt8_mul_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_sub(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_subeq(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_sup(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_supeq(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_words(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8mod(fcinfo: FunctionCallInfo) Datum;
pub extern fn char_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28div(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashint8(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_open(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_close(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_loread(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lowrite(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_lseek(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_creat(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_tell(fcinfo: FunctionCallInfo) Datum;
pub extern fn on_pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn on_sl(fcinfo: FunctionCallInfo) Datum;
pub extern fn close_pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_unlink(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashbpcharextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_inter(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_area(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_width(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_height(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_area(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_intersect(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_diagonal(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_n_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_n_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_n_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_n_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_n_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_length(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_vert(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_horiz(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_slope(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_construct(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_intersect(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_parallel(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_perp(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_vertical(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_horizontal(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_truncate(fcinfo: FunctionCallInfo) Datum;
pub extern fn textlike_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn texticregexeq_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn texticlike_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_izone(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_point_compress(fcinfo: FunctionCallInfo) Datum;
pub extern fn aclitemin(fcinfo: FunctionCallInfo) Datum;
pub extern fn aclitemout(fcinfo: FunctionCallInfo) Datum;
pub extern fn aclinsert(fcinfo: FunctionCallInfo) Datum;
pub extern fn aclremove(fcinfo: FunctionCallInfo) Datum;
pub extern fn aclcontains(fcinfo: FunctionCallInfo) Datum;
pub extern fn getdatabaseencoding(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharin(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharout(fcinfo: FunctionCallInfo) Datum;
pub extern fn varcharin(fcinfo: FunctionCallInfo) Datum;
pub extern fn varcharout(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchareq(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharlt(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharle(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchargt(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharge(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharne(fcinfo: FunctionCallInfo) Datum;
pub extern fn aclitem_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_prepared_xact(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_step_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_step_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_regclass(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashbpchar(fcinfo: FunctionCallInfo) Datum;
pub extern fn format_type(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_wal(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_wal_replay_pause_state(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_pli(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_mii(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_add_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_sub_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_mul_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_div_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_zone(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_um(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_part(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_part(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_subset_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_justify_hours(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_exists_tz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_query_tz(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_query_array_tz(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid_age(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_pl_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_mi_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_subscripts(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_subscripts_nodir(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_fill(fcinfo: FunctionCallInfo) Datum;
pub extern fn dlog10(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_age(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_scale(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_trunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_trunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8inc(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8abs(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn texticregexeq(fcinfo: FunctionCallInfo) Datum;
pub extern fn texticregexne(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameicregexeq(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameicregexne(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolin(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolout(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteain(fcinfo: FunctionCallInfo) Datum;
pub extern fn charin(fcinfo: FunctionCallInfo) Datum;
pub extern fn charlt(fcinfo: FunctionCallInfo) Datum;
pub extern fn unique_key_recheck(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4abs(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameregexne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2abs(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexeq(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexne(fcinfo: FunctionCallInfo) Datum;
pub extern fn textlen(fcinfo: FunctionCallInfo) Datum;
pub extern fn textcat(fcinfo: FunctionCallInfo) Datum;
pub extern fn PG_char_to_encoding(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidne(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidr_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn parse_ident(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_column_size(fcinfo: FunctionCallInfo) Datum;
pub extern fn overlaps_timetz(fcinfo: FunctionCallInfo) Datum;
pub extern fn datetime_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_part(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn int84div(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48pl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn int48div(fcinfo: FunctionCallInfo) Datum;
pub extern fn quote_ident(fcinfo: FunctionCallInfo) Datum;
pub extern fn quote_literal(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_trunc_zone(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_fill_with_lower_bounds(fcinfo: FunctionCallInfo) Datum;
pub extern fn i8tooid(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidtoi8(fcinfo: FunctionCallInfo) Datum;
pub extern fn quote_nullable(fcinfo: FunctionCallInfo) Datum;
pub extern fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo) Datum;
pub extern fn tideq(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_unnest(fcinfo: FunctionCallInfo) Datum;
pub extern fn currtid_byrelname(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_justify_days(fcinfo: FunctionCallInfo) Datum;
pub extern fn datetimetz_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn now(fcinfo: FunctionCallInfo) Datum;
pub extern fn positionsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn positionjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn contsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn contjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn overlaps_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn overlaps_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharlen(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_div(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectortypes(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_hostmask(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexeq_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn makeaclitem(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lock_status(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_finite(fcinfo: FunctionCallInfo) Datum;
pub extern fn textoctetlen(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharoctetlen(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_fac(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_part(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_constraintdef(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_timetz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_finite(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_finite(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_client_addr(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_client_port(fcinfo: FunctionCallInfo) Datum;
pub extern fn current_schema(fcinfo: FunctionCallInfo) Datum;
pub extern fn current_schemas(fcinfo: FunctionCallInfo) Datum;
pub extern fn textoverlay(fcinfo: FunctionCallInfo) Datum;
pub extern fn textoverlay_no_len(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_parallel(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_perp(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_vertical(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_horizontal(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_center(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn points_box(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_add(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_sub(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_div(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidr_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_contain_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn pt_contained_poly(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_isclosed(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_isopen(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_npoints(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_close(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_open(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_add(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_add_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_sub_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_mul_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_div_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn construct_point(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_add(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_sub(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_div(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_npoints(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_box(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_path(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_poly(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_poly(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_same(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_contain(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_left(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_overleft(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_overright(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_right(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_contained(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_overlap(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_below(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_above(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_area(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_diameter(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_radius(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn cr_circle(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_circle(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_poly(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_pc(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_contain_pt(fcinfo: FunctionCallInfo) Datum;
pub extern fn pt_contained_circle(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_circle(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_box(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_length(fcinfo: FunctionCallInfo) Datum;
pub extern fn close_ls(fcinfo: FunctionCallInfo) Datum;
pub extern fn close_lseg(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_construct_pp(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_interpt(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_intersect(fcinfo: FunctionCallInfo) Datum;
pub extern fn bit_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn bit_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_ruledef(fcinfo: FunctionCallInfo) Datum;
pub extern fn nextval_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn currval_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn setval_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn varbit_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn varbit_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn biteq(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitne(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitge(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitgt(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitle(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitlt(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn PG_encoding_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn drandom(fcinfo: FunctionCallInfo) Datum;
pub extern fn setseed(fcinfo: FunctionCallInfo) Datum;
pub extern fn dasin(fcinfo: FunctionCallInfo) Datum;
pub extern fn dacos(fcinfo: FunctionCallInfo) Datum;
pub extern fn datan(fcinfo: FunctionCallInfo) Datum;
pub extern fn datan2(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsin(fcinfo: FunctionCallInfo) Datum;
pub extern fn dcos(fcinfo: FunctionCallInfo) Datum;
pub extern fn dtan(fcinfo: FunctionCallInfo) Datum;
pub extern fn dcot(fcinfo: FunctionCallInfo) Datum;
pub extern fn degrees(fcinfo: FunctionCallInfo) Datum;
pub extern fn radians(fcinfo: FunctionCallInfo) Datum;
pub extern fn dpi(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_typeof(fcinfo: FunctionCallInfo) Datum;
pub extern fn ascii(fcinfo: FunctionCallInfo) Datum;
pub extern fn chr(fcinfo: FunctionCallInfo) Datum;
pub extern fn repeat(fcinfo: FunctionCallInfo) Datum;
pub extern fn similar_escape(fcinfo: FunctionCallInfo) Datum;
pub extern fn mul_d_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn texticlike(fcinfo: FunctionCallInfo) Datum;
pub extern fn texticnlike(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameiclike(fcinfo: FunctionCallInfo) Datum;
pub extern fn nameicnlike(fcinfo: FunctionCallInfo) Datum;
pub extern fn like_escape(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidgt(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidge(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_viewdef(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_userbyid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_indexdef(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) Datum;
pub extern fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_triggerdef(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) Datum;
pub extern fn bit_and(fcinfo: FunctionCallInfo) Datum;
pub extern fn bit_or(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitxor(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitnot(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitshiftleft(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitshiftright(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitcat(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitsubstr(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitlength(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitoctetlength(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitfromint4(fcinfo: FunctionCallInfo) Datum;
pub extern fn bittoint4(fcinfo: FunctionCallInfo) Datum;
pub extern fn bit(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_keywords(fcinfo: FunctionCallInfo) Datum;
pub extern fn varbit(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_hash(fcinfo: FunctionCallInfo) Datum;
pub extern fn aclexplode(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_mi_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolle(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolge(fcinfo: FunctionCallInfo) Datum;
pub extern fn btboolcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_hash(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_hash(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitposition(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitsubstr_no_len(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_abs(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_sign(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_round(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_trunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_ceil(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_floor(fcinfo: FunctionCallInfo) Datum;
pub extern fn length_in_encoding(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_convert_from(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_to_cidr(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_expr(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_convert_to(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_add(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_sub(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_mul(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_div(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_mod(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_sqrt(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_exp(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_ln(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_log(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_power(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_float4(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_float8(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_pl_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_mi_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_pl_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_mi_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_inc(fcinfo: FunctionCallInfo) Datum;
pub extern fn setval3_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_uminus(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_to_number(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_int2(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidin(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidout(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_convert(fcinfo: FunctionCallInfo) Datum;
pub extern fn iclikesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn icnlikesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn iclikejoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn icnlikejoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexeqsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn likesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn icregexeqsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexnesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn nlikesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn icregexnesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexeqjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn likejoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn icregexeqjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexnejoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn nlikejoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn icregexnejoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_avg(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_var_samp(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_stddev_samp(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_avg(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_var_samp(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_stddev_samp(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2_sum(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_sum(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_sum(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_avg(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_ascii_default(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_ascii_enc(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_ascii_encname(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int28ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82le(fcinfo: FunctionCallInfo) Datum;
pub extern fn int82ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2and(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2or(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2xor(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2not(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2shl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2shr(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4and(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4or(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4xor(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4not(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4shl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4shr(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8and(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8or(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8xor(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8not(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8shl(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8shr(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8up(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2up(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4up(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4up(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8up(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_uplus(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_table_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_table_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_numscans(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_tuples_returned(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_tuples_fetched(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_tuples_inserted(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_tuples_updated(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_tuples_deleted(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_blocks_fetched(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_blocks_hit(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_idset(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_pid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_dbid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_userid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_activity(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_numbackends(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_xact_commit(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_xact_rollback(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_blocks_fetched(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_blocks_hit(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_encode(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_decode(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteaeq(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytealt(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteale(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteagt(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteage(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteane(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteacmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_scale(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2_avg_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_avg_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_avg(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidlarger(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidsmaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_scale(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_scale(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_scale(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_tuples_hot_updated(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_div_trunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn similar_to_escape_2(fcinfo: FunctionCallInfo) Datum;
pub extern fn similar_to_escape_1(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytealike(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteanlike(fcinfo: FunctionCallInfo) Datum;
pub extern fn like_escape_bytea(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteacat(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytea_substr(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytea_substr_no_len(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteapos(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteatrim(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_trunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_part(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_activity(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_query_first_tz(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_backend_pid(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_match_tz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_pl_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_mi_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_conf_load_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_zone(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_izone(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_hash(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_timetz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_to_char(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_age(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_zone(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_izone(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_pl_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_mi_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexsubstr(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitfromint8(fcinfo: FunctionCallInfo) Datum;
pub extern fn bittoint8(fcinfo: FunctionCallInfo) Datum;
pub extern fn show_config_by_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn set_config_by_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_table_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_type_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_function_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_operator_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_opclass_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn show_all_settings(fcinfo: FunctionCallInfo) Datum;
pub extern fn replace_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn split_part(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_hex32(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_hex64(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_lower(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_upper(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_conversion_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_activity_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_terminate_backend(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_functiondef(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_column_compression(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_force_next_flush(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_pattern_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_pattern_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_function_arguments(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_pattern_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_pattern_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_function_result(fcinfo: FunctionCallInfo) Datum;
pub extern fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_database_size_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn width_bucket_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_cancel_backend(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_backup_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar_pattern_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_length(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_point_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint48cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint84cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint24cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint42cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint28cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint82cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btfloat48cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn btfloat84cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_client_addr(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_client_port(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_server_addr(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_server_port(fcinfo: FunctionCallInfo) Datum;
pub extern fn regprocedurein(fcinfo: FunctionCallInfo) Datum;
pub extern fn regprocedureout(fcinfo: FunctionCallInfo) Datum;
pub extern fn regoperin(fcinfo: FunctionCallInfo) Datum;
pub extern fn regoperout(fcinfo: FunctionCallInfo) Datum;
pub extern fn regoperatorin(fcinfo: FunctionCallInfo) Datum;
pub extern fn regoperatorout(fcinfo: FunctionCallInfo) Datum;
pub extern fn regclassin(fcinfo: FunctionCallInfo) Datum;
pub extern fn regclassout(fcinfo: FunctionCallInfo) Datum;
pub extern fn regtypein(fcinfo: FunctionCallInfo) Datum;
pub extern fn regtypeout(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_clear_snapshot(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashtid(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashtidextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn fmgr_internal_validator(fcinfo: FunctionCallInfo) Datum;
pub extern fn fmgr_c_validator(fcinfo: FunctionCallInfo) Datum;
pub extern fn fmgr_sql_validator(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_database_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_database_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_database_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_function_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_function_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_function_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_language_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_language_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_language_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_schema_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_schema_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_reset(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_backend_memory_contexts(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexreplace_noopt(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexreplace(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_total_relation_size(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_size_pretty(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_options_to_table(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn cstring_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn cstring_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn any_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn any_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyarray_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyarray_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn void_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn void_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn trigger_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn trigger_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn language_handler_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn language_handler_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn internal_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn internal_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_slru(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_reset_slru(fcinfo: FunctionCallInfo) Datum;
pub extern fn dceil(fcinfo: FunctionCallInfo) Datum;
pub extern fn dfloor(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsign(fcinfo: FunctionCallInfo) Datum;
pub extern fn md5_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyelement_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyelement_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn postgresql_fdw_validator(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) Datum;
pub extern fn md5_bytea(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_database_size_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_unnest(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_relation_size(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_lt_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_le_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_eq_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_gt_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_ge_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_ne_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_cmp_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_lt_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_le_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_eq_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_gt_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_ge_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_ne_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_cmp_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_lt_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_le_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_eq_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_gt_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_ge_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_ne_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_cmp_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_lt_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_le_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_eq_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_gt_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_ge_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_ne_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_cmp_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn shell_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn shell_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2send(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4send(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8send(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2vectorrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2vectorsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytearecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteasend(fcinfo: FunctionCallInfo) Datum;
pub extern fn textrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn textsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn unknownrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn unknownsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn oidvectorsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn namerecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn namesend(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn float4send(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8send(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpcharsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn varcharrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn varcharsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn charrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn charsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn xidrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn xidsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn regprocrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regprocsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn regprocedurerecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regproceduresend(fcinfo: FunctionCallInfo) Datum;
pub extern fn regoperrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regopersend(fcinfo: FunctionCallInfo) Datum;
pub extern fn regoperatorrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regoperatorsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn regclassrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regclasssend(fcinfo: FunctionCallInfo) Datum;
pub extern fn regtyperecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regtypesend(fcinfo: FunctionCallInfo) Datum;
pub extern fn bit_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn bit_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn varbit_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn varbit_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsinh(fcinfo: FunctionCallInfo) Datum;
pub extern fn dcosh(fcinfo: FunctionCallInfo) Datum;
pub extern fn dtanh(fcinfo: FunctionCallInfo) Datum;
pub extern fn dasinh(fcinfo: FunctionCallInfo) Datum;
pub extern fn dacosh(fcinfo: FunctionCallInfo) Datum;
pub extern fn datanh(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn lseg_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn path_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn line_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidr_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn cidr_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn cstring_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn cstring_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyarray_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyarray_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_expr_ext(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_prepared_statement(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_cursor(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_var_pop(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_stddev_pop(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_var_pop(fcinfo: FunctionCallInfo) Datum;
pub extern fn booland_statefunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn boolor_statefunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_lt_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_le_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_eq_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_gt_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_ge_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_ne_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_cmp_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_lt_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_le_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_eq_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_gt_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_ge_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_ne_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_cmp_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_tablespace_databases(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_bool(fcinfo: FunctionCallInfo) Datum;
pub extern fn bool_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn lastval(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_postmaster_start_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_blocking_pids(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_below(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_overbelow(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_overabove(fcinfo: FunctionCallInfo) Datum;
pub extern fn box_above(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_below(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_overbelow(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_overabove(fcinfo: FunctionCallInfo) Datum;
pub extern fn poly_above(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_box_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_float8(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_box_penalty(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_box_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_box_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_box_same(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_poly_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_poly_compress(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_overbelow(fcinfo: FunctionCallInfo) Datum;
pub extern fn circle_overabove(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_circle_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_circle_compress(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_stddev_pop(fcinfo: FunctionCallInfo) Datum;
pub extern fn domain_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn domain_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_timezone_abbrevs(fcinfo: FunctionCallInfo) Datum;
pub extern fn xmlexists(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_reload_conf(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_rotate_logfile_v2(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_file_1arg(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_file_off_len(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_dir_1arg(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_sleep(fcinfo: FunctionCallInfo) Datum;
pub extern fn inetnot(fcinfo: FunctionCallInfo) Datum;
pub extern fn inetand(fcinfo: FunctionCallInfo) Datum;
pub extern fn inetor(fcinfo: FunctionCallInfo) Datum;
pub extern fn inetpl(fcinfo: FunctionCallInfo) Datum;
pub extern fn inetmi_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn inetmi(fcinfo: FunctionCallInfo) Datum;
pub extern fn statement_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn clock_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_cmp_prefix(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_has_role_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_has_role_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_has_role_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_has_role_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_has_role_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_has_role_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_justify_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) Datum;
pub extern fn dasind(fcinfo: FunctionCallInfo) Datum;
pub extern fn dacosd(fcinfo: FunctionCallInfo) Datum;
pub extern fn datand(fcinfo: FunctionCallInfo) Datum;
pub extern fn datan2d(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsind(fcinfo: FunctionCallInfo) Datum;
pub extern fn dcosd(fcinfo: FunctionCallInfo) Datum;
pub extern fn dtand(fcinfo: FunctionCallInfo) Datum;
pub extern fn dcotd(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_backup_stop(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_avg_serialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_avg_deserialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn ginarrayextract(fcinfo: FunctionCallInfo) Datum;
pub extern fn ginarrayconsistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_avg_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn arrayoverlap(fcinfo: FunctionCallInfo) Datum;
pub extern fn arraycontains(fcinfo: FunctionCallInfo) Datum;
pub extern fn arraycontained(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_tuples_returned(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_tuples_fetched(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_tuples_inserted(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_tuples_updated(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_tuples_deleted(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_matches(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_split_to_table(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_split_to_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_bgwriter_timed_checkpoints(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_bgwriter_requested_checkpoints(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_bgwriter_buf_written_checkpoints(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_bgwriter_buf_written_clean(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_bgwriter_maxwritten_clean(fcinfo: FunctionCallInfo) Datum;
pub extern fn ginqueryarrayextract(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_buf_written_backend(fcinfo: FunctionCallInfo) Datum;
pub extern fn anynonarray_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anynonarray_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_last_vacuum_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_last_autovacuum_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_last_analyze_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_last_autoanalyze_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_avg_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_avg_serialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_avg_deserialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_wait_event_type(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidgt(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidlt(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidge(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidle(fcinfo: FunctionCallInfo) Datum;
pub extern fn bttidcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidlarger(fcinfo: FunctionCallInfo) Datum;
pub extern fn tidsmaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8inc_any(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8inc_float8_float8(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_sxx(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_syy(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_sxy(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_avgx(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_avgy(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_r2(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_slope(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_intercept(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_covar_pop(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_covar_samp(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_corr(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_blk_read_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_blk_write_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_switch_wal(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_current_wal_lsn(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_walfile_name_offset(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_walfile_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_current_wal_insert_lsn(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_wait_event(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_my_temp_schema(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_is_other_temp_schema(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_timezone_names(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_xact_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_avg_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_buf_alloc(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_live_tuples(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_dead_tuples(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) Datum;
pub extern fn xml_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn xml_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn xmlcomment(fcinfo: FunctionCallInfo) Datum;
pub extern fn texttoxml(fcinfo: FunctionCallInfo) Datum;
pub extern fn xmlvalidate(fcinfo: FunctionCallInfo) Datum;
pub extern fn xml_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn xml_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn xmlconcat2(fcinfo: FunctionCallInfo) Datum;
pub extern fn varbittypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn intervaltypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn intervaltypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptztypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptztypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetztypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetztypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchartypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchartypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn varchartypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn varchartypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn numerictypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn numerictypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn bittypmodin(fcinfo: FunctionCallInfo) Datum;
pub extern fn bittypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn varbittypmodout(fcinfo: FunctionCallInfo) Datum;
pub extern fn xmltotext(fcinfo: FunctionCallInfo) Datum;
pub extern fn table_to_xml(fcinfo: FunctionCallInfo) Datum;
pub extern fn query_to_xml(fcinfo: FunctionCallInfo) Datum;
pub extern fn cursor_to_xml(fcinfo: FunctionCallInfo) Datum;
pub extern fn table_to_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn query_to_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn cursor_to_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn table_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn query_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn xpath(fcinfo: FunctionCallInfo) Datum;
pub extern fn schema_to_xml(fcinfo: FunctionCallInfo) Datum;
pub extern fn schema_to_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn schema_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn database_to_xml(fcinfo: FunctionCallInfo) Datum;
pub extern fn database_to_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn database_to_xml_and_xmlschema(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_snapshot_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_snapshot_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_snapshot_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_snapshot_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_current_xact_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_current_snapshot(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_snapshot_xmin(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_snapshot_xmax(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_snapshot_xip(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_visible_in_snapshot(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_hash(fcinfo: FunctionCallInfo) Datum;
pub extern fn booltext(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_function_calls(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_function_total_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_function_self_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn btrecordcmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_table_size(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_indexes_size(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_relation_filenode(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_foreign_data_wrapper_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_foreign_data_wrapper_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_foreign_data_wrapper_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_server_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_server_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitoverlay(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitoverlay_no_len(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitgetbit(fcinfo: FunctionCallInfo) Datum;
pub extern fn bitsetbit(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_relation_filepath(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_listening_channels(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_notify(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_numscans(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_tuples_returned(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_tuples_fetched(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_tuples_inserted(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_tuples_updated(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_tuples_deleted(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_tuples_hot_updated(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_blocks_fetched(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_blocks_hit(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_function_calls(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_function_total_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_function_self_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn xpath_exists(fcinfo: FunctionCallInfo) Datum;
pub extern fn xml_is_well_formed(fcinfo: FunctionCallInfo) Datum;
pub extern fn xml_is_well_formed_document(fcinfo: FunctionCallInfo) Datum;
pub extern fn xml_is_well_formed_content(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_vacuum_count(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_autovacuum_count(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_analyze_count(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_autoanalyze_count(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_concat(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_concat_ws(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_left(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_right(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_reverse(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_buf_fsync_backend(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_point_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_conflict_tablespace(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_conflict_lock(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_conflict_snapshot(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_conflict_bufferpin(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_conflict_startup_deadlock(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_conflict_all(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_wal_replay_pause(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_wal_replay_resume(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_is_wal_replay_paused(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_stat_reset_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_bgwriter_stat_reset_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn ginarrayextract_2args(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_tsvector_2args(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_sequence_parameters(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_available_extensions(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_available_extension_versions(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_extension_update_paths(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_extension_config_dump(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_tsquery_5args(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_tsquery_consistent_6args(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn varchar_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_create_restore_point(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_wal_senders(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_row_number(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_rank(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_dense_rank(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_percent_rank(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_cume_dist(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_ntile(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_lag(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_lag_with_offset(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_lead(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_lead_with_offset(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_first_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_last_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_nth_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn fdw_handler_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn fdw_handler_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn void_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn void_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint2sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint4sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn btint8sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn btfloat4sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn btfloat8sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn btoidsortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn btnamesortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn date_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_type_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_type_privilege_id(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_not(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_and(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_or(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_temp_files(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_temp_bytes(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_deadlocks(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_to_json(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_to_json_pretty(fcinfo: FunctionCallInfo) Datum;
pub extern fn row_to_json(fcinfo: FunctionCallInfo) Datum;
pub extern fn row_to_json_pretty(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn varbit_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_checkpoint_write_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_checkpoint_sync_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_collation_for(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_trigger_depth(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_wal_lsn_diff(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_remove(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_replace(fcinfo: FunctionCallInfo) Datum;
pub extern fn rangesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_lseek64(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_tell64(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_truncate64(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_agg_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_json(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_mod_since_analyze(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_sum(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_cardinality(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_image_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_image_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_image_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_image_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_image_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn record_image_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn btrecordimagecmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_archiver(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_agg_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_build_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_build_array_noargs(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_build_object(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_build_object_noargs(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_two_arg(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_to_record(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_to_recordset(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_array_length(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_each(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_populate_record(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_typeof(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_field_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_array_element(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_array_element_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_extract_path(fcinfo: FunctionCallInfo) Datum;
pub extern fn width_bucket_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_array_elements(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_mi(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_hash(fcinfo: FunctionCallInfo) Datum;
pub extern fn bttextsortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_step_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_strip_nulls(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_strip_nulls(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_two_arg(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_agg_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_agg_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_build_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_build_array_noargs(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_build_object(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_build_object_noargs(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_ppoly(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_position(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_position_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_positions(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_circle_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_scale(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_point_fetch(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_poly_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_cpoint(fcinfo: FunctionCallInfo) Datum;
pub extern fn dist_polyp(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_file_off_len_missing(fcinfo: FunctionCallInfo) Datum;
pub extern fn show_config_by_name_missing_ok(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_binary_file_off_len_missing(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_notification_queue_usage(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_dir(fcinfo: FunctionCallInfo) Datum;
pub extern fn row_security_active(fcinfo: FunctionCallInfo) Datum;
pub extern fn row_security_active_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_concat(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_delete(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_delete_idx(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_delete_path(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_set(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_pretty(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_file(fcinfo: FunctionCallInfo) Datum;
pub extern fn xidneq(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsm_handler_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsm_handler_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsm_bernoulli_handler(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsm_system_handler(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_wal_receiver(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_progress_info(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_filter(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_setweight_by_filter(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_delete_str(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_unnest(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_delete_arr(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_avg_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_to_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_to_tsvector(fcinfo: FunctionCallInfo) Datum;
pub extern fn bpchar_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn show_all_file_settings(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_current_wal_flush_lsn(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytea_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn bttext_pattern_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn btbpchar_pattern_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_size_bytes(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_serialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_deserialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_avg_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_serialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_deserialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn float8_regr_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_delete_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_mul_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_div_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_current_xact_id_if_assigned(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_partkeydef(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_logdir(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_waldir(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ndistinct_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ndistinct_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ndistinct_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ndistinct_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_xact_status(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_safe_snapshot_blocking_pids(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_isolation_test_session_is_blocked(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_identify_object_as_address(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_opcinfo(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_add_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_avg_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_sum(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_avg(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_var_pop(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_var_samp(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_stddev_pop(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_poly_stddev_samp(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_match_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_match(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_mul_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_hba_file_rules(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_statistics_obj_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_dependencies_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_dependencies_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_dependencies_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_dependencies_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_partition_constraintdef(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_hash_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn timetz_hash_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_hash_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn uuid_hash_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_hash_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashenumextended(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_statisticsobjdef(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_hash_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_range_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_hash_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn sha224_bytea(fcinfo: FunctionCallInfo) Datum;
pub extern fn sha256_bytea(fcinfo: FunctionCallInfo) Datum;
pub extern fn sha384_bytea(fcinfo: FunctionCallInfo) Datum;
pub extern fn sha512_bytea(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_partition_tree(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_partition_root(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_partition_ancestors(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_checksum_failures(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stats_ext_mcvlist_items(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_checksum_last_failure(fcinfo: FunctionCallInfo) Datum;
pub extern fn gen_random_uuid(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_options(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_point_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_promote(fcinfo: FunctionCallInfo) Datum;
pub extern fn prefixsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn prefixjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_control_system(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_control_checkpoint(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_control_recovery(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_control_init(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_import_system_collations(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_collation_actual_version(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_int2(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_float4(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_filenode_relation(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_from_bytea(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_get(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_get_fragment(fcinfo: FunctionCallInfo) Datum;
pub extern fn be_lo_put(fcinfo: FunctionCallInfo) Datum;
pub extern fn make_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn make_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn make_timestamptz_at_timezone(fcinfo: FunctionCallInfo) Datum;
pub extern fn make_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_array_elements_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_range_quad_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_range_quad_choose(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_range_quad_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_range_quad_inner_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_range_quad_leaf_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_populate_recordset(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regoperator(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_field(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regprocedure(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_compare_jsonb(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_jsonb(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_jsonb_query(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_consistent_jsonb(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_jsonb_path(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_jsonb_query_path(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_consistent_jsonb_path(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_triconsistent_jsonb(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_triconsistent_jsonb_path(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_to_record(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_to_recordset(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regoper(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regtype(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regproc(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regclass(fcinfo: FunctionCallInfo) Datum;
pub extern fn bool_accum(fcinfo: FunctionCallInfo) Datum;
pub extern fn bool_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn bool_alltrue(fcinfo: FunctionCallInfo) Datum;
pub extern fn bool_anytrue(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyenum_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyenum_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn hashenum(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_first(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_last(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_range_bounds(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_range_all(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn enum_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn string_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn string_agg_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_describe_object(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_format(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_format_nv(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8dec(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8dec_any(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_overlap(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_gist_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_gist_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_gist_compress(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_bool(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_gist_penalty(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_gist_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_gist_same(fcinfo: FunctionCallInfo) Datum;
pub extern fn networksel(fcinfo: FunctionCallInfo) Datum;
pub extern fn networkjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) Datum;
pub extern fn int2int4_sum(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_gist_fetch(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_logical_emit_message_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_logical_emit_message_bytea(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_insert(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_xact_commit_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_pg_type_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_last_committed_xact(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_array_pg_type_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_heap_pg_class_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_index_pg_class_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_toast_pg_class_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_pg_enum_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_pg_authid_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_create_empty_extension(fcinfo: FunctionCallInfo) Datum;
pub extern fn event_trigger_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn event_trigger_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvectorin(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvectorout(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsqueryin(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsqueryout(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_strip(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_setweight(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_concat(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_match_vq(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_match_qv(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvectorsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvectorrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquerysend(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsqueryrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvectorin(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvectorout(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_compress(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_decompress(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_same(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_penalty(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_tsvector(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_tsquery(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_tsquery_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_and(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_or(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_not(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_numnode(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquerytree(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_rewrite(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_rewrite_query(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsmatchsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsmatchjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_typanalyze(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_stat1(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_stat2(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsq_mcontains(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsq_mcontained(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsquery_compress(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_starts_with(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsquery_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsquery_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsquery_same(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsquery_penalty(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsquery_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_rank_wttf(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_rank_wtt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_rank_ttf(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_rank_tt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_rankcd_wttf(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_rankcd_wtt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_rankcd_ttf(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_rankcd_tt(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_length(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_token_type_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_token_type_byname(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_parse_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_parse_byname(fcinfo: FunctionCallInfo) Datum;
pub extern fn prsd_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn prsd_nexttoken(fcinfo: FunctionCallInfo) Datum;
pub extern fn prsd_end(fcinfo: FunctionCallInfo) Datum;
pub extern fn prsd_headline(fcinfo: FunctionCallInfo) Datum;
pub extern fn prsd_lextype(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_lexize(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_cmp_tslexeme(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsimple_init(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsimple_lexize(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsynonym_init(fcinfo: FunctionCallInfo) Datum;
pub extern fn dsynonym_lexize(fcinfo: FunctionCallInfo) Datum;
pub extern fn dispell_init(fcinfo: FunctionCallInfo) Datum;
pub extern fn dispell_lexize(fcinfo: FunctionCallInfo) Datum;
pub extern fn regconfigin(fcinfo: FunctionCallInfo) Datum;
pub extern fn regconfigout(fcinfo: FunctionCallInfo) Datum;
pub extern fn regconfigrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regconfigsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn thesaurus_init(fcinfo: FunctionCallInfo) Datum;
pub extern fn thesaurus_lexize(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_byid_opt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_tsvector_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_tsquery_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn plainto_tsquery_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_tsvector(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_tsquery(fcinfo: FunctionCallInfo) Datum;
pub extern fn plainto_tsquery(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_update_trigger_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsvector_update_trigger_bycolumn(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_opt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ts_parser_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ts_dict_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ts_config_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn get_current_ts_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_match_tt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_match_tq(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ts_template_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn regdictionaryin(fcinfo: FunctionCallInfo) Datum;
pub extern fn regdictionaryout(fcinfo: FunctionCallInfo) Datum;
pub extern fn regdictionaryrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regdictionarysend(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_reset_shared(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_reset_single_table_counters(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_reset_single_function_counters(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_tablespace_location(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_create_physical_replication_slot(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_drop_replication_slot(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_replication_slots(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_logical_slot_get_changes(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_logical_slot_get_binary_changes(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_logical_slot_peek_changes(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_logical_slot_peek_binary_changes(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_create_logical_replication_slot(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_jsonb(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_snapshot_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_clean_pending_list(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsvector_consistent_oldsig(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_extract_tsquery_oldsig(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_tsquery_consistent_oldsig(fcinfo: FunctionCallInfo) Datum;
pub extern fn gtsquery_consistent_oldsig(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_spg_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_spg_choose(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_spg_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_spg_inner_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_spg_leaf_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_current_logfile(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_current_logfile_1arg(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_export_snapshot(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_is_in_recovery(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_collation_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_typanalyze(fcinfo: FunctionCallInfo) Datum;
pub extern fn arraycontsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn arraycontjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_multixact_members(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_last_wal_receive_lsn(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_last_wal_replay_lsn(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_div_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn cash_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_cash(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_file_all(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_binary_file_off_len(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_opfamily_is_visible(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_last_xact_replay_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyrange_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anyrange_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_identify_object(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_constructor2(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_constructor3(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_column_is_updatable(fcinfo: FunctionCallInfo) Datum;
pub extern fn make_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn make_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_lower(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_upper(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_empty(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_lower_inc(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_upper_inc(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_lower_inf(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_upper_inf(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_overlaps(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_contains_elem(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_contains(fcinfo: FunctionCallInfo) Datum;
pub extern fn elem_contained_by_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_contained_by(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_adjacent(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_before(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_after(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_overleft(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_overright(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_intersect(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_minus(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_gist_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_gist_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_slot_advance(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_gist_penalty(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_gist_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_gist_same(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4range_canonical(fcinfo: FunctionCallInfo) Datum;
pub extern fn daterange_canonical(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_typanalyze(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn interval_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn ginarraytriconsistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn gin_tsquery_triconsistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4range_subdiff(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8range_subdiff(fcinfo: FunctionCallInfo) Datum;
pub extern fn numrange_subdiff(fcinfo: FunctionCallInfo) Datum;
pub extern fn daterange_subdiff(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8range_canonical(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsrange_subdiff(fcinfo: FunctionCallInfo) Datum;
pub extern fn tstzrange_subdiff(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_keys(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_each_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn mxid_age(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_extract_path_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn acldefault_sql(fcinfo: FunctionCallInfo) Datum;
pub extern fn time_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_field(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_field_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_array_element(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_array_element_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_extract_path(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_summarize_new_values(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_extract_path_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_object_address(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_array_elements(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_array_length(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_keys(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_each(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_each_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_populate_record(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_populate_recordset(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_typeof(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_array_elements_text(fcinfo: FunctionCallInfo) Datum;
pub extern fn ordered_set_transition(fcinfo: FunctionCallInfo) Datum;
pub extern fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) Datum;
pub extern fn percentile_disc_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn mode_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn hypothetical_rank_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_int4_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_int8_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_unnest_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn gist_box_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_summarize_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonpath_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonpath_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonpath_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonpath_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_exists(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_query(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_query_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_query_first(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_match(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_exists_opr(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_path_match_opr(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_desummarize_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_quad_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_quad_choose(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_quad_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_kd_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_kd_choose(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_kd_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_text_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_text_choose(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_text_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_sequence_last_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_hash(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_contains(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_exists(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_exists_any(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_exists_all(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_contained(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_array_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_array_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_merge(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_merge(fcinfo: FunctionCallInfo) Datum;
pub extern fn boxes_bound_box(fcinfo: FunctionCallInfo) Datum;
pub extern fn inet_same_family(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_record_init_privs(fcinfo: FunctionCallInfo) Datum;
pub extern fn regnamespacein(fcinfo: FunctionCallInfo) Datum;
pub extern fn regnamespaceout(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regnamespace(fcinfo: FunctionCallInfo) Datum;
pub extern fn regnamespacerecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regnamespacesend(fcinfo: FunctionCallInfo) Datum;
pub extern fn point_box(fcinfo: FunctionCallInfo) Datum;
pub extern fn regroleout(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regrole(fcinfo: FunctionCallInfo) Datum;
pub extern fn regrolerecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regrolesend(fcinfo: FunctionCallInfo) Datum;
pub extern fn regrolein(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_rotate_logfile(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_file(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_missing_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_inclusion_opcinfo(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_inclusion_add_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_inclusion_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_inclusion_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_trunc(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_not(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_and(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_or(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddrtomacaddr8(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8tomacaddr(fcinfo: FunctionCallInfo) Datum;
pub extern fn macaddr8_set7bit(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_int8_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_int4_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_int4_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_int4_int2(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_int2_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_int2_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_int2_int2(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_date_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_timestamp_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_timestamptz_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_interval_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_time_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_timetz_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_float8_float8(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_float4_float8(fcinfo: FunctionCallInfo) Datum;
pub extern fn in_range_numeric_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn regcollationin(fcinfo: FunctionCallInfo) Datum;
pub extern fn regcollationout(fcinfo: FunctionCallInfo) Datum;
pub extern fn to_regcollation(fcinfo: FunctionCallInfo) Datum;
pub extern fn regcollationrecv(fcinfo: FunctionCallInfo) Datum;
pub extern fn regcollationsend(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_jsonb_byid_opt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_jsonb_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_jsonb_opt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_jsonb(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_json_byid_opt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_json_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_json_opt(fcinfo: FunctionCallInfo) Datum;
pub extern fn ts_headline_json(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_string_to_tsvector(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_string_to_tsvector(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_string_to_tsvector_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_string_to_tsvector_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_to_tsvector(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_to_tsvector_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_to_tsvector(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_to_tsvector_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_copy_physical_replication_slot_a(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_copy_physical_replication_slot_b(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_copy_logical_replication_slot_a(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_copy_logical_replication_slot_b(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_copy_logical_replication_slot_c(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblemultirange_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblemultirange_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_merge_from_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn anymultirange_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anymultirange_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_lower(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_upper(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_empty(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_lower_inc(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_upper_inc(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_lower_inf(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_upper_inf(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_typanalyze(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirangesel(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_overlaps_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_overlaps_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_overlaps_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_contains_elem(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_contains_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_contains_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn elem_contained_by_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_contained_by_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_contained_by_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_adjacent_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_adjacent_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_adjacent_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_before_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_before_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_before_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_after_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_after_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_after_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_overleft_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_overleft_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_overleft_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_overright_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_overright_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_overright_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_minus(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_intersect(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_le(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_multirange_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_constructor0(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_constructor1(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_constructor2(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_agg_finalfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn unicode_normalize_func(fcinfo: FunctionCallInfo) Datum;
pub extern fn unicode_is_normalized(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_intersect_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_multirange_pg_type_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_multirange_array_pg_type_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_intersect_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn range_contains_multirange(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_contained_by_range(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_log_backend_memory_contexts(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_heap_relfilenode(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_index_relfilenode(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_toast_relfilenode(fcinfo: FunctionCallInfo) Datum;
pub extern fn binary_upgrade_set_next_pg_tablespace_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_event_trigger_table_rewrite_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_event_trigger_table_rewrite_reason(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_event_trigger_ddl_commands(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_opcinfo(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_add_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_options(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_summary_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_summary_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_summary_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_bloom_summary_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_opcinfo(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_add_value(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_union(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_options(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_int2(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_int4(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_int8(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_float4(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_float8(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_numeric(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_tid(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_uuid(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_timetz(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_pg_lsn(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_macaddr(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_macaddr8(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_inet(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_distance_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_summary_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_summary_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_summary_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn brin_minmax_multi_summary_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn phraseto_tsquery(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_phrase(fcinfo: FunctionCallInfo) Datum;
pub extern fn tsquery_phrase_distance(fcinfo: FunctionCallInfo) Datum;
pub extern fn phraseto_tsquery_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn websearch_to_tsquery_byid(fcinfo: FunctionCallInfo) Datum;
pub extern fn websearch_to_tsquery(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_bbox_quad_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_poly_quad_compress(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_box_quad_config(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_box_quad_choose(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_box_quad_picksplit(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_box_quad_inner_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn spg_box_quad_leaf_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_mcv_list_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_mcv_list_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_mcv_list_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_mcv_list_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_pli(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_lsn_mii(fcinfo: FunctionCallInfo) Datum;
pub extern fn satisfies_hash_partition(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_tmpdir_noargs(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_tmpdir_1arg(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_archive_statusdir(fcinfo: FunctionCallInfo) Datum;
pub extern fn network_sortsupport(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8lt(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8gt(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8le(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8ge(fcinfo: FunctionCallInfo) Datum;
pub extern fn matchingsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn matchingjoinsel(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_min_scale(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_trim_scale(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4gcd(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8gcd(fcinfo: FunctionCallInfo) Datum;
pub extern fn int4lcm(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8lcm(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_gcd(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_lcm(fcinfo: FunctionCallInfo) Datum;
pub extern fn btvarstrequalimage(fcinfo: FunctionCallInfo) Datum;
pub extern fn btequalimage(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_shmem_allocations(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_ins_since_vacuum(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_set_lax(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8in(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8toxid(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8out(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8send(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8eq(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8ne(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatible_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatible_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblearray_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblearray_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblearray_recv(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblearray_send(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblenonarray_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblenonarray_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblerange_in(fcinfo: FunctionCallInfo) Datum;
pub extern fn anycompatiblerange_out(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8cmp(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8_larger(fcinfo: FunctionCallInfo) Datum;
pub extern fn xid8_smaller(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_create(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_drop(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_oid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_session_setup(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_session_reset(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_session_is_setup(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_session_progress(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_xact_setup(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_xact_reset(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_advance(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_replication_origin_progress(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_show_replication_origin_status(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_subscript_handler(fcinfo: FunctionCallInfo) Datum;
pub extern fn numeric_pg_lsn(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_backend_subxact(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_subscription(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_publication_tables(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_replica_identity_index(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_relation_is_publishable(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_gist_consistent(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_gist_compress(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_catalog_foreign_keys(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_to_table(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_to_table_null(fcinfo: FunctionCallInfo) Datum;
pub extern fn bit_bit_count(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytea_bit_count(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_xact_commit_timestamp_origin(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_replication_slot(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_reset_replication_slot(fcinfo: FunctionCallInfo) Datum;
pub extern fn trim_array(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_statisticsobjdef_expressions(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_statisticsobjdef_columns(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamp_bin(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_bin(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_subscript_handler(fcinfo: FunctionCallInfo) Datum;
pub extern fn raw_array_subscript_handler(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_session_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_active_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_idle_in_transaction_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_sessions(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_sessions_abandoned(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_sessions_fatal(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_sessions_killed(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_record(fcinfo: FunctionCallInfo) Datum;
pub extern fn hash_record_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn bytealtrim(fcinfo: FunctionCallInfo) Datum;
pub extern fn byteartrim(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_function_sqlbody(fcinfo: FunctionCallInfo) Datum;
pub extern fn unistr(fcinfo: FunctionCallInfo) Datum;
pub extern fn extract_date(fcinfo: FunctionCallInfo) Datum;
pub extern fn extract_time(fcinfo: FunctionCallInfo) Datum;
pub extern fn extract_timetz(fcinfo: FunctionCallInfo) Datum;
pub extern fn extract_timestamp(fcinfo: FunctionCallInfo) Datum;
pub extern fn extract_timestamptz(fcinfo: FunctionCallInfo) Datum;
pub extern fn extract_interval(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_parameter_privilege_name_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_parameter_privilege_id_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn has_parameter_privilege_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_file_all_missing(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_read_binary_file_all_missing(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_input_is_valid(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_input_error_info(fcinfo: FunctionCallInfo) Datum;
pub extern fn drandom_normal(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_split_walfile_name(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_io(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_shuffle(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_sample(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_tuples_newpage_updated(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_xact_tuples_newpage_updated(fcinfo: FunctionCallInfo) Datum;
pub extern fn derf(fcinfo: FunctionCallInfo) Datum;
pub extern fn derfc(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_pl_interval_at_zone(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_get_wal_resource_managers(fcinfo: FunctionCallInfo) Datum;
pub extern fn multirange_agg_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_have_stats(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_subscription_stats(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_reset_subscription_stats(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_row_number_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_rank_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_dense_rank_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn int8inc_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_settings_get_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stop_making_pinned_objects(fcinfo: FunctionCallInfo) Datum;
pub extern fn text_starts_with_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_recovery_prefetch(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_database_collation_actual_version(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ident_file_mappings(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexreplace_extended(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexreplace_extended_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn textregexreplace_extended_no_n(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_count_no_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_count_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_count(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_instr_no_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_instr_no_n(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_instr_no_endoption(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_instr_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_instr_no_subexpr(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_instr(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_like_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_like(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_substr_no_start(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_substr_no_n(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_substr_no_flags(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_substr_no_subexpr(fcinfo: FunctionCallInfo) Datum;
pub extern fn regexp_substr(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_logicalsnapdir(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_logicalmapdir(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_ls_replslotdir(fcinfo: FunctionCallInfo) Datum;
pub extern fn timestamptz_mi_interval_at_zone(fcinfo: FunctionCallInfo) Datum;
pub extern fn generate_series_timestamptz_at_zone(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_agg_strict_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_agg_strict_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_agg_unique_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn json_object_agg_unique_strict_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_agg_strict_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_agg_strict_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_agg_unique_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn jsonb_object_agg_unique_strict_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn any_value_transfn(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_serialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_deserialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_array_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_array_serialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn array_agg_array_deserialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn string_agg_combine(fcinfo: FunctionCallInfo) Datum;
pub extern fn string_agg_serialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn string_agg_deserialize(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_log_standby_snapshot(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_percent_rank_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_cume_dist_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn window_ntile_support(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_db_conflict_logicalslot(fcinfo: FunctionCallInfo) Datum;
pub extern fn pg_stat_get_lastscan(fcinfo: FunctionCallInfo) Datum;
pub extern fn system_user(fcinfo: FunctionCallInfo) Datum;
pub extern fn parse_bool(value: [*c]const u8, result: [*c]bool) bool;
pub extern fn parse_bool_with_len(value: [*c]const u8, len: usize, result: [*c]bool) bool;
pub extern fn domain_check(value: Datum, isnull: bool, domainType: Oid, extra: [*c]?*anyopaque, mcxt: MemoryContext) void;
pub extern fn errdatatype(datatypeOid: Oid) c_int;
pub extern fn errdomainconstraint(datatypeOid: Oid, conname: [*c]const u8) c_int;
pub extern fn hex_encode(src: [*c]const u8, len: usize, dst: [*c]u8) uint64;
pub extern fn hex_decode(src: [*c]const u8, len: usize, dst: [*c]u8) uint64;
pub extern fn hex_decode_safe(src: [*c]const u8, len: usize, dst: [*c]u8, escontext: [*c]Node) uint64;
pub extern fn buildint2vector(int2s: [*c]const int16, n: c_int) [*c]int2vector;
pub extern fn namestrcpy(name: Name, str: [*c]const u8) void;
pub extern fn namestrcmp(name: Name, str: [*c]const u8) c_int;
pub extern fn pg_strtoint16(s: [*c]const u8) int16;
pub extern fn pg_strtoint16_safe(s: [*c]const u8, escontext: [*c]Node) int16;
pub extern fn pg_strtoint32(s: [*c]const u8) int32;
pub extern fn pg_strtoint32_safe(s: [*c]const u8, escontext: [*c]Node) int32;
pub extern fn pg_strtoint64(s: [*c]const u8) int64;
pub extern fn pg_strtoint64_safe(s: [*c]const u8, escontext: [*c]Node) int64;
pub extern fn uint32in_subr(s: [*c]const u8, endloc: [*c][*c]u8, typname: [*c]const u8, escontext: [*c]Node) uint32;
pub extern fn uint64in_subr(s: [*c]const u8, endloc: [*c][*c]u8, typname: [*c]const u8, escontext: [*c]Node) uint64;
pub extern fn pg_itoa(i: int16, a: [*c]u8) c_int;
pub extern fn pg_ultoa_n(value: uint32, a: [*c]u8) c_int;
pub extern fn pg_ulltoa_n(value: uint64, a: [*c]u8) c_int;
pub extern fn pg_ltoa(value: int32, a: [*c]u8) c_int;
pub extern fn pg_lltoa(value: int64, a: [*c]u8) c_int;
pub extern fn pg_ultostr_zeropad(str: [*c]u8, value: uint32, minwidth: int32) [*c]u8;
pub extern fn pg_ultostr(str: [*c]u8, value: uint32) [*c]u8;
pub extern fn buildoidvector(oids: [*c]const Oid, n: c_int) [*c]oidvector;
pub extern fn oidparse(node: [*c]Node) Oid;
pub extern fn oid_cmp(p1: ?*const anyopaque, p2: ?*const anyopaque) c_int;
pub extern fn regexp_fixed_prefix(text_re: [*c]text, case_insensitive: bool, collation: Oid, exact: [*c]bool) [*c]u8;
pub extern var quote_all_identifiers: bool;
pub extern fn quote_identifier(ident: [*c]const u8) [*c]const u8;
pub extern fn quote_qualified_identifier(qualifier: [*c]const u8, ident: [*c]const u8) [*c]u8;
pub extern fn generate_operator_clause(buf: fmStringInfo, leftop: [*c]const u8, leftoptype: Oid, opoid: Oid, rightop: [*c]const u8, rightoptype: Oid) void;
pub extern fn bpchartruelen(s: [*c]u8, len: c_int) c_int;
pub extern fn cstring_to_text(s: [*c]const u8) [*c]text;
pub extern fn cstring_to_text_with_len(s: [*c]const u8, len: c_int) [*c]text;
pub extern fn text_to_cstring(t: [*c]const text) [*c]u8;
pub extern fn text_to_cstring_buffer(src: [*c]const text, dst: [*c]u8, dst_len: usize) void;
pub extern fn xidComparator(arg1: ?*const anyopaque, arg2: ?*const anyopaque) c_int;
pub extern fn xidLogicalComparator(arg1: ?*const anyopaque, arg2: ?*const anyopaque) c_int;
pub extern fn pg_inet_cidr_ntop(af: c_int, src: ?*const anyopaque, bits: c_int, dst: [*c]u8, size: usize) [*c]u8;
pub extern fn pg_inet_net_pton(af: c_int, src: [*c]const u8, dst: ?*anyopaque, size: usize) c_int;
pub extern fn convert_network_to_scalar(value: Datum, typid: Oid, failure: [*c]bool) f64;
pub extern fn network_scan_first(in: Datum) Datum;
pub extern fn network_scan_last(in: Datum) Datum;
pub extern fn clean_ipv6_addr(addr_family: c_int, addr: [*c]u8) void;
pub extern fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) Datum;
pub extern fn format_type_extended(type_oid: Oid, typemod: int32, flags: bits16) [*c]u8;
pub extern fn format_type_be(type_oid: Oid) [*c]u8;
pub extern fn format_type_be_qualified(type_oid: Oid) [*c]u8;
pub extern fn format_type_with_typemod(type_oid: Oid, typemod: int32) [*c]u8;
pub extern fn type_maximum_size(type_oid: Oid, typemod: int32) int32;
pub extern fn quote_literal_cstr(rawstr: [*c]const u8) [*c]u8;
pub const struct_SubscriptRoutines = opaque {};
pub const struct_OpBtreeInterpretation = extern struct {
    opfamily_id: Oid,
    strategy: c_int,
    oplefttype: Oid,
    oprighttype: Oid,
};
pub const OpBtreeInterpretation = struct_OpBtreeInterpretation;
pub const IOFunc_input: c_int = 0;
pub const IOFunc_output: c_int = 1;
pub const IOFunc_receive: c_int = 2;
pub const IOFunc_send: c_int = 3;
pub const enum_IOFuncSelector = c_uint;
pub const IOFuncSelector = enum_IOFuncSelector;
pub const struct_AttStatsSlot = extern struct {
    staop: Oid,
    stacoll: Oid,
    valuetype: Oid,
    values: [*c]Datum,
    nvalues: c_int,
    numbers: [*c]float4,
    nnumbers: c_int,
    values_arr: ?*anyopaque,
    numbers_arr: ?*anyopaque,
};
pub const AttStatsSlot = struct_AttStatsSlot;
pub const get_attavgwidth_hook_type = ?*const fn (Oid, AttrNumber) callconv(.C) int32;
pub extern var get_attavgwidth_hook: get_attavgwidth_hook_type;
pub extern fn op_in_opfamily(opno: Oid, opfamily: Oid) bool;
pub extern fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid) c_int;
pub extern fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) Oid;
pub extern fn get_op_opfamily_properties(opno: Oid, opfamily: Oid, ordering_op: bool, strategy: [*c]c_int, lefttype: [*c]Oid, righttype: [*c]Oid) void;
pub extern fn get_opfamily_member(opfamily: Oid, lefttype: Oid, righttype: Oid, strategy: int16) Oid;
pub extern fn get_ordering_op_properties(opno: Oid, opfamily: [*c]Oid, opcintype: [*c]Oid, strategy: [*c]int16) bool;
pub extern fn get_equality_op_for_ordering_op(opno: Oid, reverse: [*c]bool) Oid;
pub extern fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: bool) Oid;
pub extern fn get_mergejoin_opfamilies(opno: Oid) [*c]List;
pub extern fn get_compatible_hash_operators(opno: Oid, lhs_opno: [*c]Oid, rhs_opno: [*c]Oid) bool;
pub extern fn get_op_hash_functions(opno: Oid, lhs_procno: [*c]RegProcedure, rhs_procno: [*c]RegProcedure) bool;
pub extern fn get_op_btree_interpretation(opno: Oid) [*c]List;
pub extern fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) bool;
pub extern fn comparison_ops_are_compatible(opno1: Oid, opno2: Oid) bool;
pub extern fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid, procnum: int16) Oid;
pub extern fn get_attname(relid: Oid, attnum: AttrNumber, missing_ok: bool) [*c]u8;
pub extern fn get_attnum(relid: Oid, attname: [*c]const u8) AttrNumber;
pub extern fn get_attstattarget(relid: Oid, attnum: AttrNumber) c_int;
pub extern fn get_attgenerated(relid: Oid, attnum: AttrNumber) u8;
pub extern fn get_atttype(relid: Oid, attnum: AttrNumber) Oid;
pub extern fn get_atttypetypmodcoll(relid: Oid, attnum: AttrNumber, typid: [*c]Oid, typmod: [*c]int32, collid: [*c]Oid) void;
pub extern fn get_attoptions(relid: Oid, attnum: int16) Datum;
pub extern fn get_cast_oid(sourcetypeid: Oid, targettypeid: Oid, missing_ok: bool) Oid;
pub extern fn get_collation_name(colloid: Oid) [*c]u8;
pub extern fn get_collation_isdeterministic(colloid: Oid) bool;
pub extern fn get_constraint_name(conoid: Oid) [*c]u8;
pub extern fn get_constraint_index(conoid: Oid) Oid;
pub extern fn get_language_name(langoid: Oid, missing_ok: bool) [*c]u8;
pub extern fn get_opclass_family(opclass: Oid) Oid;
pub extern fn get_opclass_input_type(opclass: Oid) Oid;
pub extern fn get_opclass_opfamily_and_input_type(opclass: Oid, opfamily: [*c]Oid, opcintype: [*c]Oid) bool;
pub extern fn get_opcode(opno: Oid) RegProcedure;
pub extern fn get_opname(opno: Oid) [*c]u8;
pub extern fn get_op_rettype(opno: Oid) Oid;
pub extern fn op_input_types(opno: Oid, lefttype: [*c]Oid, righttype: [*c]Oid) void;
pub extern fn op_mergejoinable(opno: Oid, inputtype: Oid) bool;
pub extern fn op_hashjoinable(opno: Oid, inputtype: Oid) bool;
pub extern fn op_strict(opno: Oid) bool;
pub extern fn op_volatile(opno: Oid) u8;
pub extern fn get_commutator(opno: Oid) Oid;
pub extern fn get_negator(opno: Oid) Oid;
pub extern fn get_oprrest(opno: Oid) RegProcedure;
pub extern fn get_oprjoin(opno: Oid) RegProcedure;
pub extern fn get_func_name(funcid: Oid) [*c]u8;
pub extern fn get_func_namespace(funcid: Oid) Oid;
pub extern fn get_func_rettype(funcid: Oid) Oid;
pub extern fn get_func_nargs(funcid: Oid) c_int;
pub extern fn get_func_signature(funcid: Oid, argtypes: [*c][*c]Oid, nargs: [*c]c_int) Oid;
pub extern fn get_func_variadictype(funcid: Oid) Oid;
pub extern fn get_func_retset(funcid: Oid) bool;
pub extern fn func_strict(funcid: Oid) bool;
pub extern fn func_volatile(funcid: Oid) u8;
pub extern fn func_parallel(funcid: Oid) u8;
pub extern fn get_func_prokind(funcid: Oid) u8;
pub extern fn get_func_leakproof(funcid: Oid) bool;
pub extern fn get_func_support(funcid: Oid) RegProcedure;
pub extern fn get_relname_relid(relname: [*c]const u8, relnamespace: Oid) Oid;
pub extern fn get_rel_name(relid: Oid) [*c]u8;
pub extern fn get_rel_namespace(relid: Oid) Oid;
pub extern fn get_rel_type_id(relid: Oid) Oid;
pub extern fn get_rel_relkind(relid: Oid) u8;
pub extern fn get_rel_relispartition(relid: Oid) bool;
pub extern fn get_rel_tablespace(relid: Oid) Oid;
pub extern fn get_rel_persistence(relid: Oid) u8;
pub extern fn get_transform_fromsql(typid: Oid, langid: Oid, trftypes: [*c]List) Oid;
pub extern fn get_transform_tosql(typid: Oid, langid: Oid, trftypes: [*c]List) Oid;
pub extern fn get_typisdefined(typid: Oid) bool;
pub extern fn get_typlen(typid: Oid) int16;
pub extern fn get_typbyval(typid: Oid) bool;
pub extern fn get_typlenbyval(typid: Oid, typlen: [*c]int16, typbyval: [*c]bool) void;
pub extern fn get_typlenbyvalalign(typid: Oid, typlen: [*c]int16, typbyval: [*c]bool, typalign: [*c]u8) void;
pub extern fn getTypeIOParam(typeTuple: HeapTuple) Oid;
pub extern fn get_type_io_data(typid: Oid, which_func: IOFuncSelector, typlen: [*c]int16, typbyval: [*c]bool, typalign: [*c]u8, typdelim: [*c]u8, typioparam: [*c]Oid, func: [*c]Oid) void;
pub extern fn get_typstorage(typid: Oid) u8;
pub extern fn get_typdefault(typid: Oid) [*c]Node;
pub extern fn get_typtype(typid: Oid) u8;
pub extern fn type_is_rowtype(typid: Oid) bool;
pub extern fn type_is_enum(typid: Oid) bool;
pub extern fn type_is_range(typid: Oid) bool;
pub extern fn type_is_multirange(typid: Oid) bool;
pub extern fn get_type_category_preferred(typid: Oid, typcategory: [*c]u8, typispreferred: [*c]bool) void;
pub extern fn get_typ_typrelid(typid: Oid) Oid;
pub extern fn get_element_type(typid: Oid) Oid;
pub extern fn get_array_type(typid: Oid) Oid;
pub extern fn get_promoted_array_type(typid: Oid) Oid;
pub extern fn get_base_element_type(typid: Oid) Oid;
pub extern fn getTypeInputInfo(@"type": Oid, typInput: [*c]Oid, typIOParam: [*c]Oid) void;
pub extern fn getTypeOutputInfo(@"type": Oid, typOutput: [*c]Oid, typIsVarlena: [*c]bool) void;
pub extern fn getTypeBinaryInputInfo(@"type": Oid, typReceive: [*c]Oid, typIOParam: [*c]Oid) void;
pub extern fn getTypeBinaryOutputInfo(@"type": Oid, typSend: [*c]Oid, typIsVarlena: [*c]bool) void;
pub extern fn get_typmodin(typid: Oid) Oid;
pub extern fn get_typcollation(typid: Oid) Oid;
pub extern fn type_is_collatable(typid: Oid) bool;
pub extern fn get_typsubscript(typid: Oid, typelemp: [*c]Oid) RegProcedure;
pub extern fn getSubscriptingRoutines(typid: Oid, typelemp: [*c]Oid) ?*const struct_SubscriptRoutines;
pub extern fn getBaseType(typid: Oid) Oid;
pub extern fn getBaseTypeAndTypmod(typid: Oid, typmod: [*c]int32) Oid;
pub extern fn get_typavgwidth(typid: Oid, typmod: int32) int32;
pub extern fn get_attavgwidth(relid: Oid, attnum: AttrNumber) int32;
pub extern fn get_attstatsslot(sslot: [*c]AttStatsSlot, statstuple: HeapTuple, reqkind: c_int, reqop: Oid, flags: c_int) bool;
pub extern fn free_attstatsslot(sslot: [*c]AttStatsSlot) void;
pub extern fn get_namespace_name(nspid: Oid) [*c]u8;
pub extern fn get_namespace_name_or_temp(nspid: Oid) [*c]u8;
pub extern fn get_range_subtype(rangeOid: Oid) Oid;
pub extern fn get_range_collation(rangeOid: Oid) Oid;
pub extern fn get_range_multirange(rangeOid: Oid) Oid;
pub extern fn get_multirange_range(multirangeOid: Oid) Oid;
pub extern fn get_index_column_opclass(index_oid: Oid, attno: c_int) Oid;
pub extern fn get_index_isreplident(index_oid: Oid) bool;
pub extern fn get_index_isvalid(index_oid: Oid) bool;
pub extern fn get_index_isclustered(index_oid: Oid) bool;
pub extern fn get_publication_oid(pubname: [*c]const u8, missing_ok: bool) Oid;
pub extern fn get_publication_name(pubid: Oid, missing_ok: bool) [*c]u8;
pub extern fn get_subscription_oid(subname: [*c]const u8, missing_ok: bool) Oid;
pub extern fn get_subscription_name(subid: Oid, missing_ok: bool) [*c]u8;
pub const MemoryContextData = struct_MemoryContextData;
pub extern var TopMemoryContext: MemoryContext;
pub extern var ErrorContext: MemoryContext;
pub extern var PostmasterContext: MemoryContext;
pub extern var CacheMemoryContext: MemoryContext;
pub extern var MessageContext: MemoryContext;
pub extern var TopTransactionContext: MemoryContext;
pub extern var CurTransactionContext: MemoryContext;
pub extern var PortalContext: MemoryContext;
pub extern fn MemoryContextInit() void;
pub extern fn MemoryContextReset(context: MemoryContext) void;
pub extern fn MemoryContextDelete(context: MemoryContext) void;
pub extern fn MemoryContextResetOnly(context: MemoryContext) void;
pub extern fn MemoryContextResetChildren(context: MemoryContext) void;
pub extern fn MemoryContextDeleteChildren(context: MemoryContext) void;
pub extern fn MemoryContextSetIdentifier(context: MemoryContext, id: [*c]const u8) void;
pub extern fn MemoryContextSetParent(context: MemoryContext, new_parent: MemoryContext) void;
pub extern fn GetMemoryChunkContext(pointer: ?*anyopaque) MemoryContext;
pub extern fn GetMemoryChunkSpace(pointer: ?*anyopaque) Size;
pub extern fn MemoryContextGetParent(context: MemoryContext) MemoryContext;
pub extern fn MemoryContextIsEmpty(context: MemoryContext) bool;
pub extern fn MemoryContextMemAllocated(context: MemoryContext, recurse: bool) Size;
pub extern fn MemoryContextStats(context: MemoryContext) void;
pub extern fn MemoryContextStatsDetail(context: MemoryContext, max_children: c_int, print_to_stderr: bool) void;
pub extern fn MemoryContextAllowInCriticalSection(context: MemoryContext, allow: bool) void;
pub extern fn HandleLogMemoryContextInterrupt() void;
pub extern fn ProcessLogMemoryContextInterrupt() void;
pub extern fn AllocSetContextCreateInternal(parent: MemoryContext, name: [*c]const u8, minContextSize: Size, initBlockSize: Size, maxBlockSize: Size) MemoryContext;
pub extern fn SlabContextCreate(parent: MemoryContext, name: [*c]const u8, blockSize: Size, chunkSize: Size) MemoryContext;
pub extern fn GenerationContextCreate(parent: MemoryContext, name: [*c]const u8, minContextSize: Size, initBlockSize: Size, maxBlockSize: Size) MemoryContext;
pub export fn Pg_magic_func() [*c]const Pg_magic_struct {
    const Pg_magic_data = struct {
        const static: Pg_magic_struct = Pg_magic_struct{
            .len = @bitCast(c_int, @truncate(c_uint, @sizeOf(Pg_magic_struct))),
            .version = @divTrunc(@as(c_int, 160000), @as(c_int, 100)),
            .funcmaxargs = @as(c_int, 100),
            .indexmaxkeys = @as(c_int, 32),
            .namedatalen = @as(c_int, 64),
            .float8byval = @as(c_int, 1),
            .abi_extra = "PostgreSQL",
        };
    };
    return &Pg_magic_data.static;
}
pub const TestDecodingData = extern struct {
    context: MemoryContext,
    include_xids: bool,
    include_timestamp: bool,
    skip_empty_xacts: bool,
    only_local: bool,
};
pub const TestDecodingTxnData = extern struct {
    xact_wrote_changes: bool,
    stream_wrote_changes: bool,
}; // ../../src/include/c.h:916:7: warning: ignoring StaticAssert declaration
pub fn pg_decode_startup(arg_ctx: [*c]LogicalDecodingContext, arg_opt: [*c]OutputPluginOptions, arg_is_init: bool) callconv(.C) void {
    var ctx = arg_ctx;
    var opt = arg_opt;
    var is_init = arg_is_init;
    _ = @TypeOf(is_init);
    var option: [*c]ListCell = undefined;
    var data: [*c]TestDecodingData = undefined;
    var enable_streaming: bool = @as(c_int, 0) != 0;
    data = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), palloc0(@sizeOf(TestDecodingData))));
    data.*.context = blk: {
        _ = blk_1: {
            while (true) {
                if (!false) break;
            }
            break :blk_1 @as(c_int, 1);
        };
        break :blk AllocSetContextCreateInternal(ctx.*.context, "text conversion context", @bitCast(Size, @as(c_long, @as(c_int, 0))), @bitCast(Size, @as(c_long, @as(c_int, 8) * @as(c_int, 1024))), @bitCast(Size, @as(c_long, (@as(c_int, 8) * @as(c_int, 1024)) * @as(c_int, 1024))));
    };
    data.*.include_xids = @as(c_int, 1) != 0;
    data.*.include_timestamp = @as(c_int, 0) != 0;
    data.*.skip_empty_xacts = @as(c_int, 0) != 0;
    data.*.only_local = @as(c_int, 0) != 0;
    ctx.*.output_plugin_private = @ptrCast(?*anyopaque, data);
    opt.*.output_type = @bitCast(c_uint, OUTPUT_PLUGIN_TEXTUAL_OUTPUT);
    opt.*.receive_rewrites = @as(c_int, 0) != 0;
    {
        var option__state: ForEachState = ForEachState{
            .l = ctx.*.output_plugin_options,
            .i = @as(c_int, 0),
        };
        while ((if ((option__state.l != @ptrCast([*c]const List, @alignCast(@import("std").meta.alignment([*c]const List), @ptrCast([*c]List, @alignCast(@import("std").meta.alignment([*c]List), @intToPtr(?*anyopaque, @as(c_int, 0))))))) and (option__state.i < option__state.l.*.length)) blk: {
            option = &(blk_1: {
                const tmp = option__state.i;
                if (tmp >= 0) break :blk_1 option__state.l.*.elements + @intCast(usize, tmp) else break :blk_1 option__state.l.*.elements - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
            }).*;
            break :blk @as(c_int, 1);
        } else blk: {
            option = null;
            break :blk @as(c_int, 0);
        }) != 0) : (option__state.i += 1) {
            var elem: [*c]DefElem = @ptrCast([*c]DefElem, @alignCast(@import("std").meta.alignment([*c]DefElem), option.*.ptr_value));
            _ = @as(c_int, 1);
            if (strcmp(elem.*.defname, "include-xids") == @as(c_int, 0)) {
                if (elem.*.arg == @ptrCast([*c]Node, @alignCast(@import("std").meta.alignment([*c]Node), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
                    data.*.include_xids = @as(c_int, 1) != 0;
                } else if (!parse_bool(@ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, &data.*.include_xids)) while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = blk_1: {
                                _ = errcode((((((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 6))) + (((@as(c_int, '0') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 12))) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 18))) + (((@as(c_int, '3') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 24)));
                                break :blk_1 errmsg("could not parse value \"%s\" for parameter \"%s\"", @ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, elem.*.defname);
                            };
                            break :blk errfinish("test_decoding.c", @as(c_int, 192), "pg_decode_startup");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                };
            } else if (strcmp(elem.*.defname, "include-timestamp") == @as(c_int, 0)) {
                if (elem.*.arg == @ptrCast([*c]Node, @alignCast(@import("std").meta.alignment([*c]Node), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
                    data.*.include_timestamp = @as(c_int, 1) != 0;
                } else if (!parse_bool(@ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, &data.*.include_timestamp)) while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = blk_1: {
                                _ = errcode((((((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 6))) + (((@as(c_int, '0') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 12))) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 18))) + (((@as(c_int, '3') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 24)));
                                break :blk_1 errmsg("could not parse value \"%s\" for parameter \"%s\"", @ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, elem.*.defname);
                            };
                            break :blk errfinish("test_decoding.c", @as(c_int, 202), "pg_decode_startup");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                };
            } else if (strcmp(elem.*.defname, "force-binary") == @as(c_int, 0)) {
                var force_binary: bool = undefined;
                if (elem.*.arg == @ptrCast([*c]Node, @alignCast(@import("std").meta.alignment([*c]Node), @intToPtr(?*anyopaque, @as(c_int, 0))))) continue else if (!parse_bool(@ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, &force_binary)) while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = blk_1: {
                                _ = errcode((((((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 6))) + (((@as(c_int, '0') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 12))) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 18))) + (((@as(c_int, '3') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 24)));
                                break :blk_1 errmsg("could not parse value \"%s\" for parameter \"%s\"", @ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, elem.*.defname);
                            };
                            break :blk errfinish("test_decoding.c", @as(c_int, 214), "pg_decode_startup");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                };
                if (force_binary) {
                    opt.*.output_type = @bitCast(c_uint, OUTPUT_PLUGIN_BINARY_OUTPUT);
                }
            } else if (strcmp(elem.*.defname, "skip-empty-xacts") == @as(c_int, 0)) {
                if (elem.*.arg == @ptrCast([*c]Node, @alignCast(@import("std").meta.alignment([*c]Node), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
                    data.*.skip_empty_xacts = @as(c_int, 1) != 0;
                } else if (!parse_bool(@ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, &data.*.skip_empty_xacts)) while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = blk_1: {
                                _ = errcode((((((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 6))) + (((@as(c_int, '0') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 12))) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 18))) + (((@as(c_int, '3') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 24)));
                                break :blk_1 errmsg("could not parse value \"%s\" for parameter \"%s\"", @ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, elem.*.defname);
                            };
                            break :blk errfinish("test_decoding.c", @as(c_int, 228), "pg_decode_startup");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                };
            } else if (strcmp(elem.*.defname, "only-local") == @as(c_int, 0)) {
                if (elem.*.arg == @ptrCast([*c]Node, @alignCast(@import("std").meta.alignment([*c]Node), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
                    data.*.only_local = @as(c_int, 1) != 0;
                } else if (!parse_bool(@ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, &data.*.only_local)) while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = blk_1: {
                                _ = errcode((((((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 6))) + (((@as(c_int, '0') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 12))) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 18))) + (((@as(c_int, '3') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 24)));
                                break :blk_1 errmsg("could not parse value \"%s\" for parameter \"%s\"", @ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, elem.*.defname);
                            };
                            break :blk errfinish("test_decoding.c", @as(c_int, 239), "pg_decode_startup");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                };
            } else if (strcmp(elem.*.defname, "include-rewrites") == @as(c_int, 0)) {
                if (elem.*.arg == @ptrCast([*c]Node, @alignCast(@import("std").meta.alignment([*c]Node), @intToPtr(?*anyopaque, @as(c_int, 0))))) continue else if (!parse_bool(@ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, &opt.*.receive_rewrites)) while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = blk_1: {
                                _ = errcode((((((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 6))) + (((@as(c_int, '0') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 12))) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 18))) + (((@as(c_int, '3') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 24)));
                                break :blk_1 errmsg("could not parse value \"%s\" for parameter \"%s\"", @ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, elem.*.defname);
                            };
                            break :blk errfinish("test_decoding.c", @as(c_int, 250), "pg_decode_startup");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                };
            } else if (strcmp(elem.*.defname, "stream-changes") == @as(c_int, 0)) {
                if (elem.*.arg == @ptrCast([*c]Node, @alignCast(@import("std").meta.alignment([*c]Node), @intToPtr(?*anyopaque, @as(c_int, 0))))) continue else if (!parse_bool(@ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, &enable_streaming)) while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = blk_1: {
                                _ = errcode((((((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 6))) + (((@as(c_int, '0') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 12))) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 18))) + (((@as(c_int, '3') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 24)));
                                break :blk_1 errmsg("could not parse value \"%s\" for parameter \"%s\"", @ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval, elem.*.defname);
                            };
                            break :blk errfinish("test_decoding.c", @as(c_int, 260), "pg_decode_startup");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                };
            } else {
                while (true) {
                    var __errno_location_1: c_int = undefined;
                    _ = @TypeOf(__errno_location_1);
                    if ((if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) @as(c_int, @boolToInt(errstart_cold(@as(c_int, 21), null))) else @as(c_int, @boolToInt(errstart(@as(c_int, 21), null)))) != 0) {
                        _ = blk: {
                            _ = blk_1: {
                                _ = errcode((((((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 6))) + (((@as(c_int, '0') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 12))) + (((@as(c_int, '2') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 18))) + (((@as(c_int, '3') - @as(c_int, '0')) & @as(c_int, 63)) << @intCast(@import("std").math.Log2Int(c_int), 24)));
                                break :blk_1 errmsg("option \"%s\" = \"%s\" is unknown", elem.*.defname, if (elem.*.arg != null) @ptrCast([*c]String, @alignCast(@import("std").meta.alignment([*c]String), elem.*.arg)).*.sval else "(null)");
                            };
                            break :blk errfinish("test_decoding.c", @as(c_int, 268), "pg_decode_startup");
                        };
                    }
                    if ((__builtin_constant_p(@as(c_int, 21)) != 0) and (@as(c_int, 21) >= @as(c_int, 21))) {
                        __builtin_unreachable();
                    }
                    if (!false) break;
                }
            }
        }
    }
    ctx.*.streaming &= @as(c_int, @boolToInt(enable_streaming));
}
pub fn pg_decode_shutdown(arg_ctx: [*c]LogicalDecodingContext) callconv(.C) void {
    var ctx = arg_ctx;
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    MemoryContextDelete(data.*.context);
}
pub fn pg_decode_begin_txn(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), MemoryContextAllocZero(ctx.*.context, @sizeOf(TestDecodingTxnData))));
    txndata.*.xact_wrote_changes = @as(c_int, 0) != 0;
    txn.*.output_plugin_private = @ptrCast(?*anyopaque, txndata);
    if (data.*.skip_empty_xacts) return;
    pg_output_begin(ctx, data, txn, @as(c_int, 1) != 0);
}
pub fn pg_output_begin(arg_ctx: [*c]LogicalDecodingContext, arg_data: [*c]TestDecodingData, arg_txn: [*c]ReorderBufferTXN, arg_last_write: bool) callconv(.C) void {
    var ctx = arg_ctx;
    var data = arg_data;
    var txn = arg_txn;
    var last_write = arg_last_write;
    OutputPluginPrepareWrite(ctx, last_write);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "BEGIN %u", txn.*.xid);
    } else {
        appendStringInfoString(ctx.*.out, "BEGIN");
    }
    OutputPluginWrite(ctx, last_write);
}
pub fn pg_decode_commit_txn(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_commit_lsn: XLogRecPtr) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var commit_lsn = arg_commit_lsn;
    _ = @TypeOf(commit_lsn);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    var xact_wrote_changes: bool = txndata.*.xact_wrote_changes;
    pfree(@ptrCast(?*anyopaque, txndata));
    txn.*.output_plugin_private = @intToPtr(?*anyopaque, @as(c_int, 0));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !xact_wrote_changes) return;
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "COMMIT %u", txn.*.xid);
    } else {
        appendStringInfoString(ctx.*.out, "COMMIT");
    }
    if (data.*.include_timestamp) {
        appendStringInfo(ctx.*.out, " (at %s)", timestamptz_to_str(txn.*.xact_time.commit_time));
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_change(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_relation: Relation, arg_change: [*c]ReorderBufferChange) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var relation = arg_relation;
    var change = arg_change;
    var data: [*c]TestDecodingData = undefined;
    var txndata: [*c]TestDecodingTxnData = undefined;
    var class_form: Form_pg_class = undefined;
    var tupdesc: TupleDesc = undefined;
    var old: MemoryContext = undefined;
    data = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    txndata = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !txndata.*.xact_wrote_changes) {
        pg_output_begin(ctx, data, txn, @as(c_int, 0) != 0);
    }
    txndata.*.xact_wrote_changes = @as(c_int, 1) != 0;
    class_form = relation.*.rd_rel;
    tupdesc = relation.*.rd_att;
    old = MemoryContextSwitchTo(data.*.context);
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    appendStringInfoString(ctx.*.out, "table ");
    appendStringInfoString(ctx.*.out, quote_qualified_identifier(get_namespace_name(get_rel_namespace(relation.*.rd_id)), if (class_form.*.relrewrite != 0) get_rel_name(class_form.*.relrewrite) else @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), &class_form.*.relname.data))));
    appendStringInfoChar(ctx.*.out, @bitCast(u8, @truncate(i8, @as(c_int, ':'))));
    while (true) {
        switch (change.*.action) {
            @bitCast(c_uint, @as(c_int, 0)) => {
                appendStringInfoString(ctx.*.out, " INSERT:");
                if (change.*.data.tp.newtuple == @ptrCast([*c]ReorderBufferTupleBuf, @alignCast(@import("std").meta.alignment([*c]ReorderBufferTupleBuf), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
                    appendStringInfoString(ctx.*.out, " (no-tuple-data)");
                } else {
                    tuple_to_stringinfo(ctx.*.out, tupdesc, &change.*.data.tp.newtuple.*.tuple, @as(c_int, 0) != 0);
                }
                break;
            },
            @bitCast(c_uint, @as(c_int, 1)) => {
                appendStringInfoString(ctx.*.out, " UPDATE:");
                if (change.*.data.tp.oldtuple != @ptrCast([*c]ReorderBufferTupleBuf, @alignCast(@import("std").meta.alignment([*c]ReorderBufferTupleBuf), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
                    appendStringInfoString(ctx.*.out, " old-key:");
                    tuple_to_stringinfo(ctx.*.out, tupdesc, &change.*.data.tp.oldtuple.*.tuple, @as(c_int, 1) != 0);
                    appendStringInfoString(ctx.*.out, " new-tuple:");
                }
                if (change.*.data.tp.newtuple == @ptrCast([*c]ReorderBufferTupleBuf, @alignCast(@import("std").meta.alignment([*c]ReorderBufferTupleBuf), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
                    appendStringInfoString(ctx.*.out, " (no-tuple-data)");
                } else {
                    tuple_to_stringinfo(ctx.*.out, tupdesc, &change.*.data.tp.newtuple.*.tuple, @as(c_int, 0) != 0);
                }
                break;
            },
            @bitCast(c_uint, @as(c_int, 2)) => {
                appendStringInfoString(ctx.*.out, " DELETE:");
                if (change.*.data.tp.oldtuple == @ptrCast([*c]ReorderBufferTupleBuf, @alignCast(@import("std").meta.alignment([*c]ReorderBufferTupleBuf), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
                    appendStringInfoString(ctx.*.out, " (no-tuple-data)");
                } else {
                    tuple_to_stringinfo(ctx.*.out, tupdesc, &change.*.data.tp.oldtuple.*.tuple, @as(c_int, 1) != 0);
                }
                break;
            },
            else => {
                _ = @as(c_int, 1);
            },
        }
        break;
    }
    _ = MemoryContextSwitchTo(old);
    MemoryContextReset(data.*.context);
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_truncate(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_nrelations: c_int, arg_relations: [*c]Relation, arg_change: [*c]ReorderBufferChange) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var nrelations = arg_nrelations;
    var relations = arg_relations;
    var change = arg_change;
    var data: [*c]TestDecodingData = undefined;
    var txndata: [*c]TestDecodingTxnData = undefined;
    var old: MemoryContext = undefined;
    var i: c_int = undefined;
    data = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    txndata = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !txndata.*.xact_wrote_changes) {
        pg_output_begin(ctx, data, txn, @as(c_int, 0) != 0);
    }
    txndata.*.xact_wrote_changes = @as(c_int, 1) != 0;
    old = MemoryContextSwitchTo(data.*.context);
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    appendStringInfoString(ctx.*.out, "table ");
    {
        i = 0;
        while (i < nrelations) : (i += 1) {
            if (i > @as(c_int, 0)) {
                appendStringInfoString(ctx.*.out, ", ");
            }
            appendStringInfoString(ctx.*.out, quote_qualified_identifier(get_namespace_name((blk: {
                const tmp = i;
                if (tmp >= 0) break :blk relations + @intCast(usize, tmp) else break :blk relations - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
            }).*.*.rd_rel.*.relnamespace), @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), &(blk: {
                const tmp = i;
                if (tmp >= 0) break :blk relations + @intCast(usize, tmp) else break :blk relations - ~@bitCast(usize, @intCast(isize, tmp) +% -1);
            }).*.*.rd_rel.*.relname.data))));
        }
    }
    appendStringInfoString(ctx.*.out, ": TRUNCATE:");
    if ((@as(c_int, @boolToInt(change.*.data.truncate.restart_seqs)) != 0) or (@as(c_int, @boolToInt(change.*.data.truncate.cascade)) != 0)) {
        if (change.*.data.truncate.restart_seqs) {
            appendStringInfoString(ctx.*.out, " restart_seqs");
        }
        if (change.*.data.truncate.cascade) {
            appendStringInfoString(ctx.*.out, " cascade");
        }
    } else {
        appendStringInfoString(ctx.*.out, " (no-flags)");
    }
    _ = MemoryContextSwitchTo(old);
    MemoryContextReset(data.*.context);
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_filter(arg_ctx: [*c]LogicalDecodingContext, arg_origin_id: RepOriginId) callconv(.C) bool {
    var ctx = arg_ctx;
    var origin_id = arg_origin_id;
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    if ((@as(c_int, @boolToInt(data.*.only_local)) != 0) and (@bitCast(c_int, @as(c_uint, origin_id)) != @as(c_int, 0))) return @as(c_int, 1) != 0;
    return @as(c_int, 0) != 0;
}
pub fn pg_decode_message(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_lsn: XLogRecPtr, arg_transactional: bool, arg_prefix: [*c]const u8, arg_sz: Size, arg_message: [*c]const u8) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    _ = @TypeOf(txn);
    var lsn = arg_lsn;
    _ = @TypeOf(lsn);
    var transactional = arg_transactional;
    var prefix = arg_prefix;
    var sz = arg_sz;
    var message = arg_message;
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    appendStringInfo(ctx.*.out, "message: transactional: %d prefix: %s, sz: %zu content:", @as(c_int, @boolToInt(transactional)), prefix, sz);
    appendBinaryStringInfo(ctx.*.out, @ptrCast(?*const anyopaque, message), @bitCast(c_int, @truncate(c_uint, sz)));
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_filter_prepare(arg_ctx: [*c]LogicalDecodingContext, arg_xid: TransactionId, arg_gid: [*c]const u8) callconv(.C) bool {
    var ctx = arg_ctx;
    _ = @TypeOf(ctx);
    var xid = arg_xid;
    _ = @TypeOf(xid);
    var gid = arg_gid;
    if (strstr(gid, "_nodecode") != @ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), @intToPtr(?*anyopaque, @as(c_int, 0))))) return @as(c_int, 1) != 0;
    return @as(c_int, 0) != 0;
}
pub fn pg_decode_begin_prepare_txn(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), MemoryContextAllocZero(ctx.*.context, @sizeOf(TestDecodingTxnData))));
    txndata.*.xact_wrote_changes = @as(c_int, 0) != 0;
    txn.*.output_plugin_private = @ptrCast(?*anyopaque, txndata);
    if (data.*.skip_empty_xacts) return;
    pg_output_begin(ctx, data, txn, @as(c_int, 1) != 0);
}
pub fn pg_decode_prepare_txn(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_prepare_lsn: XLogRecPtr) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var prepare_lsn = arg_prepare_lsn;
    _ = @TypeOf(prepare_lsn);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !txndata.*.xact_wrote_changes) return;
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    appendStringInfo(ctx.*.out, "PREPARE TRANSACTION %s", quote_literal_cstr(txn.*.gid));
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, ", txid %u", txn.*.xid);
    }
    if (data.*.include_timestamp) {
        appendStringInfo(ctx.*.out, " (at %s)", timestamptz_to_str(txn.*.xact_time.prepare_time));
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_commit_prepared_txn(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_commit_lsn: XLogRecPtr) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var commit_lsn = arg_commit_lsn;
    _ = @TypeOf(commit_lsn);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    appendStringInfo(ctx.*.out, "COMMIT PREPARED %s", quote_literal_cstr(txn.*.gid));
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, ", txid %u", txn.*.xid);
    }
    if (data.*.include_timestamp) {
        appendStringInfo(ctx.*.out, " (at %s)", timestamptz_to_str(txn.*.xact_time.commit_time));
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_rollback_prepared_txn(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_prepare_end_lsn: XLogRecPtr, arg_prepare_time: TimestampTz) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var prepare_end_lsn = arg_prepare_end_lsn;
    _ = @TypeOf(prepare_end_lsn);
    var prepare_time = arg_prepare_time;
    _ = @TypeOf(prepare_time);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    appendStringInfo(ctx.*.out, "ROLLBACK PREPARED %s", quote_literal_cstr(txn.*.gid));
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, ", txid %u", txn.*.xid);
    }
    if (data.*.include_timestamp) {
        appendStringInfo(ctx.*.out, " (at %s)", timestamptz_to_str(txn.*.xact_time.commit_time));
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_stream_start(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    if (txndata == @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        txndata = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), MemoryContextAllocZero(ctx.*.context, @sizeOf(TestDecodingTxnData))));
        txndata.*.xact_wrote_changes = @as(c_int, 0) != 0;
        txn.*.output_plugin_private = @ptrCast(?*anyopaque, txndata);
    }
    txndata.*.stream_wrote_changes = @as(c_int, 0) != 0;
    if (data.*.skip_empty_xacts) return;
    pg_output_stream_start(ctx, data, txn, @as(c_int, 1) != 0);
}
pub fn pg_output_stream_start(arg_ctx: [*c]LogicalDecodingContext, arg_data: [*c]TestDecodingData, arg_txn: [*c]ReorderBufferTXN, arg_last_write: bool) callconv(.C) void {
    var ctx = arg_ctx;
    var data = arg_data;
    var txn = arg_txn;
    var last_write = arg_last_write;
    OutputPluginPrepareWrite(ctx, last_write);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "opening a streamed block for transaction TXN %u", txn.*.xid);
    } else {
        appendStringInfoString(ctx.*.out, "opening a streamed block for transaction");
    }
    OutputPluginWrite(ctx, last_write);
}
pub fn pg_decode_stream_stop(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !txndata.*.stream_wrote_changes) return;
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "closing a streamed block for transaction TXN %u", txn.*.xid);
    } else {
        appendStringInfoString(ctx.*.out, "closing a streamed block for transaction");
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_stream_abort(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_abort_lsn: XLogRecPtr) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var abort_lsn = arg_abort_lsn;
    _ = @TypeOf(abort_lsn);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var toptxn: [*c]ReorderBufferTXN = if (txn.*.toptxn != @ptrCast([*c]struct_ReorderBufferTXN, @alignCast(@import("std").meta.alignment([*c]struct_ReorderBufferTXN), @intToPtr(?*anyopaque, @as(c_int, 0))))) txn.*.toptxn else txn;
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), toptxn.*.output_plugin_private));
    var xact_wrote_changes: bool = txndata.*.xact_wrote_changes;
    if (txn.*.toptxn == @ptrCast([*c]struct_ReorderBufferTXN, @alignCast(@import("std").meta.alignment([*c]struct_ReorderBufferTXN), @intToPtr(?*anyopaque, @as(c_int, 0))))) {
        _ = @as(c_int, 1);
        pfree(@ptrCast(?*anyopaque, txndata));
        txn.*.output_plugin_private = @intToPtr(?*anyopaque, @as(c_int, 0));
    }
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !xact_wrote_changes) return;
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "aborting streamed (sub)transaction TXN %u", txn.*.xid);
    } else {
        appendStringInfoString(ctx.*.out, "aborting streamed (sub)transaction");
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_stream_prepare(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_prepare_lsn: XLogRecPtr) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var prepare_lsn = arg_prepare_lsn;
    _ = @TypeOf(prepare_lsn);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !txndata.*.xact_wrote_changes) return;
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "preparing streamed transaction TXN %s, txid %u", quote_literal_cstr(txn.*.gid), txn.*.xid);
    } else {
        appendStringInfo(ctx.*.out, "preparing streamed transaction %s", quote_literal_cstr(txn.*.gid));
    }
    if (data.*.include_timestamp) {
        appendStringInfo(ctx.*.out, " (at %s)", timestamptz_to_str(txn.*.xact_time.prepare_time));
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_stream_commit(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_commit_lsn: XLogRecPtr) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var commit_lsn = arg_commit_lsn;
    _ = @TypeOf(commit_lsn);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    var xact_wrote_changes: bool = txndata.*.xact_wrote_changes;
    pfree(@ptrCast(?*anyopaque, txndata));
    txn.*.output_plugin_private = @intToPtr(?*anyopaque, @as(c_int, 0));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !xact_wrote_changes) return;
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "committing streamed transaction TXN %u", txn.*.xid);
    } else {
        appendStringInfoString(ctx.*.out, "committing streamed transaction");
    }
    if (data.*.include_timestamp) {
        appendStringInfo(ctx.*.out, " (at %s)", timestamptz_to_str(txn.*.xact_time.commit_time));
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_stream_change(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_relation: Relation, arg_change: [*c]ReorderBufferChange) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var relation = arg_relation;
    _ = @TypeOf(relation);
    var change = arg_change;
    _ = @TypeOf(change);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !txndata.*.stream_wrote_changes) {
        pg_output_stream_start(ctx, data, txn, @as(c_int, 0) != 0);
    }
    txndata.*.xact_wrote_changes = blk: {
        const tmp = @as(c_int, 1) != 0;
        txndata.*.stream_wrote_changes = tmp;
        break :blk tmp;
    };
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "streaming change for TXN %u", txn.*.xid);
    } else {
        appendStringInfoString(ctx.*.out, "streaming change for transaction");
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_stream_message(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_lsn: XLogRecPtr, arg_transactional: bool, arg_prefix: [*c]const u8, arg_sz: Size, arg_message: [*c]const u8) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    _ = @TypeOf(txn);
    var lsn = arg_lsn;
    _ = @TypeOf(lsn);
    var transactional = arg_transactional;
    var prefix = arg_prefix;
    var sz = arg_sz;
    var message = arg_message;
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    if (transactional) {
        appendStringInfo(ctx.*.out, "streaming message: transactional: %d prefix: %s, sz: %zu", @as(c_int, @boolToInt(transactional)), prefix, sz);
    } else {
        appendStringInfo(ctx.*.out, "streaming message: transactional: %d prefix: %s, sz: %zu content:", @as(c_int, @boolToInt(transactional)), prefix, sz);
        appendBinaryStringInfo(ctx.*.out, @ptrCast(?*const anyopaque, message), @bitCast(c_int, @truncate(c_uint, sz)));
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn pg_decode_stream_truncate(arg_ctx: [*c]LogicalDecodingContext, arg_txn: [*c]ReorderBufferTXN, arg_nrelations: c_int, arg_relations: [*c]Relation, arg_change: [*c]ReorderBufferChange) callconv(.C) void {
    var ctx = arg_ctx;
    var txn = arg_txn;
    var nrelations = arg_nrelations;
    _ = @TypeOf(nrelations);
    var relations = arg_relations;
    _ = @TypeOf(relations);
    var change = arg_change;
    _ = @TypeOf(change);
    var data: [*c]TestDecodingData = @ptrCast([*c]TestDecodingData, @alignCast(@import("std").meta.alignment([*c]TestDecodingData), ctx.*.output_plugin_private));
    var txndata: [*c]TestDecodingTxnData = @ptrCast([*c]TestDecodingTxnData, @alignCast(@import("std").meta.alignment([*c]TestDecodingTxnData), txn.*.output_plugin_private));
    if ((@as(c_int, @boolToInt(data.*.skip_empty_xacts)) != 0) and !txndata.*.stream_wrote_changes) {
        pg_output_stream_start(ctx, data, txn, @as(c_int, 0) != 0);
    }
    txndata.*.xact_wrote_changes = blk: {
        const tmp = @as(c_int, 1) != 0;
        txndata.*.stream_wrote_changes = tmp;
        break :blk tmp;
    };
    OutputPluginPrepareWrite(ctx, @as(c_int, 1) != 0);
    if (data.*.include_xids) {
        appendStringInfo(ctx.*.out, "streaming truncate for TXN %u", txn.*.xid);
    } else {
        appendStringInfoString(ctx.*.out, "streaming truncate for transaction");
    }
    OutputPluginWrite(ctx, @as(c_int, 1) != 0);
}
pub fn print_literal(arg_s: StringInfo, arg_typid: Oid, arg_outputstr: [*c]u8) callconv(.C) void {
    var s = arg_s;
    var typid = arg_typid;
    var outputstr = arg_outputstr;
    var valptr: [*c]const u8 = undefined;
    while (true) {
        switch (typid) {
            @bitCast(Oid, @as(c_int, 21)), @bitCast(Oid, @as(c_int, 23)), @bitCast(Oid, @as(c_int, 20)), @bitCast(Oid, @as(c_int, 26)), @bitCast(Oid, @as(c_int, 700)), @bitCast(Oid, @as(c_int, 701)), @bitCast(Oid, @as(c_int, 1700)) => {
                appendStringInfoString(s, outputstr);
                break;
            },
            @bitCast(Oid, @as(c_int, 1560)), @bitCast(Oid, @as(c_int, 1562)) => {
                appendStringInfo(s, "B'%s'", outputstr);
                break;
            },
            @bitCast(Oid, @as(c_int, 16)) => {
                if (strcmp(outputstr, "t") == @as(c_int, 0)) {
                    appendStringInfoString(s, "true");
                } else {
                    appendStringInfoString(s, "false");
                }
                break;
            },
            else => {
                appendStringInfoChar(s, @bitCast(u8, @truncate(i8, @as(c_int, '\''))));
                {
                    valptr = outputstr;
                    while (valptr.* != 0) : (valptr += 1) {
                        var ch: u8 = valptr.*;
                        if ((@bitCast(c_int, @as(c_uint, ch)) == @as(c_int, '\'')) or ((@bitCast(c_int, @as(c_uint, ch)) == @as(c_int, '\\')) and (@as(c_int, 0) != 0))) {
                            appendStringInfoChar(s, ch);
                        }
                        appendStringInfoChar(s, ch);
                    }
                }
                appendStringInfoChar(s, @bitCast(u8, @truncate(i8, @as(c_int, '\''))));
                break;
            },
        }
        break;
    }
}
pub fn tuple_to_stringinfo(arg_s: StringInfo, arg_tupdesc: TupleDesc, arg_tuple: HeapTuple, arg_skip_nulls: bool) callconv(.C) void {
    var s = arg_s;
    var tupdesc = arg_tupdesc;
    var tuple = arg_tuple;
    var skip_nulls = arg_skip_nulls;
    var natt: c_int = undefined;
    {
        natt = 0;
        while (natt < tupdesc.*.natts) : (natt += 1) {
            var attr: Form_pg_attribute = undefined;
            var typid: Oid = undefined;
            var typoutput: Oid = undefined;
            var typisvarlena: bool = undefined;
            var origval: Datum = undefined;
            var isnull: bool = undefined;
            attr = &tupdesc.*.attrs()[@intCast(c_uint, natt)];
            if (attr.*.attisdropped) continue;
            if (@bitCast(c_int, @as(c_int, attr.*.attnum)) < @as(c_int, 0)) continue;
            typid = attr.*.atttypid;
            origval = heap_getattr(tuple, natt + @as(c_int, 1), tupdesc, &isnull);
            if ((@as(c_int, @boolToInt(isnull)) != 0) and (@as(c_int, @boolToInt(skip_nulls)) != 0)) continue;
            appendStringInfoChar(s, @bitCast(u8, @truncate(i8, @as(c_int, ' '))));
            appendStringInfoString(s, quote_identifier(@ptrCast([*c]u8, @alignCast(@import("std").meta.alignment([*c]u8), &attr.*.attname.data))));
            appendStringInfoChar(s, @bitCast(u8, @truncate(i8, @as(c_int, '['))));
            appendStringInfoString(s, format_type_be(typid));
            appendStringInfoChar(s, @bitCast(u8, @truncate(i8, @as(c_int, ']'))));
            getTypeOutputInfo(typid, &typoutput, &typisvarlena);
            appendStringInfoChar(s, @bitCast(u8, @truncate(i8, @as(c_int, ':'))));
            if (isnull) {
                appendStringInfoString(s, "null");
            } else if ((@as(c_int, @boolToInt(typisvarlena)) != 0) and ((@bitCast(c_int, @as(c_uint, @intToPtr([*c]varattrib_1b, origval).*.va_header)) == @as(c_int, 1)) and (@bitCast(c_int, @as(c_uint, @intToPtr([*c]varattrib_1b_e, origval).*.va_tag)) == VARTAG_ONDISK))) {
                appendStringInfoString(s, "unchanged-toast-datum");
            } else if (!typisvarlena) {
                print_literal(s, typid, OidOutputFunctionCall(typoutput, origval));
            } else {
                var val: Datum = undefined;
                val = PointerGetDatum(@ptrCast(?*const anyopaque, pg_detoast_datum(@ptrCast([*c]struct_varlena, @alignCast(@import("std").meta.alignment([*c]struct_varlena), DatumGetPointer(origval))))));
                print_literal(s, typid, OidOutputFunctionCall(typoutput, val));
            }
        }
    }
}
pub const __INTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`"); // (no file):80:9
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`"); // (no file):86:9
pub const __FLT16_DENORM_MIN__ = @compileError("unable to translate C expr: unexpected token 'IntegerLiteral'"); // (no file):109:9
pub const __FLT16_EPSILON__ = @compileError("unable to translate C expr: unexpected token 'IntegerLiteral'"); // (no file):113:9
pub const __FLT16_MAX__ = @compileError("unable to translate C expr: unexpected token 'IntegerLiteral'"); // (no file):119:9
pub const __FLT16_MIN__ = @compileError("unable to translate C expr: unexpected token 'IntegerLiteral'"); // (no file):122:9
pub const __INT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`"); // (no file):183:9
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`"); // (no file):205:9
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`"); // (no file):213:9
pub const __seg_gs = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // (no file):343:9
pub const __seg_fs = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // (no file):344:9
pub const PG_INT128_TYPE = @compileError("unable to translate macro: undefined identifier `__int128`"); // ../../src/include/pg_config.h:622:9
pub const PG_PRINTF_ATTRIBUTE = @compileError("unable to translate macro: undefined identifier `gnu_printf`"); // ../../src/include/pg_config.h:641:9
pub const pg_restrict = @compileError("unable to translate macro: undefined identifier `__restrict`"); // ../../src/include/pg_config.h:811:9
pub const restrict = @compileError("unable to translate macro: undefined identifier `__restrict`"); // ../../src/include/pg_config.h:816:9
pub const __GLIBC_USE = @compileError("unable to translate macro: undefined identifier `__GLIBC_USE_`"); // /usr/include/features.h:187:9
pub const __glibc_has_attribute = @compileError("unable to translate macro: undefined identifier `__has_attribute`"); // /usr/include/sys/cdefs.h:45:10
pub const __glibc_has_extension = @compileError("unable to translate macro: undefined identifier `__has_extension`"); // /usr/include/sys/cdefs.h:55:10
pub const __THROW = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:79:11
pub const __THROWNL = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:80:11
pub const __NTH = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:81:11
pub const __NTHNL = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:82:11
pub const __CONCAT = @compileError("unable to translate C expr: unexpected token '##'"); // /usr/include/sys/cdefs.h:124:9
pub const __STRING = @compileError("unable to translate C expr: unexpected token '#'"); // /usr/include/sys/cdefs.h:125:9
pub const __warnattr = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:209:10
pub const __errordecl = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/sys/cdefs.h:210:10
pub const __flexarr = @compileError("unable to translate C expr: unexpected token '['"); // /usr/include/sys/cdefs.h:218:10
pub const __REDIRECT = @compileError("unable to translate macro: undefined identifier `__asm__`"); // /usr/include/sys/cdefs.h:249:10
pub const __REDIRECT_NTH = @compileError("unable to translate macro: undefined identifier `__asm__`"); // /usr/include/sys/cdefs.h:256:11
pub const __REDIRECT_NTHNL = @compileError("unable to translate macro: undefined identifier `__asm__`"); // /usr/include/sys/cdefs.h:258:11
pub const __ASMNAME2 = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/sys/cdefs.h:262:10
pub const __attribute_malloc__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:283:10
pub const __attribute_alloc_size__ = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:294:10
pub const __attribute_alloc_align__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:300:10
pub const __attribute_pure__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:310:10
pub const __attribute_const__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:317:10
pub const __attribute_maybe_unused__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:323:10
pub const __attribute_used__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:332:10
pub const __attribute_noinline__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:333:10
pub const __attribute_deprecated__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:341:10
pub const __attribute_deprecated_msg__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:351:10
pub const __attribute_format_arg__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:364:10
pub const __attribute_format_strfmon__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:374:10
pub const __attribute_nonnull__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:386:11
pub const __returns_nonnull = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:399:10
pub const __attribute_warn_unused_result__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:408:10
pub const __always_inline = @compileError("unable to translate macro: undefined identifier `__inline`"); // /usr/include/sys/cdefs.h:426:10
pub const __attribute_artificial__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:435:10
pub const __extern_inline = @compileError("unable to translate macro: undefined identifier `__inline`"); // /usr/include/sys/cdefs.h:453:11
pub const __extern_always_inline = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:454:11
pub const __restrict_arr = @compileError("unable to translate macro: undefined identifier `__restrict`"); // /usr/include/sys/cdefs.h:497:10
pub const __attribute_copy__ = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:546:10
pub const __LDBL_REDIR2_DECL = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:622:10
pub const __LDBL_REDIR_DECL = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:623:10
pub const __glibc_macro_warning1 = @compileError("unable to translate macro: undefined identifier `_Pragma`"); // /usr/include/sys/cdefs.h:637:10
pub const __glibc_macro_warning = @compileError("unable to translate macro: undefined identifier `GCC`"); // /usr/include/sys/cdefs.h:638:10
pub const __fortified_attr_access = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:683:11
pub const __attr_access = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:684:11
pub const __attr_access_none = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:685:11
pub const __attr_dealloc = @compileError("unable to translate C expr: unexpected token 'Eof'"); // /usr/include/sys/cdefs.h:695:10
pub const __attribute_returns_twice__ = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/sys/cdefs.h:702:10
pub const va_start = @compileError("unable to translate macro: undefined identifier `__builtin_va_start`"); // /usr/lib/zig/include/stdarg.h:17:9
pub const va_end = @compileError("unable to translate macro: undefined identifier `__builtin_va_end`"); // /usr/lib/zig/include/stdarg.h:18:9
pub const va_arg = @compileError("unable to translate macro: undefined identifier `__builtin_va_arg`"); // /usr/lib/zig/include/stdarg.h:19:9
pub const __va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`"); // /usr/lib/zig/include/stdarg.h:24:9
pub const va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`"); // /usr/lib/zig/include/stdarg.h:27:9
pub const __STD_TYPE = @compileError("unable to translate C expr: unexpected token 'typedef'"); // /usr/include/bits/types.h:137:10
pub const __FSID_T_TYPE = @compileError("unable to translate macro: undefined identifier `__val`"); // /usr/include/bits/typesizes.h:73:9
pub const __getc_unlocked_body = @compileError("TODO postfix inc/dec expr"); // /usr/include/bits/types/struct_FILE.h:102:9
pub const __putc_unlocked_body = @compileError("TODO postfix inc/dec expr"); // /usr/include/bits/types/struct_FILE.h:106:9
pub const __CFLOAT32 = @compileError("unable to translate: TODO _Complex"); // /usr/include/bits/floatn-common.h:149:12
pub const __CFLOAT64 = @compileError("unable to translate: TODO _Complex"); // /usr/include/bits/floatn-common.h:160:13
pub const __CFLOAT32X = @compileError("unable to translate: TODO _Complex"); // /usr/include/bits/floatn-common.h:169:12
pub const __CFLOAT64X = @compileError("unable to translate: TODO _Complex"); // /usr/include/bits/floatn-common.h:178:13
pub const __builtin_nansf32 = @compileError("unable to translate macro: undefined identifier `__builtin_nansf`"); // /usr/include/bits/floatn-common.h:221:12
pub const __builtin_huge_valf64 = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`"); // /usr/include/bits/floatn-common.h:255:13
pub const __builtin_inff64 = @compileError("unable to translate macro: undefined identifier `__builtin_inf`"); // /usr/include/bits/floatn-common.h:256:13
pub const __builtin_nanf64 = @compileError("unable to translate macro: undefined identifier `__builtin_nan`"); // /usr/include/bits/floatn-common.h:257:13
pub const __builtin_nansf64 = @compileError("unable to translate macro: undefined identifier `__builtin_nans`"); // /usr/include/bits/floatn-common.h:258:13
pub const __builtin_huge_valf32x = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`"); // /usr/include/bits/floatn-common.h:272:12
pub const __builtin_inff32x = @compileError("unable to translate macro: undefined identifier `__builtin_inf`"); // /usr/include/bits/floatn-common.h:273:12
pub const __builtin_nanf32x = @compileError("unable to translate macro: undefined identifier `__builtin_nan`"); // /usr/include/bits/floatn-common.h:274:12
pub const __builtin_nansf32x = @compileError("unable to translate macro: undefined identifier `__builtin_nans`"); // /usr/include/bits/floatn-common.h:275:12
pub const __builtin_huge_valf64x = @compileError("unable to translate macro: undefined identifier `__builtin_huge_vall`"); // /usr/include/bits/floatn-common.h:289:13
pub const __builtin_inff64x = @compileError("unable to translate macro: undefined identifier `__builtin_infl`"); // /usr/include/bits/floatn-common.h:290:13
pub const __builtin_nanf64x = @compileError("unable to translate macro: undefined identifier `__builtin_nanl`"); // /usr/include/bits/floatn-common.h:291:13
pub const __builtin_nansf64x = @compileError("unable to translate macro: undefined identifier `__builtin_nansl`"); // /usr/include/bits/floatn-common.h:292:13
pub const __FD_ZERO = @compileError("unable to translate macro: undefined identifier `__i`"); // /usr/include/bits/select.h:25:9
pub const __FD_SET = @compileError("unable to translate C expr: expected ')' instead got '|='"); // /usr/include/bits/select.h:32:9
pub const __FD_CLR = @compileError("unable to translate C expr: expected ')' instead got '&='"); // /usr/include/bits/select.h:34:9
pub const __PTHREAD_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/bits/struct_mutex.h:56:10
pub const __PTHREAD_RWLOCK_ELISION_EXTRA = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/bits/struct_rwlock.h:40:11
pub const __ONCE_FLAG_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/bits/thread-shared-types.h:113:9
pub const offsetof = @compileError("unable to translate macro: undefined identifier `__builtin_offsetof`"); // /usr/lib/zig/include/stddef.h:104:9
pub const pg_attribute_unused = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:118:9
pub const pg_nodiscard = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:130:9
pub const pg_attribute_no_sanitize_alignment = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:142:9
pub const pg_attribute_nonnull = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/c.h:153:9
pub const pg_attribute_format_arg = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:171:9
pub const pg_attribute_printf = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:172:9
pub const pg_attribute_aligned = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:180:9
pub const pg_attribute_noreturn = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:181:9
pub const pg_attribute_packed = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:182:9
pub const pg_attribute_always_inline = @compileError("unable to translate C expr: unexpected token 'inline'"); // ../../src/include/c.h:218:9
pub const pg_noinline = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:229:9
pub const pg_attribute_cold = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:257:9
pub const pg_attribute_hot = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:263:9
pub const CppAsString = @compileError("unable to translate C expr: unexpected token '#'"); // ../../src/include/c.h:310:9
pub const CppConcat = @compileError("unable to translate C expr: unexpected token '##'"); // ../../src/include/c.h:312:9
pub const VA_ARGS_NARGS = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/c.h:346:9
pub const VA_ARGS_NARGS_ = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/c.h:357:9
pub const PointerIsValid = @compileError("unable to translate C expr: unexpected token 'const'"); // ../../src/include/c.h:747:9
pub const lengthof = @compileError("unable to translate C expr: unexpected token '('"); // ../../src/include/c.h:772:9
pub const StaticAssertDecl = @compileError("unable to translate C expr: unexpected token '_Static_assert'"); // ../../src/include/c.h:913:9
pub const StaticAssertStmt = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/c.h:915:9
pub const StaticAssertExpr = @compileError("unable to translate C expr: unexpected token '{'"); // ../../src/include/c.h:917:9
pub const AssertVariableIsOfType = @compileError("unable to translate macro: undefined identifier `__builtin_types_compatible_p`"); // ../../src/include/c.h:958:9
pub const AssertVariableIsOfTypeMacro = @compileError("unable to translate macro: undefined identifier `__builtin_types_compatible_p`"); // ../../src/include/c.h:961:9
pub const MemSet = @compileError("unable to translate macro: undefined identifier `_vstart`"); // ../../src/include/c.h:1004:9
pub const MemSetAligned = @compileError("unable to translate macro: undefined identifier `_start`"); // ../../src/include/c.h:1037:9
pub const MemSetLoop = @compileError("unable to translate macro: undefined identifier `_start`"); // ../../src/include/c.h:1072:9
pub const INVERT_COMPARE_RESULT = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/c.h:1117:9
pub const unconstify = @compileError("unable to translate macro: undefined identifier `__builtin_types_compatible_p`"); // ../../src/include/c.h:1244:9
pub const unvolatize = @compileError("unable to translate macro: undefined identifier `__builtin_types_compatible_p`"); // ../../src/include/c.h:1248:9
pub const PGDLLEXPORT = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // ../../src/include/c.h:1337:9
pub const SIGNAL_ARGS = @compileError("unable to translate macro: undefined identifier `postgres_signal_arg`"); // ../../src/include/c.h:1353:9
pub const __exctype = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/ctype.h:102:9
pub const __tobody = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/ctype.h:155:9
pub const __exctype_l = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/ctype.h:244:10
pub const ALL_CONNECTION_FAILURE_ERRNOS = @compileError("unable to translate C expr: unexpected token ':'"); // ../../src/include/port.h:121:9
pub const pg_pread = @compileError("unable to translate macro: undefined identifier `pread`"); // ../../src/include/port.h:225:9
pub const pg_pwrite = @compileError("unable to translate macro: undefined identifier `pwrite`"); // ../../src/include/port.h:226:9
pub const TIMEZONE_GLOBAL = @compileError("unable to translate macro: undefined identifier `timezone`"); // ../../src/include/port.h:268:9
pub const TZNAME_GLOBAL = @compileError("unable to translate macro: undefined identifier `tzname`"); // ../../src/include/port.h:269:9
pub const closesocket = @compileError("unable to translate macro: undefined identifier `close`"); // ../../src/include/port.h:349:9
pub const HUGE_VAL = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`"); // /usr/include/math.h:48:10
pub const HUGE_VALL = @compileError("unable to translate macro: undefined identifier `__builtin_huge_vall`"); // /usr/include/math.h:60:11
pub const __GLIBC_FLT_EVAL_METHOD = @compileError("unable to translate macro: undefined identifier `__FLT_EVAL_METHOD__`"); // /usr/include/bits/flt-eval-method.h:27:11
pub const __SIMD_DECL = @compileError("unable to translate macro: undefined identifier `__DECL_SIMD_`"); // /usr/include/math.h:276:9
pub const __MATHCALL_VEC = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/math.h:278:9
pub const __MATHDECL_VEC = @compileError("unable to translate C expr: unexpected token 'Identifier'"); // /usr/include/math.h:282:9
pub const __MATHDECL = @compileError("unable to translate macro: undefined identifier `__`"); // /usr/include/math.h:288:9
pub const __MATHDECLX = @compileError("unable to translate macro: undefined identifier `__attribute__`"); // /usr/include/math.h:293:9
pub const __MATHDECL_1_IMPL = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/math.h:296:9
pub const __MATHREDIR = @compileError("unable to translate C expr: unexpected token 'extern'"); // /usr/include/math.h:305:9
pub const __MATHCALL_NARROW_ARGS_1 = @compileError("unable to translate macro: undefined identifier `_Marg_`"); // /usr/include/math.h:550:9
pub const __MATHCALL_NARROW_ARGS_2 = @compileError("unable to translate macro: undefined identifier `_Marg_`"); // /usr/include/math.h:551:9
pub const __MATHCALL_NARROW_ARGS_3 = @compileError("unable to translate macro: undefined identifier `_Marg_`"); // /usr/include/math.h:552:9
pub const __MATHCALL_NARROW_NORMAL = @compileError("unable to translate macro: undefined identifier `_Mret_`"); // /usr/include/math.h:553:9
pub const __MATHCALL_NARROW_REDIR = @compileError("unable to translate macro: undefined identifier `_Mret_`"); // /usr/include/math.h:555:9
pub const __MATH_TG = @compileError("unable to translate macro: undefined identifier `f`"); // /usr/include/math.h:922:10
pub const fpclassify = @compileError("unable to translate macro: undefined identifier `__builtin_fpclassify`"); // /usr/include/math.h:967:11
pub const isfinite = @compileError("unable to translate macro: undefined identifier `__builtin_isfinite`"); // /usr/include/math.h:994:11
pub const isnormal = @compileError("unable to translate macro: undefined identifier `__builtin_isnormal`"); // /usr/include/math.h:1002:11
pub const isgreater = @compileError("unable to translate macro: undefined identifier `__builtin_isgreater`"); // /usr/include/math.h:1305:11
pub const isgreaterequal = @compileError("unable to translate macro: undefined identifier `__builtin_isgreaterequal`"); // /usr/include/math.h:1306:11
pub const isless = @compileError("unable to translate macro: undefined identifier `__builtin_isless`"); // /usr/include/math.h:1307:11
pub const islessequal = @compileError("unable to translate macro: undefined identifier `__builtin_islessequal`"); // /usr/include/math.h:1308:11
pub const islessgreater = @compileError("unable to translate macro: undefined identifier `__builtin_islessgreater`"); // /usr/include/math.h:1309:11
pub const isunordered = @compileError("unable to translate macro: undefined identifier `__builtin_isunordered`"); // /usr/include/math.h:1310:11
pub const appendStringInfoCharMacro = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/lib/stringinfo.h:128:9
pub const ereport_domain = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:141:9
pub const ereport = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:163:9
pub const elog = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:238:9
pub const errsave_domain = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:266:9
pub const errsave = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:274:9
pub const ereturn_domain = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:284:9
pub const ereturn = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:290:9
pub const PG_TRY = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:384:9
pub const PG_CATCH = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:394:9
pub const PG_FINALLY = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:401:9
pub const PG_END_TRY = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/elog.h:409:9
pub const palloc_object = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/utils/palloc.h:96:9
pub const palloc0_object = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/utils/palloc.h:97:9
pub const palloc_array = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/utils/palloc.h:102:9
pub const palloc0_array = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/utils/palloc.h:103:9
pub const repalloc_array = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/utils/palloc.h:109:9
pub const repalloc0_array = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/utils/palloc.h:110:9
pub const NON_EXEC_STATIC = @compileError("unable to translate C expr: unexpected token 'static'"); // ../../src/include/postgres.h:576:9
pub const CATALOG = @compileError("unable to translate macro: undefined identifier `FormData_`"); // ../../src/include/catalog/genbki.h:23:9
pub const BKI_ROWTYPE_OID = @compileError("unable to translate C expr: unexpected token 'Eof'"); // ../../src/include/catalog/genbki.h:28:9
pub const BKI_DEFAULT = @compileError("unable to translate C expr: unexpected token 'Eof'"); // ../../src/include/catalog/genbki.h:35:9
pub const BKI_ARRAY_DEFAULT = @compileError("unable to translate C expr: unexpected token 'Eof'"); // ../../src/include/catalog/genbki.h:37:9
pub const BKI_LOOKUP = @compileError("unable to translate C expr: unexpected token 'Eof'"); // ../../src/include/catalog/genbki.h:46:9
pub const BKI_LOOKUP_OPT = @compileError("unable to translate C expr: unexpected token 'Eof'"); // ../../src/include/catalog/genbki.h:47:9
pub const DECLARE_TOAST = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:63:9
pub const DECLARE_TOAST_WITH_MACRO = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:64:9
pub const DECLARE_INDEX = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:83:9
pub const DECLARE_UNIQUE_INDEX = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:84:9
pub const DECLARE_UNIQUE_INDEX_PKEY = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:85:9
pub const DECLARE_OID_DEFINING_MACRO = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:93:9
pub const DECLARE_FOREIGN_KEY = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:117:9
pub const DECLARE_FOREIGN_KEY_OPT = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:118:9
pub const DECLARE_ARRAY_FOREIGN_KEY = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:119:9
pub const DECLARE_ARRAY_FOREIGN_KEY_OPT = @compileError("unable to translate C expr: unexpected token 'extern'"); // ../../src/include/catalog/genbki.h:120:9
pub const ItemIdSetUnused = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/storage/itemid.h:128:9
pub const ItemIdSetNormal = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/storage/itemid.h:140:9
pub const ItemIdSetRedirect = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/storage/itemid.h:152:9
pub const ItemIdSetDead = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/storage/itemid.h:164:9
pub const ItemIdMarkDead = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/storage/itemid.h:179:9
pub const PG_RETURN_ITEMPOINTER = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/storage/itemptr.h:243:9
pub const pg_node_attr = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/nodes/nodes.h:120:9
pub const nodeTag = @compileError("unable to translate C expr: unexpected token 'const'"); // ../../src/include/nodes/nodes.h:133:9
pub const newNode = @compileError("unable to translate macro: undefined identifier `_result`"); // ../../src/include/nodes/nodes.h:149:9
pub const makeNode = @compileError("unable to translate macro: undefined identifier `T_`"); // ../../src/include/nodes/nodes.h:176:9
pub const NodeSetTag = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/nodes/nodes.h:177:9
pub const IsA = @compileError("unable to translate macro: undefined identifier `T_`"); // ../../src/include/nodes/nodes.h:179:9
pub const castNode = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/nodes/nodes.h:197:9
pub const copyObject = @compileError("unable to translate macro: undefined identifier `typeof`"); // ../../src/include/nodes/nodes.h:242:9
pub const foreach = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:373:9
pub const foreach_delete_current = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:390:9
pub const foreach_current_index = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:403:9
pub const for_each_from = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:414:9
pub const for_each_cell = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:438:9
pub const forboth = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:467:9
pub const multi_for_advance_cell = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/nodes/pg_list.h:474:9
pub const for_both_cell = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:489:9
pub const forthree = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:512:9
pub const forfour = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:524:9
pub const forfive = @compileError("unable to translate macro: undefined identifier `__state`"); // ../../src/include/nodes/pg_list.h:537:9
pub const ATTRIBUTE_FIXED_PART_SIZE = @compileError("unable to translate macro: undefined identifier `attcollation`"); // ../../src/include/catalog/pg_attribute.h:201:9
pub const TupleDescSize = @compileError("unable to translate macro: undefined identifier `attrs`"); // ../../src/include/access/tupdesc.h:102:9
pub const PinTupleDesc = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/access/tupdesc.h:116:9
pub const ReleaseTupleDesc = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/access/tupdesc.h:122:9
pub const AssertPendingSyncs_RelationCache = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/utils/relcache.h:135:9
pub const ObjectAddressSubSet = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/catalog/objectaddress.h:33:9
pub const IsTrueArrayType = @compileError("unable to translate macro: undefined identifier `F_ARRAY_SUBSCRIPT_HANDLER`"); // ../../src/include/catalog/pg_type_d.h:123:9
pub const st_atime = @compileError("unable to translate macro: undefined identifier `st_atim`"); // /usr/include/bits/struct_stat.h:77:11
pub const st_mtime = @compileError("unable to translate macro: undefined identifier `st_mtim`"); // /usr/include/bits/struct_stat.h:78:11
pub const st_ctime = @compileError("unable to translate macro: undefined identifier `st_ctim`"); // /usr/include/bits/struct_stat.h:79:11
pub const TIMESTAMP_NOBEGIN = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/datatype/timestamp.h:158:9
pub const TIMESTAMP_NOEND = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/datatype/timestamp.h:163:9
pub const TransactionIdStore = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/access/transam.h:44:9
pub const StoreInvalidTransactionId = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/access/transam.h:45:9
pub const TransactionIdAdvance = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/access/transam.h:91:9
pub const TransactionIdRetreat = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/access/transam.h:141:9
pub const PG_RMGR = @compileError("unable to translate C expr: unexpected token 'Eof'"); // ../../src/include/access/rmgr.h:22:9
pub const INIT_CRC32C = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/port/pg_crc32c.h:41:9
pub const COMP_CRC32C = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/port/pg_crc32c.h:67:9
pub const FIN_CRC32C = @compileError("unable to translate C expr: expected ')' instead got '^='"); // ../../src/include/port/pg_crc32c.h:69:9
pub const SizeOfXLogRecord = @compileError("unable to translate macro: undefined identifier `xl_crc`"); // ../../src/include/access/xlogrecord.h:55:9
pub const SizeOfXLogRecordBlockHeader = @compileError("unable to translate macro: undefined identifier `data_length`"); // ../../src/include/access/xlogrecord.h:115:9
pub const SizeOfXLogRecordBlockImageHeader = @compileError("unable to translate macro: undefined identifier `bimg_info`"); // ../../src/include/access/xlogrecord.h:153:9
pub const XL_ROUTINE = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/access/xlogreader.h:117:9
pub const PageXLogRecPtrSet = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/storage/bufpage.h:106:9
pub const SizeOfPageHeaderData = @compileError("unable to translate macro: undefined identifier `pd_linp`"); // ../../src/include/storage/bufpage.h:214:9
pub const PageSetPrunable = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/storage/bufpage.h:445:9
pub const PageClearPrunable = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/storage/bufpage.h:452:9
pub const SET_VARSIZE_4B = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/varatt.h:232:9
pub const SET_VARSIZE_4B_C = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/varatt.h:234:9
pub const SET_VARSIZE_1B = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/varatt.h:236:9
pub const SET_VARTAG_1B_E = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/varatt.h:238:9
pub const VARHDRSZ_EXTERNAL = @compileError("unable to translate macro: undefined identifier `va_data`"); // ../../src/include/varatt.h:253:9
pub const VARHDRSZ_COMPRESSED = @compileError("unable to translate macro: undefined identifier `va_compressed`"); // ../../src/include/varatt.h:254:9
pub const VARHDRSZ_SHORT = @compileError("unable to translate macro: undefined identifier `va_data`"); // ../../src/include/varatt.h:255:9
pub const VARATT_EXTERNAL_SET_SIZE_AND_COMPRESS_METHOD = @compileError("unable to translate macro: undefined identifier `TOAST_PGLZ_COMPRESSION_ID`"); // ../../src/include/varatt.h:339:9
pub const SizeofHeapTupleHeader = @compileError("unable to translate macro: undefined identifier `t_bits`"); // ../../src/include/access/htup_details.h:185:9
pub const HeapTupleHeaderSetXmin = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/access/htup_details.h:320:9
pub const HeapTupleHeaderSetXminCommitted = @compileError("unable to translate C expr: expected ')' instead got '|='"); // ../../src/include/access/htup_details.h:341:9
pub const HeapTupleHeaderSetXminInvalid = @compileError("unable to translate C expr: expected ')' instead got '|='"); // ../../src/include/access/htup_details.h:347:9
pub const HeapTupleHeaderSetXminFrozen = @compileError("unable to translate C expr: expected ')' instead got '|='"); // ../../src/include/access/htup_details.h:353:9
pub const HeapTupleHeaderSetXmax = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/access/htup_details.h:381:9
pub const HeapTupleHeaderSetCmin = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/access/htup_details.h:398:9
pub const HeapTupleHeaderSetCmax = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/access/htup_details.h:406:9
pub const HeapTupleHeaderSetXvac = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/access/htup_details.h:424:9
pub const HeapTupleHeaderSetTypeId = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/access/htup_details.h:466:9
pub const HeapTupleHeaderSetTypMod = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/access/htup_details.h:476:9
pub const HeapTupleHeaderSetHotUpdated = @compileError("unable to translate C expr: expected ')' instead got '|='"); // ../../src/include/access/htup_details.h:494:9
pub const HeapTupleHeaderClearHotUpdated = @compileError("unable to translate C expr: expected ')' instead got '&='"); // ../../src/include/access/htup_details.h:499:9
pub const HeapTupleHeaderSetHeapOnly = @compileError("unable to translate C expr: expected ')' instead got '|='"); // ../../src/include/access/htup_details.h:509:9
pub const HeapTupleHeaderClearHeapOnly = @compileError("unable to translate C expr: expected ')' instead got '&='"); // ../../src/include/access/htup_details.h:514:9
pub const HeapTupleHeaderSetMatch = @compileError("unable to translate C expr: expected ')' instead got '|='"); // ../../src/include/access/htup_details.h:524:9
pub const HeapTupleHeaderClearMatch = @compileError("unable to translate C expr: expected ')' instead got '&='"); // ../../src/include/access/htup_details.h:529:9
pub const HeapTupleHeaderSetNatts = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/access/htup_details.h:537:9
pub const MINIMAL_TUPLE_OFFSET = @compileError("unable to translate macro: undefined identifier `t_infomask2`"); // ../../src/include/access/htup_details.h:622:9
pub const MINIMAL_TUPLE_PADDING = @compileError("unable to translate macro: undefined identifier `t_infomask2`"); // ../../src/include/access/htup_details.h:624:9
pub const MINIMAL_TUPLE_DATA_OFFSET = @compileError("unable to translate macro: undefined identifier `t_infomask2`"); // ../../src/include/access/htup_details.h:626:9
pub const SizeofMinimalTupleHeader = @compileError("unable to translate macro: undefined identifier `t_bits`"); // ../../src/include/access/htup_details.h:652:9
pub const DLIST_STATIC_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // ../../src/include/lib/ilist.h:281:9
pub const DCLIST_STATIC_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // ../../src/include/lib/ilist.h:282:9
pub const SLIST_STATIC_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // ../../src/include/lib/ilist.h:283:9
pub const dlist_container = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/lib/ilist.h:593:9
pub const dlist_head_element = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/lib/ilist.h:603:9
pub const dlist_tail_element = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/lib/ilist.h:612:9
pub const dlist_foreach = @compileError("unable to translate C expr: unexpected token 'for'"); // ../../src/include/lib/ilist.h:623:9
pub const dlist_foreach_modify = @compileError("unable to translate C expr: unexpected token 'for'"); // ../../src/include/lib/ilist.h:640:9
pub const dlist_reverse_foreach = @compileError("unable to translate C expr: unexpected token 'for'"); // ../../src/include/lib/ilist.h:654:9
pub const dclist_head_element = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/lib/ilist.h:955:9
pub const dclist_tail_element = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/lib/ilist.h:964:9
pub const slist_container = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/lib/ilist.h:1106:9
pub const slist_head_element = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/lib/ilist.h:1116:9
pub const slist_foreach = @compileError("unable to translate C expr: unexpected token 'for'"); // ../../src/include/lib/ilist.h:1132:9
pub const slist_foreach_modify = @compileError("unable to translate C expr: unexpected token 'for'"); // ../../src/include/lib/ilist.h:1148:9
pub const si_pid = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:128:9
pub const si_uid = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:129:9
pub const si_timerid = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:130:9
pub const si_overrun = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:131:9
pub const si_status = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:132:9
pub const si_utime = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:133:9
pub const si_stime = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:134:9
pub const si_value = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:135:9
pub const si_int = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:136:9
pub const si_ptr = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:137:9
pub const si_addr = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:138:9
pub const si_addr_lsb = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:139:9
pub const si_lower = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:140:9
pub const si_upper = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:141:9
pub const si_pkey = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:142:9
pub const si_band = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:143:9
pub const si_fd = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:144:9
pub const si_call_addr = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:146:10
pub const si_syscall = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:147:10
pub const si_arch = @compileError("unable to translate macro: undefined identifier `_sifields`"); // /usr/include/bits/types/siginfo_t.h:148:10
pub const sigev_notify_function = @compileError("unable to translate macro: undefined identifier `_sigev_un`"); // /usr/include/bits/types/sigevent_t.h:45:9
pub const sigev_notify_attributes = @compileError("unable to translate macro: undefined identifier `_sigev_un`"); // /usr/include/bits/types/sigevent_t.h:46:9
pub const sa_handler = @compileError("unable to translate macro: undefined identifier `__sigaction_handler`"); // /usr/include/bits/sigaction.h:39:10
pub const sa_sigaction = @compileError("unable to translate macro: undefined identifier `__sigaction_handler`"); // /usr/include/bits/sigaction.h:40:10
pub const pairingheap_container = @compileError("unable to translate C expr: unexpected token ')'"); // ../../src/include/lib/pairingheap.h:43:9
pub const pairingheap_const_container = @compileError("unable to translate C expr: unexpected token 'const'"); // ../../src/include/lib/pairingheap.h:51:9
pub const pairingheap_reset = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/lib/pairingheap.h:93:9
pub const SizeForFunctionCallInfo = @compileError("unable to translate macro: undefined identifier `args`"); // ../../src/include/fmgr.h:102:9
pub const LOCAL_FCINFO = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:110:9
pub const fmgr_info_set_expr = @compileError("unable to translate C expr: expected ')' instead got '='"); // ../../src/include/fmgr.h:135:9
pub const InitFunctionCallInfoData = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/fmgr.h:150:9
pub const PG_FUNCTION_ARGS = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:193:9
pub const PG_GET_COLLATION = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:198:9
pub const PG_NARGS = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:203:9
pub const PG_ARGISNULL = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:209:9
pub const PG_FREE_IF_COPY = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/fmgr.h:260:9
pub const PG_GETARG_DATUM = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:268:9
pub const PG_HAS_OPCLASS_OPTIONS = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:341:9
pub const PG_GET_OPCLASS_OPTIONS = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:342:9
pub const PG_RETURN_NULL = @compileError("unable to translate macro: undefined identifier `fcinfo`"); // ../../src/include/fmgr.h:345:9
pub const PG_RETURN_VOID = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:349:9
pub const PG_RETURN_DATUM = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:353:9
pub const PG_RETURN_INT32 = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:354:9
pub const PG_RETURN_UINT32 = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:355:9
pub const PG_RETURN_INT16 = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:356:9
pub const PG_RETURN_UINT16 = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:357:9
pub const PG_RETURN_CHAR = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:358:9
pub const PG_RETURN_BOOL = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:359:9
pub const PG_RETURN_OID = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:360:9
pub const PG_RETURN_POINTER = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:361:9
pub const PG_RETURN_CSTRING = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:362:9
pub const PG_RETURN_NAME = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:363:9
pub const PG_RETURN_TRANSACTIONID = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:364:9
pub const PG_RETURN_FLOAT4 = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:366:9
pub const PG_RETURN_FLOAT8 = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:367:9
pub const PG_RETURN_INT64 = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:368:9
pub const PG_RETURN_UINT64 = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/fmgr.h:369:9
pub const PG_RETURN_HEAPTUPLEHEADER = @compileError("unable to translate macro: undefined identifier `HeapTupleHeaderGetDatum`"); // ../../src/include/fmgr.h:375:9
pub const PG_FUNCTION_INFO_V1 = @compileError("unable to translate macro: undefined identifier `pg_finfo_`"); // ../../src/include/fmgr.h:415:9
pub const PG_MODULE_MAGIC_DATA = @compileError("unable to translate C expr: unexpected token '{'"); // ../../src/include/fmgr.h:476:9
pub const PG_MODULE_MAGIC = @compileError("unable to translate macro: undefined identifier `Pg_magic_data`"); // ../../src/include/fmgr.h:499:9
pub const PG_RETURN_TIMESTAMP = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/utils/timestamp.h:67:9
pub const PG_RETURN_TIMESTAMPTZ = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/utils/timestamp.h:68:9
pub const PG_RETURN_INTERVAL_P = @compileError("unable to translate C expr: unexpected token 'return'"); // ../../src/include/utils/timestamp.h:69:9
pub const S_UNLOCK = @compileError("unable to translate macro: undefined identifier `__asm__`"); // ../../src/include/storage/s_lock.h:654:9
pub const S_LOCK = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // ../../src/include/storage/s_lock.h:775:9
pub const init_local_spin_delay = @compileError("unable to translate macro: undefined identifier `__FILE__`"); // ../../src/include/storage/s_lock.h:863:9
pub const pg_memory_barrier_impl = @compileError("unable to translate macro: undefined identifier `__asm__`"); // ../../src/include/port/atomics/arch-x86.h:39:9
pub const pg_compiler_barrier_impl = @compileError("unable to translate macro: undefined identifier `__asm__`"); // ../../src/include/port/atomics/generic-gcc.h:30:9
pub const __SOCKADDR_COMMON = @compileError("unable to translate macro: undefined identifier `family`"); // /usr/include/bits/sockaddr.h:34:9
pub const __struct_group = @compileError("unable to translate C expr: expected ')' instead got '...'"); // /usr/include/linux/stddef.h:26:9
pub const __DECLARE_FLEX_ARRAY = @compileError("unable to translate macro: undefined identifier `__empty_`"); // /usr/include/linux/stddef.h:42:9
pub const __SOCKADDR_ARG = @compileError("unable to translate macro: undefined identifier `__restrict`"); // /usr/include/sys/socket.h:58:10
pub const __CONST_SOCKADDR_ARG = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/sys/socket.h:59:10
pub const SCM_SRCRT = @compileError("unable to translate macro: undefined identifier `IPV6_RXSRCRT`"); // /usr/include/bits/in.h:170:9
pub const s6_addr = @compileError("unable to translate macro: undefined identifier `__in6_u`"); // /usr/include/netinet/in.h:229:9
pub const s6_addr16 = @compileError("unable to translate macro: undefined identifier `__in6_u`"); // /usr/include/netinet/in.h:231:10
pub const s6_addr32 = @compileError("unable to translate macro: undefined identifier `__in6_u`"); // /usr/include/netinet/in.h:232:10
pub const IN6ADDR_ANY_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/netinet/in.h:239:9
pub const IN6ADDR_LOOPBACK_INIT = @compileError("unable to translate C expr: unexpected token '{'"); // /usr/include/netinet/in.h:240:9
pub const IN6_IS_ADDR_UNSPECIFIED = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/netinet/in.h:433:10
pub const IN6_IS_ADDR_LOOPBACK = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/netinet/in.h:441:10
pub const IN6_IS_ADDR_LINKLOCAL = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/netinet/in.h:449:10
pub const IN6_IS_ADDR_SITELOCAL = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/netinet/in.h:454:10
pub const IN6_IS_ADDR_V4MAPPED = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/netinet/in.h:459:10
pub const IN6_IS_ADDR_V4COMPAT = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/netinet/in.h:466:10
pub const IN6_ARE_ADDR_EQUAL = @compileError("unable to translate macro: undefined identifier `__extension__`"); // /usr/include/netinet/in.h:474:10
pub const IN6_IS_ADDR_MULTICAST = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/netinet/in.h:521:9
pub const IN6_IS_ADDR_MC_NODELOCAL = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/netinet/in.h:533:9
pub const IN6_IS_ADDR_MC_LINKLOCAL = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/netinet/in.h:537:9
pub const IN6_IS_ADDR_MC_SITELOCAL = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/netinet/in.h:541:9
pub const IN6_IS_ADDR_MC_ORGLOCAL = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/netinet/in.h:545:9
pub const IN6_IS_ADDR_MC_GLOBAL = @compileError("unable to translate C expr: unexpected token 'const'"); // /usr/include/netinet/in.h:549:9
pub const h_addr = @compileError("unable to translate macro: undefined identifier `h_addr_list`"); // /usr/include/netdb.h:106:10
pub const MinSizeOfXactAssignment = @compileError("unable to translate macro: undefined identifier `xsub`"); // ../../src/include/access/xact.h:225:9
pub const MinSizeOfXactSubxacts = @compileError("unable to translate macro: undefined identifier `subxacts`"); // ../../src/include/access/xact.h:266:9
pub const MinSizeOfXactRelfileLocators = @compileError("unable to translate macro: undefined identifier `xlocators`"); // ../../src/include/access/xact.h:273:9
pub const MinSizeOfXactStatsItems = @compileError("unable to translate macro: undefined identifier `items`"); // ../../src/include/access/xact.h:294:9
pub const MinSizeOfXactInvals = @compileError("unable to translate macro: undefined identifier `msgs`"); // ../../src/include/access/xact.h:301:9
pub const MinSizeOfXactCommit = @compileError("unable to translate macro: undefined identifier `xact_time`"); // ../../src/include/access/xact.h:328:9
pub const CLASS_TUPLE_SIZE = @compileError("unable to translate macro: undefined identifier `relminmxid`"); // ../../src/include/catalog/pg_class.h:145:9
pub const RelationSetTargetBlock = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/utils/rel.h:609:9
pub const WalSndWakeupRequest = @compileError("unable to translate C expr: unexpected token 'do'"); // ../../src/include/replication/walsender.h:57:9
pub const MemoryContextIsValid = @compileError("unable to translate macro: undefined identifier `AllocSetContext`"); // ../../src/include/nodes/memnodes.h:107:9
pub const AllocSetContextCreate = @compileError("unable to translate C expr: expected ')' instead got '...'"); // ../../src/include/utils/memutils.h:124:9
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 15);
pub const __clang_minor__ = @as(c_int, 0);
pub const __clang_patchlevel__ = @as(c_int, 7);
pub const __clang_version__ = "15.0.7 ";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 15.0.7";
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-32";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const _LP64 = @as(c_int, 1);
pub const __LP64__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 64);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @as(c_int, 128);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 32);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 32);
pub const __INTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 8);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 4);
pub const __SIZEOF_WINT_T__ = @as(c_int, 4);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_long;
pub const __INTMAX_FMTd__ = "ld";
pub const __INTMAX_FMTi__ = "li";
pub const __UINTMAX_TYPE__ = c_ulong;
pub const __UINTMAX_FMTo__ = "lo";
pub const __UINTMAX_FMTu__ = "lu";
pub const __UINTMAX_FMTx__ = "lx";
pub const __UINTMAX_FMTX__ = "lX";
pub const __PTRDIFF_TYPE__ = c_long;
pub const __PTRDIFF_FMTd__ = "ld";
pub const __PTRDIFF_FMTi__ = "li";
pub const __INTPTR_TYPE__ = c_long;
pub const __INTPTR_FMTd__ = "ld";
pub const __INTPTR_FMTi__ = "li";
pub const __SIZE_TYPE__ = c_ulong;
pub const __SIZE_FMTo__ = "lo";
pub const __SIZE_FMTu__ = "lu";
pub const __SIZE_FMTx__ = "lx";
pub const __SIZE_FMTX__ = "lX";
pub const __WCHAR_TYPE__ = c_int;
pub const __WINT_TYPE__ = c_uint;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulong;
pub const __UINTPTR_FMTo__ = "lo";
pub const __UINTPTR_FMTu__ = "lu";
pub const __UINTPTR_FMTx__ = "lx";
pub const __UINTPTR_FMTX__ = "lX";
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 3.64519953188247460253e-4951);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 18);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 21);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.08420217248550443401e-19);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 64);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_long;
pub const __INT64_FMTd__ = "ld";
pub const __INT64_FMTi__ = "li";
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulong;
pub const __UINT64_FMTo__ = "lo";
pub const __UINT64_FMTu__ = "lu";
pub const __UINT64_FMTx__ = "lx";
pub const __UINT64_FMTX__ = "lX";
pub const __UINT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __INT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_long;
pub const __INT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "ld";
pub const __INT_LEAST64_FMTi__ = "li";
pub const __UINT_LEAST64_TYPE__ = c_ulong;
pub const __UINT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_LEAST64_FMTo__ = "lo";
pub const __UINT_LEAST64_FMTu__ = "lu";
pub const __UINT_LEAST64_FMTx__ = "lx";
pub const __UINT_LEAST64_FMTX__ = "lX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_long;
pub const __INT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "ld";
pub const __INT_FAST64_FMTi__ = "li";
pub const __UINT_FAST64_TYPE__ = c_ulong;
pub const __UINT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_FAST64_FMTo__ = "lo";
pub const __UINT_FAST64_FMTu__ = "lu";
pub const __UINT_FAST64_FMTx__ = "lx";
pub const __UINT_FAST64_FMTX__ = "lX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __PIE__ = @as(c_int, 2);
pub const __pie__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __code_model_small__ = @as(c_int, 1);
pub const __amd64__ = @as(c_int, 1);
pub const __amd64 = @as(c_int, 1);
pub const __x86_64 = @as(c_int, 1);
pub const __x86_64__ = @as(c_int, 1);
pub const __SEG_GS = @as(c_int, 1);
pub const __SEG_FS = @as(c_int, 1);
pub const __corei7 = @as(c_int, 1);
pub const __corei7__ = @as(c_int, 1);
pub const __tune_corei7__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __NO_MATH_INLINES = @as(c_int, 1);
pub const __AES__ = @as(c_int, 1);
pub const __PCLMUL__ = @as(c_int, 1);
pub const __LAHF_SAHF__ = @as(c_int, 1);
pub const __LZCNT__ = @as(c_int, 1);
pub const __RDRND__ = @as(c_int, 1);
pub const __FSGSBASE__ = @as(c_int, 1);
pub const __BMI__ = @as(c_int, 1);
pub const __BMI2__ = @as(c_int, 1);
pub const __POPCNT__ = @as(c_int, 1);
pub const __PRFCHW__ = @as(c_int, 1);
pub const __RDSEED__ = @as(c_int, 1);
pub const __ADX__ = @as(c_int, 1);
pub const __MOVBE__ = @as(c_int, 1);
pub const __FMA__ = @as(c_int, 1);
pub const __F16C__ = @as(c_int, 1);
pub const __FXSR__ = @as(c_int, 1);
pub const __XSAVE__ = @as(c_int, 1);
pub const __XSAVEOPT__ = @as(c_int, 1);
pub const __XSAVEC__ = @as(c_int, 1);
pub const __XSAVES__ = @as(c_int, 1);
pub const __CLFLUSHOPT__ = @as(c_int, 1);
pub const __SGX__ = @as(c_int, 1);
pub const __INVPCID__ = @as(c_int, 1);
pub const __CRC32__ = @as(c_int, 1);
pub const __AVX2__ = @as(c_int, 1);
pub const __AVX__ = @as(c_int, 1);
pub const __SSE4_2__ = @as(c_int, 1);
pub const __SSE4_1__ = @as(c_int, 1);
pub const __SSSE3__ = @as(c_int, 1);
pub const __SSE3__ = @as(c_int, 1);
pub const __SSE2__ = @as(c_int, 1);
pub const __SSE2_MATH__ = @as(c_int, 1);
pub const __SSE__ = @as(c_int, 1);
pub const __SSE_MATH__ = @as(c_int, 1);
pub const __MMX__ = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __SIZEOF_FLOAT128__ = @as(c_int, 16);
pub const unix = @as(c_int, 1);
pub const __unix = @as(c_int, 1);
pub const __unix__ = @as(c_int, 1);
pub const linux = @as(c_int, 1);
pub const __linux = @as(c_int, 1);
pub const __linux__ = @as(c_int, 1);
pub const __ELF__ = @as(c_int, 1);
pub const __gnu_linux__ = @as(c_int, 1);
pub const __FLOAT128__ = @as(c_int, 1);
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const _DEBUG = @as(c_int, 1);
pub const __GCC_HAVE_DWARF2_CFI_ASM = @as(c_int, 1);
pub const POSTGRES_H = "";
pub const C_H = "";
pub const POSTGRES_EXT_H = "";
pub const PG_INT64_TYPE = c_long;
pub const InvalidOid = @import("std").zig.c_translation.cast(Oid, @as(c_int, 0));
pub const OID_MAX = UINT_MAX;
pub inline fn atooid(x: anytype) Oid {
    return @import("std").zig.c_translation.cast(Oid, strtoul(x, NULL, @as(c_int, 10)));
}
pub const PG_DIAG_SEVERITY = 'S';
pub const PG_DIAG_SEVERITY_NONLOCALIZED = 'V';
pub const PG_DIAG_SQLSTATE = 'C';
pub const PG_DIAG_MESSAGE_PRIMARY = 'M';
pub const PG_DIAG_MESSAGE_DETAIL = 'D';
pub const PG_DIAG_MESSAGE_HINT = 'H';
pub const PG_DIAG_STATEMENT_POSITION = 'P';
pub const PG_DIAG_INTERNAL_POSITION = 'p';
pub const PG_DIAG_INTERNAL_QUERY = 'q';
pub const PG_DIAG_CONTEXT = 'W';
pub const PG_DIAG_SCHEMA_NAME = 's';
pub const PG_DIAG_TABLE_NAME = 't';
pub const PG_DIAG_COLUMN_NAME = 'c';
pub const PG_DIAG_DATATYPE_NAME = 'd';
pub const PG_DIAG_CONSTRAINT_NAME = 'n';
pub const PG_DIAG_SOURCE_FILE = 'F';
pub const PG_DIAG_SOURCE_LINE = 'L';
pub const PG_DIAG_SOURCE_FUNCTION = 'R';
pub const ALIGNOF_DOUBLE = @as(c_int, 8);
pub const ALIGNOF_INT = @as(c_int, 4);
pub const ALIGNOF_LONG = @as(c_int, 8);
pub const ALIGNOF_PG_INT128_TYPE = @as(c_int, 16);
pub const ALIGNOF_SHORT = @as(c_int, 2);
pub const BLCKSZ = @as(c_int, 8192);
pub const CONFIGURE_ARGS = "";
pub const DEF_PGPORT = @as(c_int, 5432);
pub const DEF_PGPORT_STR = "5432";
pub const DLSUFFIX = ".so";
pub const ENABLE_THREAD_SAFETY = @as(c_int, 1);
pub const HAVE_APPEND_HISTORY = @as(c_int, 1);
pub const HAVE_ATOMICS = @as(c_int, 1);
pub const HAVE_BACKTRACE_SYMBOLS = @as(c_int, 1);
pub const HAVE_COMPUTED_GOTO = @as(c_int, 1);
pub const HAVE_DECL_FDATASYNC = @as(c_int, 1);
pub const HAVE_DECL_F_FULLFSYNC = @as(c_int, 0);
pub const HAVE_DECL_POSIX_FADVISE = @as(c_int, 1);
pub const HAVE_DECL_PREADV = @as(c_int, 1);
pub const HAVE_DECL_PWRITEV = @as(c_int, 1);
pub const HAVE_DECL_STRLCAT = @as(c_int, 0);
pub const HAVE_DECL_STRLCPY = @as(c_int, 0);
pub const HAVE_DECL_STRNLEN = @as(c_int, 1);
pub const HAVE_EXECINFO_H = @as(c_int, 1);
pub const HAVE_EXPLICIT_BZERO = @as(c_int, 1);
pub const HAVE_FSEEKO = @as(c_int, 1);
pub const HAVE_GCC__ATOMIC_INT32_CAS = @as(c_int, 1);
pub const HAVE_GCC__ATOMIC_INT64_CAS = @as(c_int, 1);
pub const HAVE_GCC__SYNC_CHAR_TAS = @as(c_int, 1);
pub const HAVE_GCC__SYNC_INT32_CAS = @as(c_int, 1);
pub const HAVE_GCC__SYNC_INT32_TAS = @as(c_int, 1);
pub const HAVE_GCC__SYNC_INT64_CAS = @as(c_int, 1);
pub const HAVE_GETIFADDRS = @as(c_int, 1);
pub const HAVE_GETOPT = @as(c_int, 1);
pub const HAVE_GETOPT_H = @as(c_int, 1);
pub const HAVE_GETOPT_LONG = @as(c_int, 1);
pub const HAVE_HISTORY_TRUNCATE_FILE = @as(c_int, 1);
pub const HAVE_IFADDRS_H = @as(c_int, 1);
pub const HAVE_INET_ATON = @as(c_int, 1);
pub const HAVE_INET_PTON = @as(c_int, 1);
pub const HAVE_INTTYPES_H = @as(c_int, 1);
pub const HAVE_INT_OPTERR = @as(c_int, 1);
pub const HAVE_INT_TIMEZONE = @as(c_int, 1);
pub const HAVE_LANGINFO_H = @as(c_int, 1);
pub const HAVE_LIBM = @as(c_int, 1);
pub const HAVE_LIBREADLINE = @as(c_int, 1);
pub const HAVE_LIBZ = @as(c_int, 1);
pub const HAVE_LOCALE_T = @as(c_int, 1);
pub const HAVE_LONG_INT_64 = @as(c_int, 1);
pub const HAVE_MEMORY_H = @as(c_int, 1);
pub const HAVE_MKDTEMP = @as(c_int, 1);
pub const HAVE_POSIX_FADVISE = @as(c_int, 1);
pub const HAVE_POSIX_FALLOCATE = @as(c_int, 1);
pub const HAVE_PPOLL = @as(c_int, 1);
pub const HAVE_PTHREAD = @as(c_int, 1);
pub const HAVE_PTHREAD_BARRIER_WAIT = @as(c_int, 1);
pub const HAVE_PTHREAD_PRIO_INHERIT = @as(c_int, 1);
pub const HAVE_READLINE_HISTORY_H = @as(c_int, 1);
pub const HAVE_READLINE_READLINE_H = @as(c_int, 1);
pub const HAVE_RL_COMPLETION_MATCHES = @as(c_int, 1);
pub const HAVE_RL_COMPLETION_SUPPRESS_QUOTE = @as(c_int, 1);
pub const HAVE_RL_FILENAME_COMPLETION_FUNCTION = @as(c_int, 1);
pub const HAVE_RL_FILENAME_QUOTE_CHARACTERS = @as(c_int, 1);
pub const HAVE_RL_FILENAME_QUOTING_FUNCTION = @as(c_int, 1);
pub const HAVE_RL_RESET_SCREEN_SIZE = @as(c_int, 1);
pub const HAVE_RL_VARIABLE_BIND = @as(c_int, 1);
pub const HAVE_SOCKLEN_T = @as(c_int, 1);
pub const HAVE_SPINLOCKS = @as(c_int, 1);
pub const HAVE_STDBOOL_H = @as(c_int, 1);
pub const HAVE_STDINT_H = @as(c_int, 1);
pub const HAVE_STDLIB_H = @as(c_int, 1);
pub const HAVE_STRCHRNUL = @as(c_int, 1);
pub const HAVE_STRERROR_R = @as(c_int, 1);
pub const HAVE_STRINGS_H = @as(c_int, 1);
pub const HAVE_STRING_H = @as(c_int, 1);
pub const HAVE_STRNLEN = @as(c_int, 1);
pub const HAVE_STRSIGNAL = @as(c_int, 1);
pub const HAVE_STRUCT_OPTION = @as(c_int, 1);
pub const HAVE_STRUCT_TM_TM_ZONE = @as(c_int, 1);
pub const HAVE_SYNCFS = @as(c_int, 1);
pub const HAVE_SYNC_FILE_RANGE = @as(c_int, 1);
pub const HAVE_SYSLOG = @as(c_int, 1);
pub const HAVE_SYS_EPOLL_H = @as(c_int, 1);
pub const HAVE_SYS_PERSONALITY_H = @as(c_int, 1);
pub const HAVE_SYS_PRCTL_H = @as(c_int, 1);
pub const HAVE_SYS_SIGNALFD_H = @as(c_int, 1);
pub const HAVE_SYS_STAT_H = @as(c_int, 1);
pub const HAVE_SYS_TYPES_H = @as(c_int, 1);
pub const HAVE_TERMIOS_H = @as(c_int, 1);
pub const HAVE_TYPEOF = @as(c_int, 1);
pub const HAVE_UNISTD_H = @as(c_int, 1);
pub const HAVE_USELOCALE = @as(c_int, 1);
pub const HAVE_VISIBILITY_ATTRIBUTE = @as(c_int, 1);
pub const HAVE_X86_64_POPCNTQ = @as(c_int, 1);
pub const HAVE__BOOL = @as(c_int, 1);
pub const HAVE__BUILTIN_BSWAP16 = @as(c_int, 1);
pub const HAVE__BUILTIN_BSWAP32 = @as(c_int, 1);
pub const HAVE__BUILTIN_BSWAP64 = @as(c_int, 1);
pub const HAVE__BUILTIN_CLZ = @as(c_int, 1);
pub const HAVE__BUILTIN_CONSTANT_P = @as(c_int, 1);
pub const HAVE__BUILTIN_CTZ = @as(c_int, 1);
pub const HAVE__BUILTIN_FRAME_ADDRESS = @as(c_int, 1);
pub const HAVE__BUILTIN_OP_OVERFLOW = @as(c_int, 1);
pub const HAVE__BUILTIN_POPCOUNT = @as(c_int, 1);
pub const HAVE__BUILTIN_TYPES_COMPATIBLE_P = @as(c_int, 1);
pub const HAVE__BUILTIN_UNREACHABLE = @as(c_int, 1);
pub const HAVE__GET_CPUID = @as(c_int, 1);
pub const HAVE__STATIC_ASSERT = @as(c_int, 1);
pub const INT64_MODIFIER = "l";
pub const MAXIMUM_ALIGNOF = @as(c_int, 8);
pub const MEMSET_LOOP_LIMIT = @as(c_int, 1024);
pub const PACKAGE_BUGREPORT = "pgsql-bugs@lists.postgresql.org";
pub const PACKAGE_NAME = "PostgreSQL";
pub const PACKAGE_STRING = "PostgreSQL 16beta1";
pub const PACKAGE_TARNAME = "postgresql";
pub const PACKAGE_URL = "https://www.postgresql.org/";
pub const PACKAGE_VERSION = "16beta1";
pub const PG_KRB_SRVNAM = "postgres";
pub const PG_MAJORVERSION = "16";
pub const PG_MAJORVERSION_NUM = @as(c_int, 16);
pub const PG_MINORVERSION_NUM = @as(c_int, 0);
pub const PG_USE_STDBOOL = @as(c_int, 1);
pub const PG_VERSION = "16beta1";
pub const PG_VERSION_NUM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 160000, .decimal);
pub const PG_VERSION_STR = "PostgreSQL 16beta1 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 13.1.1 20230429, 64-bit";
pub const RELSEG_SIZE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 131072, .decimal);
pub const SIZEOF_BOOL = @as(c_int, 1);
pub const SIZEOF_LONG = @as(c_int, 8);
pub const SIZEOF_OFF_T = @as(c_int, 8);
pub const SIZEOF_SIZE_T = @as(c_int, 8);
pub const SIZEOF_VOID_P = @as(c_int, 8);
pub const STDC_HEADERS = @as(c_int, 1);
pub const USE_ICU = @as(c_int, 1);
pub const USE_SSE42_CRC32C_WITH_RUNTIME_CHECK = @as(c_int, 1);
pub const USE_SYSV_SHARED_MEMORY = @as(c_int, 1);
pub const USE_UNNAMED_POSIX_SEMAPHORES = @as(c_int, 1);
pub const XLOG_BLCKSZ = @as(c_int, 8192);
pub const DEFAULT_XLOG_SEG_SIZE = (@as(c_int, 16) * @as(c_int, 1024)) * @as(c_int, 1024);
pub const NAMEDATALEN = @as(c_int, 64);
pub const FUNC_MAX_ARGS = @as(c_int, 100);
pub const FMGR_ABI_EXTRA = "PostgreSQL";
pub const INDEX_MAX_KEYS = @as(c_int, 32);
pub const PARTITION_MAX_KEYS = @as(c_int, 32);
pub const USE_FLOAT8_BYVAL = @as(c_int, 1);
pub const NUM_SPINLOCK_SEMAPHORES = @as(c_int, 128);
pub const NUM_ATOMICS_SEMAPHORES = @as(c_int, 64);
pub const MAXPGPATH = @as(c_int, 1024);
pub const BITS_PER_BYTE = @as(c_int, 8);
pub const ALIGNOF_BUFFER = @as(c_int, 32);
pub const USE_POSIX_FADVISE = "";
pub const USE_PREFETCH = "";
pub const DEFAULT_BACKEND_FLUSH_AFTER = @as(c_int, 0);
pub const DEFAULT_BGWRITER_FLUSH_AFTER = @as(c_int, 64);
pub const DEFAULT_CHECKPOINT_FLUSH_AFTER = @as(c_int, 32);
pub const WRITEBACK_MAX_PENDING_FLUSHES = @as(c_int, 256);
pub const DEFAULT_PGSOCKET_DIR = "/tmp";
pub const DEFAULT_EVENT_SOURCE = "PostgreSQL";
pub const PG_CACHE_LINE_SIZE = @as(c_int, 128);
pub const PG_IO_ALIGN_SIZE = @as(c_int, 4096);
pub const TRACE_SORT = @as(c_int, 1);
pub const HAVE_LINUX_EIDRM_BUG = "";
pub const PLATFORM_DEFAULT_SYNC_METHOD = SYNC_METHOD_FDATASYNC;
pub const _STDIO_H = @as(c_int, 1);
pub const __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION = "";
pub const _FEATURES_H = @as(c_int, 1);
pub const __KERNEL_STRICT_NAMES = "";
pub inline fn __GNUC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub inline fn __glibc_clang_prereq(maj: anytype, min: anytype) @TypeOf(((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _DEFAULT_SOURCE = @as(c_int, 1);
pub const __GLIBC_USE_ISOC2X = @as(c_int, 0);
pub const __USE_ISOC11 = @as(c_int, 1);
pub const __USE_ISOC99 = @as(c_int, 1);
pub const __USE_ISOC95 = @as(c_int, 1);
pub const __USE_POSIX_IMPLICITLY = @as(c_int, 1);
pub const _POSIX_SOURCE = @as(c_int, 1);
pub const _POSIX_C_SOURCE = @as(c_long, 200809);
pub const __USE_POSIX = @as(c_int, 1);
pub const __USE_POSIX2 = @as(c_int, 1);
pub const __USE_POSIX199309 = @as(c_int, 1);
pub const __USE_POSIX199506 = @as(c_int, 1);
pub const __USE_XOPEN2K = @as(c_int, 1);
pub const __USE_XOPEN2K8 = @as(c_int, 1);
pub const _ATFILE_SOURCE = @as(c_int, 1);
pub const __WORDSIZE = @as(c_int, 64);
pub const __WORDSIZE_TIME64_COMPAT32 = @as(c_int, 1);
pub const __SYSCALL_WORDSIZE = @as(c_int, 64);
pub const __TIMESIZE = __WORDSIZE;
pub const __USE_MISC = @as(c_int, 1);
pub const __USE_ATFILE = @as(c_int, 1);
pub const __USE_FORTIFY_LEVEL = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_GETS = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_SCANF = @as(c_int, 0);
pub const _STDC_PREDEF_H = @as(c_int, 1);
pub const __STDC_IEC_559__ = @as(c_int, 1);
pub const __STDC_IEC_60559_BFP__ = @as(c_long, 201404);
pub const __STDC_IEC_559_COMPLEX__ = @as(c_int, 1);
pub const __STDC_IEC_60559_COMPLEX__ = @as(c_long, 201404);
pub const __STDC_ISO_10646__ = @as(c_long, 201706);
pub const __GNU_LIBRARY__ = @as(c_int, 6);
pub const __GLIBC__ = @as(c_int, 2);
pub const __GLIBC_MINOR__ = @as(c_int, 37);
pub inline fn __GLIBC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    return ((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _SYS_CDEFS_H = @as(c_int, 1);
pub inline fn __glibc_has_builtin(name: anytype) @TypeOf(__has_builtin(name)) {
    return __has_builtin(name);
}
pub const __LEAF = "";
pub const __LEAF_ATTR = "";
pub inline fn __P(args: anytype) @TypeOf(args) {
    return args;
}
pub inline fn __PMT(args: anytype) @TypeOf(args) {
    return args;
}
pub const __ptr_t = ?*anyopaque;
pub const __BEGIN_DECLS = "";
pub const __END_DECLS = "";
pub inline fn __bos(ptr: anytype) @TypeOf(__builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1))) {
    return __builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1));
}
pub inline fn __bos0(ptr: anytype) @TypeOf(__builtin_object_size(ptr, @as(c_int, 0))) {
    return __builtin_object_size(ptr, @as(c_int, 0));
}
pub inline fn __glibc_objsize0(__o: anytype) @TypeOf(__bos0(__o)) {
    return __bos0(__o);
}
pub inline fn __glibc_objsize(__o: anytype) @TypeOf(__bos(__o)) {
    return __bos(__o);
}
pub const __glibc_c99_flexarr_available = @as(c_int, 1);
pub inline fn __ASMNAME(cname: anytype) @TypeOf(__ASMNAME2(__USER_LABEL_PREFIX__, cname)) {
    return __ASMNAME2(__USER_LABEL_PREFIX__, cname);
}
pub inline fn __nonnull(params: anytype) @TypeOf(__attribute_nonnull__(params)) {
    return __attribute_nonnull__(params);
}
pub const __wur = "";
pub const __fortify_function = __extern_always_inline ++ __attribute_artificial__;
pub inline fn __glibc_unlikely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 0))) {
    return __builtin_expect(cond, @as(c_int, 0));
}
pub inline fn __glibc_likely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 1))) {
    return __builtin_expect(cond, @as(c_int, 1));
}
pub const __attribute_nonstring__ = "";
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = @as(c_int, 0);
pub inline fn __LDBL_REDIR1(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto) {
    _ = @TypeOf(alias);
    return name ++ proto;
}
pub inline fn __LDBL_REDIR(name: anytype, proto: anytype) @TypeOf(name ++ proto) {
    return name ++ proto;
}
pub inline fn __LDBL_REDIR1_NTH(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = @TypeOf(alias);
    return name ++ proto ++ __THROW;
}
pub inline fn __LDBL_REDIR_NTH(name: anytype, proto: anytype) @TypeOf(name ++ proto ++ __THROW) {
    return name ++ proto ++ __THROW;
}
pub inline fn __REDIRECT_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT(name, proto, alias)) {
    return __REDIRECT(name, proto, alias);
}
pub inline fn __REDIRECT_NTH_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT_NTH(name, proto, alias)) {
    return __REDIRECT_NTH(name, proto, alias);
}
pub const __HAVE_GENERIC_SELECTION = @as(c_int, 1);
pub const __attr_dealloc_free = "";
pub const __stub___compat_bdflush = "";
pub const __stub_chflags = "";
pub const __stub_fchflags = "";
pub const __stub_gtty = "";
pub const __stub_revoke = "";
pub const __stub_setlogin = "";
pub const __stub_sigreturn = "";
pub const __stub_stty = "";
pub const __GLIBC_USE_LIB_EXT2 = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_BFP_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = @as(c_int, 0);
pub const __GLIBC_USE_IEC_60559_TYPES_EXT = @as(c_int, 0);
pub const __need_size_t = "";
pub const __need_NULL = "";
pub const _SIZE_T = "";
pub const NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const __need___va_list = "";
pub const __STDARG_H = "";
pub const _VA_LIST = "";
pub const __GNUC_VA_LIST = @as(c_int, 1);
pub const _BITS_TYPES_H = @as(c_int, 1);
pub const __S16_TYPE = c_short;
pub const __U16_TYPE = c_ushort;
pub const __S32_TYPE = c_int;
pub const __U32_TYPE = c_uint;
pub const __SLONGWORD_TYPE = c_long;
pub const __ULONGWORD_TYPE = c_ulong;
pub const __SQUAD_TYPE = c_long;
pub const __UQUAD_TYPE = c_ulong;
pub const __SWORD_TYPE = c_long;
pub const __UWORD_TYPE = c_ulong;
pub const __SLONG32_TYPE = c_int;
pub const __ULONG32_TYPE = c_uint;
pub const __S64_TYPE = c_long;
pub const __U64_TYPE = c_ulong;
pub const _BITS_TYPESIZES_H = @as(c_int, 1);
pub const __SYSCALL_SLONG_TYPE = __SLONGWORD_TYPE;
pub const __SYSCALL_ULONG_TYPE = __ULONGWORD_TYPE;
pub const __DEV_T_TYPE = __UQUAD_TYPE;
pub const __UID_T_TYPE = __U32_TYPE;
pub const __GID_T_TYPE = __U32_TYPE;
pub const __INO_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __INO64_T_TYPE = __UQUAD_TYPE;
pub const __MODE_T_TYPE = __U32_TYPE;
pub const __NLINK_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSWORD_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __OFF_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __OFF64_T_TYPE = __SQUAD_TYPE;
pub const __PID_T_TYPE = __S32_TYPE;
pub const __RLIM_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __RLIM64_T_TYPE = __UQUAD_TYPE;
pub const __BLKCNT_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __BLKCNT64_T_TYPE = __SQUAD_TYPE;
pub const __FSBLKCNT_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSBLKCNT64_T_TYPE = __UQUAD_TYPE;
pub const __FSFILCNT_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSFILCNT64_T_TYPE = __UQUAD_TYPE;
pub const __ID_T_TYPE = __U32_TYPE;
pub const __CLOCK_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __TIME_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __USECONDS_T_TYPE = __U32_TYPE;
pub const __SUSECONDS_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __SUSECONDS64_T_TYPE = __SQUAD_TYPE;
pub const __DADDR_T_TYPE = __S32_TYPE;
pub const __KEY_T_TYPE = __S32_TYPE;
pub const __CLOCKID_T_TYPE = __S32_TYPE;
pub const __TIMER_T_TYPE = ?*anyopaque;
pub const __BLKSIZE_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __SSIZE_T_TYPE = __SWORD_TYPE;
pub const __CPU_MASK_TYPE = __SYSCALL_ULONG_TYPE;
pub const __OFF_T_MATCHES_OFF64_T = @as(c_int, 1);
pub const __INO_T_MATCHES_INO64_T = @as(c_int, 1);
pub const __RLIM_T_MATCHES_RLIM64_T = @as(c_int, 1);
pub const __STATFS_MATCHES_STATFS64 = @as(c_int, 1);
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = @as(c_int, 1);
pub const __FD_SETSIZE = @as(c_int, 1024);
pub const _BITS_TIME64_H = @as(c_int, 1);
pub const __TIME64_T_TYPE = __TIME_T_TYPE;
pub const _____fpos_t_defined = @as(c_int, 1);
pub const ____mbstate_t_defined = @as(c_int, 1);
pub const _____fpos64_t_defined = @as(c_int, 1);
pub const ____FILE_defined = @as(c_int, 1);
pub const __FILE_defined = @as(c_int, 1);
pub const __struct_FILE_defined = @as(c_int, 1);
pub const _IO_EOF_SEEN = @as(c_int, 0x0010);
pub inline fn __feof_unlocked_body(_fp: anytype) @TypeOf((_fp.*._flags & _IO_EOF_SEEN) != @as(c_int, 0)) {
    return (_fp.*._flags & _IO_EOF_SEEN) != @as(c_int, 0);
}
pub const _IO_ERR_SEEN = @as(c_int, 0x0020);
pub inline fn __ferror_unlocked_body(_fp: anytype) @TypeOf((_fp.*._flags & _IO_ERR_SEEN) != @as(c_int, 0)) {
    return (_fp.*._flags & _IO_ERR_SEEN) != @as(c_int, 0);
}
pub const _IO_USER_LOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hexadecimal);
pub const _VA_LIST_DEFINED = "";
pub const __off_t_defined = "";
pub const __ssize_t_defined = "";
pub const _IOFBF = @as(c_int, 0);
pub const _IOLBF = @as(c_int, 1);
pub const _IONBF = @as(c_int, 2);
pub const BUFSIZ = @as(c_int, 8192);
pub const EOF = -@as(c_int, 1);
pub const SEEK_SET = @as(c_int, 0);
pub const SEEK_CUR = @as(c_int, 1);
pub const SEEK_END = @as(c_int, 2);
pub const P_tmpdir = "/tmp";
pub const _BITS_STDIO_LIM_H = @as(c_int, 1);
pub const L_tmpnam = @as(c_int, 20);
pub const TMP_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 238328, .decimal);
pub const FILENAME_MAX = @as(c_int, 4096);
pub const L_ctermid = @as(c_int, 9);
pub const FOPEN_MAX = @as(c_int, 16);
pub const __attr_dealloc_fclose = __attr_dealloc(fclose, @as(c_int, 1));
pub const _BITS_FLOATN_H = "";
pub const __HAVE_FLOAT128 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128 = @as(c_int, 0);
pub const __HAVE_FLOAT64X = @as(c_int, 1);
pub const __HAVE_FLOAT64X_LONG_DOUBLE = @as(c_int, 1);
pub const _BITS_FLOATN_COMMON_H = "";
pub const __HAVE_FLOAT16 = @as(c_int, 0);
pub const __HAVE_FLOAT32 = @as(c_int, 1);
pub const __HAVE_FLOAT64 = @as(c_int, 1);
pub const __HAVE_FLOAT32X = @as(c_int, 1);
pub const __HAVE_FLOAT128X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT16 = __HAVE_FLOAT16;
pub const __HAVE_DISTINCT_FLOAT32 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT32X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128X = __HAVE_FLOAT128X;
pub const __HAVE_FLOAT128_UNLIKE_LDBL = (__HAVE_DISTINCT_FLOAT128 != 0) and (__LDBL_MANT_DIG__ != @as(c_int, 113));
pub const __HAVE_FLOATN_NOT_TYPEDEF = @as(c_int, 0);
pub const __f32 = @import("std").zig.c_translation.Macros.F_SUFFIX;
pub inline fn __f64(x: anytype) @TypeOf(x) {
    return x;
}
pub inline fn __f32x(x: anytype) @TypeOf(x) {
    return x;
}
pub const __f64x = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub inline fn __builtin_huge_valf32() @TypeOf(__builtin_huge_valf()) {
    return __builtin_huge_valf();
}
pub inline fn __builtin_inff32() @TypeOf(__builtin_inff()) {
    return __builtin_inff();
}
pub inline fn __builtin_nanf32(x: anytype) @TypeOf(__builtin_nanf(x)) {
    return __builtin_nanf(x);
}
pub const __need_wchar_t = "";
pub const _WCHAR_T = "";
pub const _STDLIB_H = @as(c_int, 1);
pub const WNOHANG = @as(c_int, 1);
pub const WUNTRACED = @as(c_int, 2);
pub const WSTOPPED = @as(c_int, 2);
pub const WEXITED = @as(c_int, 4);
pub const WCONTINUED = @as(c_int, 8);
pub const WNOWAIT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hexadecimal);
pub const __WNOTHREAD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hexadecimal);
pub const __WALL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hexadecimal);
pub const __WCLONE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal);
pub inline fn __WEXITSTATUS(status: anytype) @TypeOf((status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hexadecimal)) >> @as(c_int, 8)) {
    return (status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hexadecimal)) >> @as(c_int, 8);
}
pub inline fn __WTERMSIG(status: anytype) @TypeOf(status & @as(c_int, 0x7f)) {
    return status & @as(c_int, 0x7f);
}
pub inline fn __WSTOPSIG(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    return __WEXITSTATUS(status);
}
pub inline fn __WIFEXITED(status: anytype) @TypeOf(__WTERMSIG(status) == @as(c_int, 0)) {
    return __WTERMSIG(status) == @as(c_int, 0);
}
pub inline fn __WIFSIGNALED(status: anytype) @TypeOf((@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0)) {
    return (@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0);
}
pub inline fn __WIFSTOPPED(status: anytype) @TypeOf((status & @as(c_int, 0xff)) == @as(c_int, 0x7f)) {
    return (status & @as(c_int, 0xff)) == @as(c_int, 0x7f);
}
pub inline fn __WIFCONTINUED(status: anytype) @TypeOf(status == __W_CONTINUED) {
    return status == __W_CONTINUED;
}
pub inline fn __WCOREDUMP(status: anytype) @TypeOf(status & __WCOREFLAG) {
    return status & __WCOREFLAG;
}
pub inline fn __W_EXITCODE(ret: anytype, sig: anytype) @TypeOf((ret << @as(c_int, 8)) | sig) {
    return (ret << @as(c_int, 8)) | sig;
}
pub inline fn __W_STOPCODE(sig: anytype) @TypeOf((sig << @as(c_int, 8)) | @as(c_int, 0x7f)) {
    return (sig << @as(c_int, 8)) | @as(c_int, 0x7f);
}
pub const __W_CONTINUED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hexadecimal);
pub const __WCOREFLAG = @as(c_int, 0x80);
pub inline fn WEXITSTATUS(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    return __WEXITSTATUS(status);
}
pub inline fn WTERMSIG(status: anytype) @TypeOf(__WTERMSIG(status)) {
    return __WTERMSIG(status);
}
pub inline fn WSTOPSIG(status: anytype) @TypeOf(__WSTOPSIG(status)) {
    return __WSTOPSIG(status);
}
pub inline fn WIFEXITED(status: anytype) @TypeOf(__WIFEXITED(status)) {
    return __WIFEXITED(status);
}
pub inline fn WIFSIGNALED(status: anytype) @TypeOf(__WIFSIGNALED(status)) {
    return __WIFSIGNALED(status);
}
pub inline fn WIFSTOPPED(status: anytype) @TypeOf(__WIFSTOPPED(status)) {
    return __WIFSTOPPED(status);
}
pub inline fn WIFCONTINUED(status: anytype) @TypeOf(__WIFCONTINUED(status)) {
    return __WIFCONTINUED(status);
}
pub const __ldiv_t_defined = @as(c_int, 1);
pub const __lldiv_t_defined = @as(c_int, 1);
pub const RAND_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const EXIT_FAILURE = @as(c_int, 1);
pub const EXIT_SUCCESS = @as(c_int, 0);
pub const MB_CUR_MAX = __ctype_get_mb_cur_max();
pub const _SYS_TYPES_H = @as(c_int, 1);
pub const __u_char_defined = "";
pub const __ino_t_defined = "";
pub const __dev_t_defined = "";
pub const __gid_t_defined = "";
pub const __mode_t_defined = "";
pub const __nlink_t_defined = "";
pub const __uid_t_defined = "";
pub const __pid_t_defined = "";
pub const __id_t_defined = "";
pub const __daddr_t_defined = "";
pub const __key_t_defined = "";
pub const __clock_t_defined = @as(c_int, 1);
pub const __clockid_t_defined = @as(c_int, 1);
pub const __time_t_defined = @as(c_int, 1);
pub const __timer_t_defined = @as(c_int, 1);
pub const _BITS_STDINT_INTN_H = @as(c_int, 1);
pub const __BIT_TYPES_DEFINED__ = @as(c_int, 1);
pub const _ENDIAN_H = @as(c_int, 1);
pub const _BITS_ENDIAN_H = @as(c_int, 1);
pub const __LITTLE_ENDIAN = @as(c_int, 1234);
pub const __BIG_ENDIAN = @as(c_int, 4321);
pub const __PDP_ENDIAN = @as(c_int, 3412);
pub const _BITS_ENDIANNESS_H = @as(c_int, 1);
pub const __BYTE_ORDER = __LITTLE_ENDIAN;
pub const __FLOAT_WORD_ORDER = __BYTE_ORDER;
pub inline fn __LONG_LONG_PAIR(HI: anytype, LO: anytype) @TypeOf(HI) {
    return blk: {
        _ = @TypeOf(LO);
        break :blk HI;
    };
}
pub const LITTLE_ENDIAN = __LITTLE_ENDIAN;
pub const BIG_ENDIAN = __BIG_ENDIAN;
pub const PDP_ENDIAN = __PDP_ENDIAN;
pub const BYTE_ORDER = __BYTE_ORDER;
pub const _BITS_BYTESWAP_H = @as(c_int, 1);
pub inline fn __bswap_constant_16(x: anytype) __uint16_t {
    return @import("std").zig.c_translation.cast(__uint16_t, ((x >> @as(c_int, 8)) & @as(c_int, 0xff)) | ((x & @as(c_int, 0xff)) << @as(c_int, 8)));
}
pub inline fn __bswap_constant_32(x: anytype) @TypeOf(((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hexadecimal)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hexadecimal)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24))) {
    return ((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hexadecimal)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hexadecimal)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24));
}
pub inline fn __bswap_constant_64(x: anytype) @TypeOf(((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56))) {
    return ((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56));
}
pub const _BITS_UINTN_IDENTITY_H = @as(c_int, 1);
pub inline fn htobe16(x: anytype) @TypeOf(__bswap_16(x)) {
    return __bswap_16(x);
}
pub inline fn htole16(x: anytype) @TypeOf(__uint16_identity(x)) {
    return __uint16_identity(x);
}
pub inline fn be16toh(x: anytype) @TypeOf(__bswap_16(x)) {
    return __bswap_16(x);
}
pub inline fn le16toh(x: anytype) @TypeOf(__uint16_identity(x)) {
    return __uint16_identity(x);
}
pub inline fn htobe32(x: anytype) @TypeOf(__bswap_32(x)) {
    return __bswap_32(x);
}
pub inline fn htole32(x: anytype) @TypeOf(__uint32_identity(x)) {
    return __uint32_identity(x);
}
pub inline fn be32toh(x: anytype) @TypeOf(__bswap_32(x)) {
    return __bswap_32(x);
}
pub inline fn le32toh(x: anytype) @TypeOf(__uint32_identity(x)) {
    return __uint32_identity(x);
}
pub inline fn htobe64(x: anytype) @TypeOf(__bswap_64(x)) {
    return __bswap_64(x);
}
pub inline fn htole64(x: anytype) @TypeOf(__uint64_identity(x)) {
    return __uint64_identity(x);
}
pub inline fn be64toh(x: anytype) @TypeOf(__bswap_64(x)) {
    return __bswap_64(x);
}
pub inline fn le64toh(x: anytype) @TypeOf(__uint64_identity(x)) {
    return __uint64_identity(x);
}
pub const _SYS_SELECT_H = @as(c_int, 1);
pub inline fn __FD_ISSET(d: anytype, s: anytype) @TypeOf((__FDS_BITS(s)[@intCast(usize, __FD_ELT(d))] & __FD_MASK(d)) != @as(c_int, 0)) {
    return (__FDS_BITS(s)[@intCast(usize, __FD_ELT(d))] & __FD_MASK(d)) != @as(c_int, 0);
}
pub const __sigset_t_defined = @as(c_int, 1);
pub const ____sigset_t_defined = "";
pub const _SIGSET_NWORDS = @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 1024), @as(c_int, 8) * @import("std").zig.c_translation.sizeof(c_ulong));
pub const __timeval_defined = @as(c_int, 1);
pub const _STRUCT_TIMESPEC = @as(c_int, 1);
pub const __suseconds_t_defined = "";
pub const __NFDBITS = @as(c_int, 8) * @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.sizeof(__fd_mask));
pub inline fn __FD_ELT(d: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(d, __NFDBITS)) {
    return @import("std").zig.c_translation.MacroArithmetic.div(d, __NFDBITS);
}
pub inline fn __FD_MASK(d: anytype) __fd_mask {
    return @import("std").zig.c_translation.cast(__fd_mask, @as(c_ulong, 1) << @import("std").zig.c_translation.MacroArithmetic.rem(d, __NFDBITS));
}
pub inline fn __FDS_BITS(set: anytype) @TypeOf(set.*.__fds_bits) {
    return set.*.__fds_bits;
}
pub const FD_SETSIZE = __FD_SETSIZE;
pub const NFDBITS = __NFDBITS;
pub inline fn FD_SET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_SET(fd, fdsetp)) {
    return __FD_SET(fd, fdsetp);
}
pub inline fn FD_CLR(fd: anytype, fdsetp: anytype) @TypeOf(__FD_CLR(fd, fdsetp)) {
    return __FD_CLR(fd, fdsetp);
}
pub inline fn FD_ISSET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_ISSET(fd, fdsetp)) {
    return __FD_ISSET(fd, fdsetp);
}
pub inline fn FD_ZERO(fdsetp: anytype) @TypeOf(__FD_ZERO(fdsetp)) {
    return __FD_ZERO(fdsetp);
}
pub const __blksize_t_defined = "";
pub const __blkcnt_t_defined = "";
pub const __fsblkcnt_t_defined = "";
pub const __fsfilcnt_t_defined = "";
pub const _BITS_PTHREADTYPES_COMMON_H = @as(c_int, 1);
pub const _THREAD_SHARED_TYPES_H = @as(c_int, 1);
pub const _BITS_PTHREADTYPES_ARCH_H = @as(c_int, 1);
pub const __SIZEOF_PTHREAD_MUTEX_T = @as(c_int, 40);
pub const __SIZEOF_PTHREAD_ATTR_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_RWLOCK_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_BARRIER_T = @as(c_int, 32);
pub const __SIZEOF_PTHREAD_MUTEXATTR_T = @as(c_int, 4);
pub const __SIZEOF_PTHREAD_COND_T = @as(c_int, 48);
pub const __SIZEOF_PTHREAD_CONDATTR_T = @as(c_int, 4);
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T = @as(c_int, 8);
pub const __SIZEOF_PTHREAD_BARRIERATTR_T = @as(c_int, 4);
pub const __LOCK_ALIGNMENT = "";
pub const __ONCE_ALIGNMENT = "";
pub const _BITS_ATOMIC_WIDE_COUNTER_H = "";
pub const _THREAD_MUTEX_INTERNAL_H = @as(c_int, 1);
pub const __PTHREAD_MUTEX_HAVE_PREV = @as(c_int, 1);
pub const _RWLOCK_INTERNAL_H = "";
pub inline fn __PTHREAD_RWLOCK_INITIALIZER(__flags: anytype) @TypeOf(__flags) {
    return blk: {
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @TypeOf(__PTHREAD_RWLOCK_ELISION_EXTRA);
        _ = @as(c_int, 0);
        break :blk __flags;
    };
}
pub const __have_pthread_attr_t = @as(c_int, 1);
pub const _ALLOCA_H = @as(c_int, 1);
pub const __COMPAR_FN_T = "";
pub const _STRING_H = @as(c_int, 1);
pub const _BITS_TYPES_LOCALE_T_H = @as(c_int, 1);
pub const _BITS_TYPES___LOCALE_T_H = @as(c_int, 1);
pub const _STRINGS_H = @as(c_int, 1);
pub const __STDDEF_H = "";
pub const __need_ptrdiff_t = "";
pub const __need_STDDEF_H_misc = "";
pub const _PTRDIFF_T = "";
pub const __CLANG_MAX_ALIGN_T_DEFINED = "";
pub const __CLANG_STDINT_H = "";
pub const _STDINT_H = @as(c_int, 1);
pub const _BITS_WCHAR_H = @as(c_int, 1);
pub const __WCHAR_MAX = __WCHAR_MAX__;
pub const __WCHAR_MIN = -__WCHAR_MAX - @as(c_int, 1);
pub const _BITS_STDINT_UINTN_H = @as(c_int, 1);
pub const __intptr_t_defined = "";
pub const __INT64_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __UINT64_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INT8_MIN = -@as(c_int, 128);
pub const INT16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const INT32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT8_MAX = @as(c_int, 127);
pub const INT16_MAX = @as(c_int, 32767);
pub const INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT8_MAX = @as(c_int, 255);
pub const UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INT_LEAST8_MIN = -@as(c_int, 128);
pub const INT_LEAST16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const INT_LEAST32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT_LEAST64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT_LEAST8_MAX = @as(c_int, 127);
pub const INT_LEAST16_MAX = @as(c_int, 32767);
pub const INT_LEAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT_LEAST64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT_LEAST8_MAX = @as(c_int, 255);
pub const UINT_LEAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT_LEAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT_LEAST64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INT_FAST8_MIN = -@as(c_int, 128);
pub const INT_FAST16_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INT_FAST32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INT_FAST64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT_FAST8_MAX = @as(c_int, 127);
pub const INT_FAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INT_FAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INT_FAST64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT_FAST8_MAX = @as(c_int, 255);
pub const UINT_FAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const UINT_FAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const UINT_FAST64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INTPTR_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const UINTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const INTMAX_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INTMAX_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINTMAX_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const PTRDIFF_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const PTRDIFF_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const SIG_ATOMIC_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const SIG_ATOMIC_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const WCHAR_MIN = __WCHAR_MIN;
pub const WCHAR_MAX = __WCHAR_MAX;
pub const WINT_MIN = @as(c_uint, 0);
pub const WINT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub inline fn INT8_C(c: anytype) @TypeOf(c) {
    return c;
}
pub inline fn INT16_C(c: anytype) @TypeOf(c) {
    return c;
}
pub inline fn INT32_C(c: anytype) @TypeOf(c) {
    return c;
}
pub const INT64_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub inline fn UINT8_C(c: anytype) @TypeOf(c) {
    return c;
}
pub inline fn UINT16_C(c: anytype) @TypeOf(c) {
    return c;
}
pub const UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const UINT64_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INTMAX_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const UINTMAX_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const _ERRNO_H = @as(c_int, 1);
pub const _BITS_ERRNO_H = @as(c_int, 1);
pub const _ASM_GENERIC_ERRNO_H = "";
pub const _ASM_GENERIC_ERRNO_BASE_H = "";
pub const EPERM = @as(c_int, 1);
pub const ENOENT = @as(c_int, 2);
pub const ESRCH = @as(c_int, 3);
pub const EINTR = @as(c_int, 4);
pub const EIO = @as(c_int, 5);
pub const ENXIO = @as(c_int, 6);
pub const E2BIG = @as(c_int, 7);
pub const ENOEXEC = @as(c_int, 8);
pub const EBADF = @as(c_int, 9);
pub const ECHILD = @as(c_int, 10);
pub const EAGAIN = @as(c_int, 11);
pub const ENOMEM = @as(c_int, 12);
pub const EACCES = @as(c_int, 13);
pub const EFAULT = @as(c_int, 14);
pub const ENOTBLK = @as(c_int, 15);
pub const EBUSY = @as(c_int, 16);
pub const EEXIST = @as(c_int, 17);
pub const EXDEV = @as(c_int, 18);
pub const ENODEV = @as(c_int, 19);
pub const ENOTDIR = @as(c_int, 20);
pub const EISDIR = @as(c_int, 21);
pub const EINVAL = @as(c_int, 22);
pub const ENFILE = @as(c_int, 23);
pub const EMFILE = @as(c_int, 24);
pub const ENOTTY = @as(c_int, 25);
pub const ETXTBSY = @as(c_int, 26);
pub const EFBIG = @as(c_int, 27);
pub const ENOSPC = @as(c_int, 28);
pub const ESPIPE = @as(c_int, 29);
pub const EROFS = @as(c_int, 30);
pub const EMLINK = @as(c_int, 31);
pub const EPIPE = @as(c_int, 32);
pub const EDOM = @as(c_int, 33);
pub const ERANGE = @as(c_int, 34);
pub const EDEADLK = @as(c_int, 35);
pub const ENAMETOOLONG = @as(c_int, 36);
pub const ENOLCK = @as(c_int, 37);
pub const ENOSYS = @as(c_int, 38);
pub const ENOTEMPTY = @as(c_int, 39);
pub const ELOOP = @as(c_int, 40);
pub const EWOULDBLOCK = EAGAIN;
pub const ENOMSG = @as(c_int, 42);
pub const EIDRM = @as(c_int, 43);
pub const ECHRNG = @as(c_int, 44);
pub const EL2NSYNC = @as(c_int, 45);
pub const EL3HLT = @as(c_int, 46);
pub const EL3RST = @as(c_int, 47);
pub const ELNRNG = @as(c_int, 48);
pub const EUNATCH = @as(c_int, 49);
pub const ENOCSI = @as(c_int, 50);
pub const EL2HLT = @as(c_int, 51);
pub const EBADE = @as(c_int, 52);
pub const EBADR = @as(c_int, 53);
pub const EXFULL = @as(c_int, 54);
pub const ENOANO = @as(c_int, 55);
pub const EBADRQC = @as(c_int, 56);
pub const EBADSLT = @as(c_int, 57);
pub const EDEADLOCK = EDEADLK;
pub const EBFONT = @as(c_int, 59);
pub const ENOSTR = @as(c_int, 60);
pub const ENODATA = @as(c_int, 61);
pub const ETIME = @as(c_int, 62);
pub const ENOSR = @as(c_int, 63);
pub const ENONET = @as(c_int, 64);
pub const ENOPKG = @as(c_int, 65);
pub const EREMOTE = @as(c_int, 66);
pub const ENOLINK = @as(c_int, 67);
pub const EADV = @as(c_int, 68);
pub const ESRMNT = @as(c_int, 69);
pub const ECOMM = @as(c_int, 70);
pub const EPROTO = @as(c_int, 71);
pub const EMULTIHOP = @as(c_int, 72);
pub const EDOTDOT = @as(c_int, 73);
pub const EBADMSG = @as(c_int, 74);
pub const EOVERFLOW = @as(c_int, 75);
pub const ENOTUNIQ = @as(c_int, 76);
pub const EBADFD = @as(c_int, 77);
pub const EREMCHG = @as(c_int, 78);
pub const ELIBACC = @as(c_int, 79);
pub const ELIBBAD = @as(c_int, 80);
pub const ELIBSCN = @as(c_int, 81);
pub const ELIBMAX = @as(c_int, 82);
pub const ELIBEXEC = @as(c_int, 83);
pub const EILSEQ = @as(c_int, 84);
pub const ERESTART = @as(c_int, 85);
pub const ESTRPIPE = @as(c_int, 86);
pub const EUSERS = @as(c_int, 87);
pub const ENOTSOCK = @as(c_int, 88);
pub const EDESTADDRREQ = @as(c_int, 89);
pub const EMSGSIZE = @as(c_int, 90);
pub const EPROTOTYPE = @as(c_int, 91);
pub const ENOPROTOOPT = @as(c_int, 92);
pub const EPROTONOSUPPORT = @as(c_int, 93);
pub const ESOCKTNOSUPPORT = @as(c_int, 94);
pub const EOPNOTSUPP = @as(c_int, 95);
pub const EPFNOSUPPORT = @as(c_int, 96);
pub const EAFNOSUPPORT = @as(c_int, 97);
pub const EADDRINUSE = @as(c_int, 98);
pub const EADDRNOTAVAIL = @as(c_int, 99);
pub const ENETDOWN = @as(c_int, 100);
pub const ENETUNREACH = @as(c_int, 101);
pub const ENETRESET = @as(c_int, 102);
pub const ECONNABORTED = @as(c_int, 103);
pub const ECONNRESET = @as(c_int, 104);
pub const ENOBUFS = @as(c_int, 105);
pub const EISCONN = @as(c_int, 106);
pub const ENOTCONN = @as(c_int, 107);
pub const ESHUTDOWN = @as(c_int, 108);
pub const ETOOMANYREFS = @as(c_int, 109);
pub const ETIMEDOUT = @as(c_int, 110);
pub const ECONNREFUSED = @as(c_int, 111);
pub const EHOSTDOWN = @as(c_int, 112);
pub const EHOSTUNREACH = @as(c_int, 113);
pub const EALREADY = @as(c_int, 114);
pub const EINPROGRESS = @as(c_int, 115);
pub const ESTALE = @as(c_int, 116);
pub const EUCLEAN = @as(c_int, 117);
pub const ENOTNAM = @as(c_int, 118);
pub const ENAVAIL = @as(c_int, 119);
pub const EISNAM = @as(c_int, 120);
pub const EREMOTEIO = @as(c_int, 121);
pub const EDQUOT = @as(c_int, 122);
pub const ENOMEDIUM = @as(c_int, 123);
pub const EMEDIUMTYPE = @as(c_int, 124);
pub const ECANCELED = @as(c_int, 125);
pub const ENOKEY = @as(c_int, 126);
pub const EKEYEXPIRED = @as(c_int, 127);
pub const EKEYREVOKED = @as(c_int, 128);
pub const EKEYREJECTED = @as(c_int, 129);
pub const EOWNERDEAD = @as(c_int, 130);
pub const ENOTRECOVERABLE = @as(c_int, 131);
pub const ERFKILL = @as(c_int, 132);
pub const EHWPOISON = @as(c_int, 133);
pub const ENOTSUP = EOPNOTSUPP;
pub const errno = __errno_location().*;
pub const _LOCALE_H = @as(c_int, 1);
pub const _BITS_LOCALE_H = @as(c_int, 1);
pub const __LC_CTYPE = @as(c_int, 0);
pub const __LC_NUMERIC = @as(c_int, 1);
pub const __LC_TIME = @as(c_int, 2);
pub const __LC_COLLATE = @as(c_int, 3);
pub const __LC_MONETARY = @as(c_int, 4);
pub const __LC_MESSAGES = @as(c_int, 5);
pub const __LC_ALL = @as(c_int, 6);
pub const __LC_PAPER = @as(c_int, 7);
pub const __LC_NAME = @as(c_int, 8);
pub const __LC_ADDRESS = @as(c_int, 9);
pub const __LC_TELEPHONE = @as(c_int, 10);
pub const __LC_MEASUREMENT = @as(c_int, 11);
pub const __LC_IDENTIFICATION = @as(c_int, 12);
pub const LC_CTYPE = __LC_CTYPE;
pub const LC_NUMERIC = __LC_NUMERIC;
pub const LC_TIME = __LC_TIME;
pub const LC_COLLATE = __LC_COLLATE;
pub const LC_MONETARY = __LC_MONETARY;
pub const LC_MESSAGES = __LC_MESSAGES;
pub const LC_ALL = __LC_ALL;
pub const LC_PAPER = __LC_PAPER;
pub const LC_NAME = __LC_NAME;
pub const LC_ADDRESS = __LC_ADDRESS;
pub const LC_TELEPHONE = __LC_TELEPHONE;
pub const LC_MEASUREMENT = __LC_MEASUREMENT;
pub const LC_IDENTIFICATION = __LC_IDENTIFICATION;
pub const LC_CTYPE_MASK = @as(c_int, 1) << __LC_CTYPE;
pub const LC_NUMERIC_MASK = @as(c_int, 1) << __LC_NUMERIC;
pub const LC_TIME_MASK = @as(c_int, 1) << __LC_TIME;
pub const LC_COLLATE_MASK = @as(c_int, 1) << __LC_COLLATE;
pub const LC_MONETARY_MASK = @as(c_int, 1) << __LC_MONETARY;
pub const LC_MESSAGES_MASK = @as(c_int, 1) << __LC_MESSAGES;
pub const LC_PAPER_MASK = @as(c_int, 1) << __LC_PAPER;
pub const LC_NAME_MASK = @as(c_int, 1) << __LC_NAME;
pub const LC_ADDRESS_MASK = @as(c_int, 1) << __LC_ADDRESS;
pub const LC_TELEPHONE_MASK = @as(c_int, 1) << __LC_TELEPHONE;
pub const LC_MEASUREMENT_MASK = @as(c_int, 1) << __LC_MEASUREMENT;
pub const LC_IDENTIFICATION_MASK = @as(c_int, 1) << __LC_IDENTIFICATION;
pub const LC_ALL_MASK = ((((((((((LC_CTYPE_MASK | LC_NUMERIC_MASK) | LC_TIME_MASK) | LC_COLLATE_MASK) | LC_MONETARY_MASK) | LC_MESSAGES_MASK) | LC_PAPER_MASK) | LC_NAME_MASK) | LC_ADDRESS_MASK) | LC_TELEPHONE_MASK) | LC_MEASUREMENT_MASK) | LC_IDENTIFICATION_MASK;
pub const LC_GLOBAL_LOCALE = @import("std").zig.c_translation.cast(locale_t, -@as(c_long, 1));
pub const PG_USED_FOR_ASSERTS_ONLY = pg_attribute_unused();
pub const HAVE_PG_ATTRIBUTE_NORETURN = @as(c_int, 1);
pub inline fn pg_unreachable() @TypeOf(__builtin_unreachable()) {
    return __builtin_unreachable();
}
pub inline fn likely(x: anytype) @TypeOf(__builtin_expect(x != @as(c_int, 0), @as(c_int, 1))) {
    return __builtin_expect(x != @as(c_int, 0), @as(c_int, 1));
}
pub inline fn unlikely(x: anytype) @TypeOf(__builtin_expect(x != @as(c_int, 0), @as(c_int, 0))) {
    return __builtin_expect(x != @as(c_int, 0), @as(c_int, 0));
}
pub inline fn CppAsString2(x: anytype) @TypeOf(CppAsString(x)) {
    return CppAsString(x);
}
pub const FLEXIBLE_ARRAY_MEMBER = "";
pub const HAVE_PRAGMA_GCC_SYSTEM_HEADER = @as(c_int, 1);
pub const __STDBOOL_H = "";
pub const __bool_true_false_are_defined = @as(c_int, 1);
pub const @"bool" = bool;
pub const @"true" = @as(c_int, 1);
pub const @"false" = @as(c_int, 0);
pub const INT64CONST = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const UINT64CONST = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INT64_FORMAT = "%" ++ INT64_MODIFIER ++ "d";
pub const UINT64_FORMAT = "%" ++ INT64_MODIFIER ++ "u";
pub const HAVE_INT128 = @as(c_int, 1);
pub const PG_INT8_MIN = -@as(c_int, 0x7F) - @as(c_int, 1);
pub const PG_INT8_MAX = @as(c_int, 0x7F);
pub const PG_UINT8_MAX = @as(c_int, 0xFF);
pub const PG_INT16_MIN = -@as(c_int, 0x7FFF) - @as(c_int, 1);
pub const PG_INT16_MAX = @as(c_int, 0x7FFF);
pub const PG_UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFF, .hexadecimal);
pub const PG_INT32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7FFFFFFF, .hexadecimal) - @as(c_int, 1);
pub const PG_INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7FFFFFFF, .hexadecimal);
pub const PG_UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xFFFFFFFF, .hexadecimal);
pub const PG_INT64_MIN = -INT64CONST(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7FFFFFFFFFFFFFFF, .hexadecimal)) - @as(c_int, 1);
pub const PG_INT64_MAX = INT64CONST(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7FFFFFFFFFFFFFFF, .hexadecimal));
pub const PG_UINT64_MAX = UINT64CONST(@import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFFFFFFFFFF, .hexadecimal));
pub const HAVE_INT64_TIMESTAMP = "";
pub const FLOAT8PASSBYVAL = @"true";
pub const InvalidSubTransactionId = @import("std").zig.c_translation.cast(SubTransactionId, @as(c_int, 0));
pub const TopSubTransactionId = @import("std").zig.c_translation.cast(SubTransactionId, @as(c_int, 1));
pub const FirstCommandId = @import("std").zig.c_translation.cast(CommandId, @as(c_int, 0));
pub const InvalidCommandId = ~@import("std").zig.c_translation.cast(CommandId, @as(c_int, 0));
pub const VARHDRSZ = @import("std").zig.c_translation.cast(int32, @import("std").zig.c_translation.sizeof(int32));
pub inline fn NameStr(name: anytype) @TypeOf(name.data) {
    return name.data;
}
pub inline fn BoolIsValid(boolean: anytype) @TypeOf((boolean == @"false") or (boolean == @"true")) {
    return (boolean == @"false") or (boolean == @"true");
}
pub inline fn PointerIsAligned(pointer: anytype, @"type": anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.rem(@import("std").zig.c_translation.cast(usize, pointer), @import("std").zig.c_translation.sizeof(@"type")) == @as(c_int, 0)) {
    _ = @TypeOf(@"type");
    return @import("std").zig.c_translation.MacroArithmetic.rem(@import("std").zig.c_translation.cast(usize, pointer), @import("std").zig.c_translation.sizeof(@"type")) == @as(c_int, 0);
}
pub inline fn OffsetToPointer(base: anytype, offset: anytype) ?*anyopaque {
    return @import("std").zig.c_translation.cast(?*anyopaque, @import("std").zig.c_translation.cast([*c]u8, base) + offset);
}
pub inline fn OidIsValid(objectId: anytype) @TypeOf(@"bool"(objectId != InvalidOid)) {
    return @"bool"(objectId != InvalidOid);
}
pub inline fn RegProcedureIsValid(p: anytype) @TypeOf(OidIsValid(p)) {
    return OidIsValid(p);
}
pub inline fn TYPEALIGN(ALIGNVAL: anytype, LEN: anytype) @TypeOf((@import("std").zig.c_translation.cast(usize, LEN) + (ALIGNVAL - @as(c_int, 1))) & ~@import("std").zig.c_translation.cast(usize, ALIGNVAL - @as(c_int, 1))) {
    return (@import("std").zig.c_translation.cast(usize, LEN) + (ALIGNVAL - @as(c_int, 1))) & ~@import("std").zig.c_translation.cast(usize, ALIGNVAL - @as(c_int, 1));
}
pub inline fn SHORTALIGN(LEN: anytype) @TypeOf(TYPEALIGN(ALIGNOF_SHORT, LEN)) {
    return TYPEALIGN(ALIGNOF_SHORT, LEN);
}
pub inline fn INTALIGN(LEN: anytype) @TypeOf(TYPEALIGN(ALIGNOF_INT, LEN)) {
    return TYPEALIGN(ALIGNOF_INT, LEN);
}
pub inline fn LONGALIGN(LEN: anytype) @TypeOf(TYPEALIGN(ALIGNOF_LONG, LEN)) {
    return TYPEALIGN(ALIGNOF_LONG, LEN);
}
pub inline fn DOUBLEALIGN(LEN: anytype) @TypeOf(TYPEALIGN(ALIGNOF_DOUBLE, LEN)) {
    return TYPEALIGN(ALIGNOF_DOUBLE, LEN);
}
pub inline fn MAXALIGN(LEN: anytype) @TypeOf(TYPEALIGN(MAXIMUM_ALIGNOF, LEN)) {
    return TYPEALIGN(MAXIMUM_ALIGNOF, LEN);
}
pub inline fn BUFFERALIGN(LEN: anytype) @TypeOf(TYPEALIGN(ALIGNOF_BUFFER, LEN)) {
    return TYPEALIGN(ALIGNOF_BUFFER, LEN);
}
pub inline fn CACHELINEALIGN(LEN: anytype) @TypeOf(TYPEALIGN(PG_CACHE_LINE_SIZE, LEN)) {
    return TYPEALIGN(PG_CACHE_LINE_SIZE, LEN);
}
pub inline fn TYPEALIGN_DOWN(ALIGNVAL: anytype, LEN: anytype) @TypeOf(@import("std").zig.c_translation.cast(usize, LEN) & ~@import("std").zig.c_translation.cast(usize, ALIGNVAL - @as(c_int, 1))) {
    return @import("std").zig.c_translation.cast(usize, LEN) & ~@import("std").zig.c_translation.cast(usize, ALIGNVAL - @as(c_int, 1));
}
pub inline fn SHORTALIGN_DOWN(LEN: anytype) @TypeOf(TYPEALIGN_DOWN(ALIGNOF_SHORT, LEN)) {
    return TYPEALIGN_DOWN(ALIGNOF_SHORT, LEN);
}
pub inline fn INTALIGN_DOWN(LEN: anytype) @TypeOf(TYPEALIGN_DOWN(ALIGNOF_INT, LEN)) {
    return TYPEALIGN_DOWN(ALIGNOF_INT, LEN);
}
pub inline fn LONGALIGN_DOWN(LEN: anytype) @TypeOf(TYPEALIGN_DOWN(ALIGNOF_LONG, LEN)) {
    return TYPEALIGN_DOWN(ALIGNOF_LONG, LEN);
}
pub inline fn DOUBLEALIGN_DOWN(LEN: anytype) @TypeOf(TYPEALIGN_DOWN(ALIGNOF_DOUBLE, LEN)) {
    return TYPEALIGN_DOWN(ALIGNOF_DOUBLE, LEN);
}
pub inline fn MAXALIGN_DOWN(LEN: anytype) @TypeOf(TYPEALIGN_DOWN(MAXIMUM_ALIGNOF, LEN)) {
    return TYPEALIGN_DOWN(MAXIMUM_ALIGNOF, LEN);
}
pub inline fn BUFFERALIGN_DOWN(LEN: anytype) @TypeOf(TYPEALIGN_DOWN(ALIGNOF_BUFFER, LEN)) {
    return TYPEALIGN_DOWN(ALIGNOF_BUFFER, LEN);
}
pub inline fn TYPEALIGN64(ALIGNVAL: anytype, LEN: anytype) @TypeOf((@import("std").zig.c_translation.cast(uint64, LEN) + (ALIGNVAL - @as(c_int, 1))) & ~@import("std").zig.c_translation.cast(uint64, ALIGNVAL - @as(c_int, 1))) {
    return (@import("std").zig.c_translation.cast(uint64, LEN) + (ALIGNVAL - @as(c_int, 1))) & ~@import("std").zig.c_translation.cast(uint64, ALIGNVAL - @as(c_int, 1));
}
pub inline fn MAXALIGN64(LEN: anytype) @TypeOf(TYPEALIGN64(MAXIMUM_ALIGNOF, LEN)) {
    return TYPEALIGN64(MAXIMUM_ALIGNOF, LEN);
}
pub inline fn Assert(condition: anytype) anyopaque {
    _ = @TypeOf(condition);
    return @import("std").zig.c_translation.cast(anyopaque, @"true");
}
pub inline fn AssertMacro(condition: anytype) anyopaque {
    _ = @TypeOf(condition);
    return @import("std").zig.c_translation.cast(anyopaque, @"true");
}
pub inline fn AssertPointerAlignment(ptr: anytype, bndr: anytype) @TypeOf(Assert(TYPEALIGN(bndr, @import("std").zig.c_translation.cast(usize, ptr)) == @import("std").zig.c_translation.cast(usize, ptr))) {
    return Assert(TYPEALIGN(bndr, @import("std").zig.c_translation.cast(usize, ptr)) == @import("std").zig.c_translation.cast(usize, ptr));
}
pub inline fn Max(x: anytype, y: anytype) @TypeOf(if (x > y) x else y) {
    return if (x > y) x else y;
}
pub inline fn Min(x: anytype, y: anytype) @TypeOf(if (x < y) x else y) {
    return if (x < y) x else y;
}
pub const LONG_ALIGN_MASK = @import("std").zig.c_translation.sizeof(c_long) - @as(c_int, 1);
pub inline fn MemSetTest(val: anytype, len: anytype) @TypeOf(((((len & LONG_ALIGN_MASK) == @as(c_int, 0)) and (len <= MEMSET_LOOP_LIMIT)) and (MEMSET_LOOP_LIMIT != @as(c_int, 0))) and (val == @as(c_int, 0))) {
    return ((((len & LONG_ALIGN_MASK) == @as(c_int, 0)) and (len <= MEMSET_LOOP_LIMIT)) and (MEMSET_LOOP_LIMIT != @as(c_int, 0))) and (val == @as(c_int, 0));
}
pub inline fn FLOAT4_FITS_IN_INT16(num: anytype) @TypeOf((num >= @import("std").zig.c_translation.cast(float4, PG_INT16_MIN)) and (num < -@import("std").zig.c_translation.cast(float4, PG_INT16_MIN))) {
    return (num >= @import("std").zig.c_translation.cast(float4, PG_INT16_MIN)) and (num < -@import("std").zig.c_translation.cast(float4, PG_INT16_MIN));
}
pub inline fn FLOAT4_FITS_IN_INT32(num: anytype) @TypeOf((num >= @import("std").zig.c_translation.cast(float4, PG_INT32_MIN)) and (num < -@import("std").zig.c_translation.cast(float4, PG_INT32_MIN))) {
    return (num >= @import("std").zig.c_translation.cast(float4, PG_INT32_MIN)) and (num < -@import("std").zig.c_translation.cast(float4, PG_INT32_MIN));
}
pub inline fn FLOAT4_FITS_IN_INT64(num: anytype) @TypeOf((num >= @import("std").zig.c_translation.cast(float4, PG_INT64_MIN)) and (num < -@import("std").zig.c_translation.cast(float4, PG_INT64_MIN))) {
    return (num >= @import("std").zig.c_translation.cast(float4, PG_INT64_MIN)) and (num < -@import("std").zig.c_translation.cast(float4, PG_INT64_MIN));
}
pub inline fn FLOAT8_FITS_IN_INT16(num: anytype) @TypeOf((num >= @import("std").zig.c_translation.cast(float8, PG_INT16_MIN)) and (num < -@import("std").zig.c_translation.cast(float8, PG_INT16_MIN))) {
    return (num >= @import("std").zig.c_translation.cast(float8, PG_INT16_MIN)) and (num < -@import("std").zig.c_translation.cast(float8, PG_INT16_MIN));
}
pub inline fn FLOAT8_FITS_IN_INT32(num: anytype) @TypeOf((num >= @import("std").zig.c_translation.cast(float8, PG_INT32_MIN)) and (num < -@import("std").zig.c_translation.cast(float8, PG_INT32_MIN))) {
    return (num >= @import("std").zig.c_translation.cast(float8, PG_INT32_MIN)) and (num < -@import("std").zig.c_translation.cast(float8, PG_INT32_MIN));
}
pub inline fn FLOAT8_FITS_IN_INT64(num: anytype) @TypeOf((num >= @import("std").zig.c_translation.cast(float8, PG_INT64_MIN)) and (num < -@import("std").zig.c_translation.cast(float8, PG_INT64_MIN))) {
    return (num >= @import("std").zig.c_translation.cast(float8, PG_INT64_MIN)) and (num < -@import("std").zig.c_translation.cast(float8, PG_INT64_MIN));
}
pub const HIGHBIT = @as(c_int, 0x80);
pub inline fn IS_HIGHBIT_SET(ch: anytype) @TypeOf(@import("std").zig.c_translation.cast(u8, ch) & HIGHBIT) {
    return @import("std").zig.c_translation.cast(u8, ch) & HIGHBIT;
}
pub inline fn SQL_STR_DOUBLE(ch: anytype, escape_backslash: anytype) @TypeOf((ch == '\'') or ((ch == '\\') and (escape_backslash != 0))) {
    return (ch == '\'') or ((ch == '\\') and (escape_backslash != 0));
}
pub const ESCAPE_STRING_SYNTAX = 'E';
pub const STATUS_OK = @as(c_int, 0);
pub const STATUS_ERROR = -@as(c_int, 1);
pub const STATUS_EOF = -@as(c_int, 2);
pub inline fn gettext(x: anytype) @TypeOf(x) {
    return x;
}
pub inline fn dgettext(d: anytype, x: anytype) @TypeOf(x) {
    _ = @TypeOf(d);
    return x;
}
pub inline fn ngettext(s: anytype, p: anytype, n: anytype) @TypeOf(if (n == @as(c_int, 1)) s else p) {
    return if (n == @as(c_int, 1)) s else p;
}
pub inline fn dngettext(d: anytype, s: anytype, p: anytype, n: anytype) @TypeOf(if (n == @as(c_int, 1)) s else p) {
    _ = @TypeOf(d);
    return if (n == @as(c_int, 1)) s else p;
}
pub inline fn @"_"(x: anytype) @TypeOf(gettext(x)) {
    return gettext(x);
}
pub inline fn gettext_noop(x: anytype) @TypeOf(x) {
    return x;
}
pub inline fn PG_TEXTDOMAIN(domain: anytype) @TypeOf(domain ++ "-" ++ PG_MAJORVERSION) {
    return domain ++ "-" ++ PG_MAJORVERSION;
}
pub const PG_BINARY = @as(c_int, 0);
pub const PG_BINARY_A = "a";
pub const PG_BINARY_R = "r";
pub const PG_BINARY_W = "w";
pub inline fn strtoi64(str: anytype, endptr: anytype, base: anytype) int64 {
    return @import("std").zig.c_translation.cast(int64, strtol(str, endptr, base));
}
pub inline fn strtou64(str: anytype, endptr: anytype, base: anytype) uint64 {
    return @import("std").zig.c_translation.cast(uint64, strtoul(str, endptr, base));
}
pub inline fn i64abs(i: anytype) @TypeOf(labs(i)) {
    return labs(i);
}
pub const PGDLLIMPORT = "";
pub const PG_PORT_H = "";
pub const _CTYPE_H = @as(c_int, 1);
pub inline fn _ISbit(bit_1: anytype) @TypeOf(if (bit_1 < @as(c_int, 8)) (@as(c_int, 1) << bit_1) << @as(c_int, 8) else (@as(c_int, 1) << bit_1) >> @as(c_int, 8)) {
    return if (bit_1 < @as(c_int, 8)) (@as(c_int, 1) << bit_1) << @as(c_int, 8) else (@as(c_int, 1) << bit_1) >> @as(c_int, 8);
}
pub inline fn __isctype(c: anytype, @"type": anytype) @TypeOf(__ctype_b_loc().*[@intCast(usize, @import("std").zig.c_translation.cast(c_int, c))] & @import("std").zig.c_translation.cast(c_ushort, @"type")) {
    return __ctype_b_loc().*[@intCast(usize, @import("std").zig.c_translation.cast(c_int, c))] & @import("std").zig.c_translation.cast(c_ushort, @"type");
}
pub inline fn __isascii(c: anytype) @TypeOf((c & ~@as(c_int, 0x7f)) == @as(c_int, 0)) {
    return (c & ~@as(c_int, 0x7f)) == @as(c_int, 0);
}
pub inline fn __toascii(c: anytype) @TypeOf(c & @as(c_int, 0x7f)) {
    return c & @as(c_int, 0x7f);
}
pub inline fn __isctype_l(c: anytype, @"type": anytype, locale: anytype) @TypeOf(locale.*.__ctype_b[@intCast(usize, @import("std").zig.c_translation.cast(c_int, c))] & @import("std").zig.c_translation.cast(c_ushort, @"type")) {
    return locale.*.__ctype_b[@intCast(usize, @import("std").zig.c_translation.cast(c_int, c))] & @import("std").zig.c_translation.cast(c_ushort, @"type");
}
pub inline fn __isalnum_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISalnum, l)) {
    return __isctype_l(c, _ISalnum, l);
}
pub inline fn __isalpha_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISalpha, l)) {
    return __isctype_l(c, _ISalpha, l);
}
pub inline fn __iscntrl_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _IScntrl, l)) {
    return __isctype_l(c, _IScntrl, l);
}
pub inline fn __isdigit_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISdigit, l)) {
    return __isctype_l(c, _ISdigit, l);
}
pub inline fn __islower_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISlower, l)) {
    return __isctype_l(c, _ISlower, l);
}
pub inline fn __isgraph_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISgraph, l)) {
    return __isctype_l(c, _ISgraph, l);
}
pub inline fn __isprint_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISprint, l)) {
    return __isctype_l(c, _ISprint, l);
}
pub inline fn __ispunct_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISpunct, l)) {
    return __isctype_l(c, _ISpunct, l);
}
pub inline fn __isspace_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISspace, l)) {
    return __isctype_l(c, _ISspace, l);
}
pub inline fn __isupper_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISupper, l)) {
    return __isctype_l(c, _ISupper, l);
}
pub inline fn __isxdigit_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISxdigit, l)) {
    return __isctype_l(c, _ISxdigit, l);
}
pub inline fn __isblank_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISblank, l)) {
    return __isctype_l(c, _ISblank, l);
}
pub inline fn __isascii_l(c: anytype, l: anytype) @TypeOf(__isascii(c)) {
    return blk_1: {
        _ = @TypeOf(l);
        break :blk_1 __isascii(c);
    };
}
pub inline fn __toascii_l(c: anytype, l: anytype) @TypeOf(__toascii(c)) {
    return blk_1: {
        _ = @TypeOf(l);
        break :blk_1 __toascii(c);
    };
}
pub inline fn isascii_l(c: anytype, l: anytype) @TypeOf(__isascii_l(c, l)) {
    return __isascii_l(c, l);
}
pub inline fn toascii_l(c: anytype, l: anytype) @TypeOf(__toascii_l(c, l)) {
    return __toascii_l(c, l);
}
pub const PGINVALID_SOCKET = -@as(c_int, 1);
pub inline fn IS_NONWINDOWS_DIR_SEP(ch: anytype) @TypeOf(ch == '/') {
    return ch == '/';
}
pub inline fn is_nonwindows_absolute_path(filename: anytype) @TypeOf(IS_NONWINDOWS_DIR_SEP(filename[@intCast(usize, @as(c_int, 0))])) {
    return IS_NONWINDOWS_DIR_SEP(filename[@intCast(usize, @as(c_int, 0))]);
}
pub inline fn IS_WINDOWS_DIR_SEP(ch: anytype) @TypeOf((ch == '/') or (ch == '\\')) {
    return (ch == '/') or (ch == '\\');
}
pub inline fn is_windows_absolute_path(filename: anytype) @TypeOf((IS_WINDOWS_DIR_SEP(filename[@intCast(usize, @as(c_int, 0))]) != 0) or (((isalpha(@import("std").zig.c_translation.cast(u8, filename[@intCast(usize, @as(c_int, 0))])) != 0) and (filename[@intCast(usize, @as(c_int, 1))] == ':')) and (IS_WINDOWS_DIR_SEP(filename[@intCast(usize, @as(c_int, 2))]) != 0))) {
    return (IS_WINDOWS_DIR_SEP(filename[@intCast(usize, @as(c_int, 0))]) != 0) or (((isalpha(@import("std").zig.c_translation.cast(u8, filename[@intCast(usize, @as(c_int, 0))])) != 0) and (filename[@intCast(usize, @as(c_int, 1))] == ':')) and (IS_WINDOWS_DIR_SEP(filename[@intCast(usize, @as(c_int, 2))]) != 0));
}
pub inline fn IS_DIR_SEP(ch: anytype) @TypeOf(IS_NONWINDOWS_DIR_SEP(ch)) {
    return IS_NONWINDOWS_DIR_SEP(ch);
}
pub inline fn is_absolute_path(filename: anytype) @TypeOf(is_nonwindows_absolute_path(filename)) {
    return is_nonwindows_absolute_path(filename);
}
pub const PG_BACKEND_VERSIONSTR = "postgres (PostgreSQL) " ++ PG_VERSION ++ "\n";
pub const EXE = "";
pub const DEVNULL = "/dev/null";
pub const USE_REPL_SNPRINTF = @as(c_int, 1);
pub const PG_STRERROR_R_BUFLEN = @as(c_int, 256);
pub const PG_IOLBF = _IOLBF;
pub const pgoff_t = off_t;
pub const _MATH_H = @as(c_int, 1);
pub const _BITS_LIBM_SIMD_DECL_STUBS_H = @as(c_int, 1);
pub const __DECL_SIMD_cos = "";
pub const __DECL_SIMD_cosf = "";
pub const __DECL_SIMD_cosl = "";
pub const __DECL_SIMD_cosf16 = "";
pub const __DECL_SIMD_cosf32 = "";
pub const __DECL_SIMD_cosf64 = "";
pub const __DECL_SIMD_cosf128 = "";
pub const __DECL_SIMD_cosf32x = "";
pub const __DECL_SIMD_cosf64x = "";
pub const __DECL_SIMD_cosf128x = "";
pub const __DECL_SIMD_sin = "";
pub const __DECL_SIMD_sinf = "";
pub const __DECL_SIMD_sinl = "";
pub const __DECL_SIMD_sinf16 = "";
pub const __DECL_SIMD_sinf32 = "";
pub const __DECL_SIMD_sinf64 = "";
pub const __DECL_SIMD_sinf128 = "";
pub const __DECL_SIMD_sinf32x = "";
pub const __DECL_SIMD_sinf64x = "";
pub const __DECL_SIMD_sinf128x = "";
pub const __DECL_SIMD_sincos = "";
pub const __DECL_SIMD_sincosf = "";
pub const __DECL_SIMD_sincosl = "";
pub const __DECL_SIMD_sincosf16 = "";
pub const __DECL_SIMD_sincosf32 = "";
pub const __DECL_SIMD_sincosf64 = "";
pub const __DECL_SIMD_sincosf128 = "";
pub const __DECL_SIMD_sincosf32x = "";
pub const __DECL_SIMD_sincosf64x = "";
pub const __DECL_SIMD_sincosf128x = "";
pub const __DECL_SIMD_log = "";
pub const __DECL_SIMD_logf = "";
pub const __DECL_SIMD_logl = "";
pub const __DECL_SIMD_logf16 = "";
pub const __DECL_SIMD_logf32 = "";
pub const __DECL_SIMD_logf64 = "";
pub const __DECL_SIMD_logf128 = "";
pub const __DECL_SIMD_logf32x = "";
pub const __DECL_SIMD_logf64x = "";
pub const __DECL_SIMD_logf128x = "";
pub const __DECL_SIMD_exp = "";
pub const __DECL_SIMD_expf = "";
pub const __DECL_SIMD_expl = "";
pub const __DECL_SIMD_expf16 = "";
pub const __DECL_SIMD_expf32 = "";
pub const __DECL_SIMD_expf64 = "";
pub const __DECL_SIMD_expf128 = "";
pub const __DECL_SIMD_expf32x = "";
pub const __DECL_SIMD_expf64x = "";
pub const __DECL_SIMD_expf128x = "";
pub const __DECL_SIMD_pow = "";
pub const __DECL_SIMD_powf = "";
pub const __DECL_SIMD_powl = "";
pub const __DECL_SIMD_powf16 = "";
pub const __DECL_SIMD_powf32 = "";
pub const __DECL_SIMD_powf64 = "";
pub const __DECL_SIMD_powf128 = "";
pub const __DECL_SIMD_powf32x = "";
pub const __DECL_SIMD_powf64x = "";
pub const __DECL_SIMD_powf128x = "";
pub const __DECL_SIMD_acos = "";
pub const __DECL_SIMD_acosf = "";
pub const __DECL_SIMD_acosl = "";
pub const __DECL_SIMD_acosf16 = "";
pub const __DECL_SIMD_acosf32 = "";
pub const __DECL_SIMD_acosf64 = "";
pub const __DECL_SIMD_acosf128 = "";
pub const __DECL_SIMD_acosf32x = "";
pub const __DECL_SIMD_acosf64x = "";
pub const __DECL_SIMD_acosf128x = "";
pub const __DECL_SIMD_atan = "";
pub const __DECL_SIMD_atanf = "";
pub const __DECL_SIMD_atanl = "";
pub const __DECL_SIMD_atanf16 = "";
pub const __DECL_SIMD_atanf32 = "";
pub const __DECL_SIMD_atanf64 = "";
pub const __DECL_SIMD_atanf128 = "";
pub const __DECL_SIMD_atanf32x = "";
pub const __DECL_SIMD_atanf64x = "";
pub const __DECL_SIMD_atanf128x = "";
pub const __DECL_SIMD_asin = "";
pub const __DECL_SIMD_asinf = "";
pub const __DECL_SIMD_asinl = "";
pub const __DECL_SIMD_asinf16 = "";
pub const __DECL_SIMD_asinf32 = "";
pub const __DECL_SIMD_asinf64 = "";
pub const __DECL_SIMD_asinf128 = "";
pub const __DECL_SIMD_asinf32x = "";
pub const __DECL_SIMD_asinf64x = "";
pub const __DECL_SIMD_asinf128x = "";
pub const __DECL_SIMD_hypot = "";
pub const __DECL_SIMD_hypotf = "";
pub const __DECL_SIMD_hypotl = "";
pub const __DECL_SIMD_hypotf16 = "";
pub const __DECL_SIMD_hypotf32 = "";
pub const __DECL_SIMD_hypotf64 = "";
pub const __DECL_SIMD_hypotf128 = "";
pub const __DECL_SIMD_hypotf32x = "";
pub const __DECL_SIMD_hypotf64x = "";
pub const __DECL_SIMD_hypotf128x = "";
pub const __DECL_SIMD_exp2 = "";
pub const __DECL_SIMD_exp2f = "";
pub const __DECL_SIMD_exp2l = "";
pub const __DECL_SIMD_exp2f16 = "";
pub const __DECL_SIMD_exp2f32 = "";
pub const __DECL_SIMD_exp2f64 = "";
pub const __DECL_SIMD_exp2f128 = "";
pub const __DECL_SIMD_exp2f32x = "";
pub const __DECL_SIMD_exp2f64x = "";
pub const __DECL_SIMD_exp2f128x = "";
pub const __DECL_SIMD_exp10 = "";
pub const __DECL_SIMD_exp10f = "";
pub const __DECL_SIMD_exp10l = "";
pub const __DECL_SIMD_exp10f16 = "";
pub const __DECL_SIMD_exp10f32 = "";
pub const __DECL_SIMD_exp10f64 = "";
pub const __DECL_SIMD_exp10f128 = "";
pub const __DECL_SIMD_exp10f32x = "";
pub const __DECL_SIMD_exp10f64x = "";
pub const __DECL_SIMD_exp10f128x = "";
pub const __DECL_SIMD_cosh = "";
pub const __DECL_SIMD_coshf = "";
pub const __DECL_SIMD_coshl = "";
pub const __DECL_SIMD_coshf16 = "";
pub const __DECL_SIMD_coshf32 = "";
pub const __DECL_SIMD_coshf64 = "";
pub const __DECL_SIMD_coshf128 = "";
pub const __DECL_SIMD_coshf32x = "";
pub const __DECL_SIMD_coshf64x = "";
pub const __DECL_SIMD_coshf128x = "";
pub const __DECL_SIMD_expm1 = "";
pub const __DECL_SIMD_expm1f = "";
pub const __DECL_SIMD_expm1l = "";
pub const __DECL_SIMD_expm1f16 = "";
pub const __DECL_SIMD_expm1f32 = "";
pub const __DECL_SIMD_expm1f64 = "";
pub const __DECL_SIMD_expm1f128 = "";
pub const __DECL_SIMD_expm1f32x = "";
pub const __DECL_SIMD_expm1f64x = "";
pub const __DECL_SIMD_expm1f128x = "";
pub const __DECL_SIMD_sinh = "";
pub const __DECL_SIMD_sinhf = "";
pub const __DECL_SIMD_sinhl = "";
pub const __DECL_SIMD_sinhf16 = "";
pub const __DECL_SIMD_sinhf32 = "";
pub const __DECL_SIMD_sinhf64 = "";
pub const __DECL_SIMD_sinhf128 = "";
pub const __DECL_SIMD_sinhf32x = "";
pub const __DECL_SIMD_sinhf64x = "";
pub const __DECL_SIMD_sinhf128x = "";
pub const __DECL_SIMD_cbrt = "";
pub const __DECL_SIMD_cbrtf = "";
pub const __DECL_SIMD_cbrtl = "";
pub const __DECL_SIMD_cbrtf16 = "";
pub const __DECL_SIMD_cbrtf32 = "";
pub const __DECL_SIMD_cbrtf64 = "";
pub const __DECL_SIMD_cbrtf128 = "";
pub const __DECL_SIMD_cbrtf32x = "";
pub const __DECL_SIMD_cbrtf64x = "";
pub const __DECL_SIMD_cbrtf128x = "";
pub const __DECL_SIMD_atan2 = "";
pub const __DECL_SIMD_atan2f = "";
pub const __DECL_SIMD_atan2l = "";
pub const __DECL_SIMD_atan2f16 = "";
pub const __DECL_SIMD_atan2f32 = "";
pub const __DECL_SIMD_atan2f64 = "";
pub const __DECL_SIMD_atan2f128 = "";
pub const __DECL_SIMD_atan2f32x = "";
pub const __DECL_SIMD_atan2f64x = "";
pub const __DECL_SIMD_atan2f128x = "";
pub const __DECL_SIMD_log10 = "";
pub const __DECL_SIMD_log10f = "";
pub const __DECL_SIMD_log10l = "";
pub const __DECL_SIMD_log10f16 = "";
pub const __DECL_SIMD_log10f32 = "";
pub const __DECL_SIMD_log10f64 = "";
pub const __DECL_SIMD_log10f128 = "";
pub const __DECL_SIMD_log10f32x = "";
pub const __DECL_SIMD_log10f64x = "";
pub const __DECL_SIMD_log10f128x = "";
pub const __DECL_SIMD_log2 = "";
pub const __DECL_SIMD_log2f = "";
pub const __DECL_SIMD_log2l = "";
pub const __DECL_SIMD_log2f16 = "";
pub const __DECL_SIMD_log2f32 = "";
pub const __DECL_SIMD_log2f64 = "";
pub const __DECL_SIMD_log2f128 = "";
pub const __DECL_SIMD_log2f32x = "";
pub const __DECL_SIMD_log2f64x = "";
pub const __DECL_SIMD_log2f128x = "";
pub const __DECL_SIMD_log1p = "";
pub const __DECL_SIMD_log1pf = "";
pub const __DECL_SIMD_log1pl = "";
pub const __DECL_SIMD_log1pf16 = "";
pub const __DECL_SIMD_log1pf32 = "";
pub const __DECL_SIMD_log1pf64 = "";
pub const __DECL_SIMD_log1pf128 = "";
pub const __DECL_SIMD_log1pf32x = "";
pub const __DECL_SIMD_log1pf64x = "";
pub const __DECL_SIMD_log1pf128x = "";
pub const __DECL_SIMD_atanh = "";
pub const __DECL_SIMD_atanhf = "";
pub const __DECL_SIMD_atanhl = "";
pub const __DECL_SIMD_atanhf16 = "";
pub const __DECL_SIMD_atanhf32 = "";
pub const __DECL_SIMD_atanhf64 = "";
pub const __DECL_SIMD_atanhf128 = "";
pub const __DECL_SIMD_atanhf32x = "";
pub const __DECL_SIMD_atanhf64x = "";
pub const __DECL_SIMD_atanhf128x = "";
pub const __DECL_SIMD_acosh = "";
pub const __DECL_SIMD_acoshf = "";
pub const __DECL_SIMD_acoshl = "";
pub const __DECL_SIMD_acoshf16 = "";
pub const __DECL_SIMD_acoshf32 = "";
pub const __DECL_SIMD_acoshf64 = "";
pub const __DECL_SIMD_acoshf128 = "";
pub const __DECL_SIMD_acoshf32x = "";
pub const __DECL_SIMD_acoshf64x = "";
pub const __DECL_SIMD_acoshf128x = "";
pub const __DECL_SIMD_erf = "";
pub const __DECL_SIMD_erff = "";
pub const __DECL_SIMD_erfl = "";
pub const __DECL_SIMD_erff16 = "";
pub const __DECL_SIMD_erff32 = "";
pub const __DECL_SIMD_erff64 = "";
pub const __DECL_SIMD_erff128 = "";
pub const __DECL_SIMD_erff32x = "";
pub const __DECL_SIMD_erff64x = "";
pub const __DECL_SIMD_erff128x = "";
pub const __DECL_SIMD_tanh = "";
pub const __DECL_SIMD_tanhf = "";
pub const __DECL_SIMD_tanhl = "";
pub const __DECL_SIMD_tanhf16 = "";
pub const __DECL_SIMD_tanhf32 = "";
pub const __DECL_SIMD_tanhf64 = "";
pub const __DECL_SIMD_tanhf128 = "";
pub const __DECL_SIMD_tanhf32x = "";
pub const __DECL_SIMD_tanhf64x = "";
pub const __DECL_SIMD_tanhf128x = "";
pub const __DECL_SIMD_asinh = "";
pub const __DECL_SIMD_asinhf = "";
pub const __DECL_SIMD_asinhl = "";
pub const __DECL_SIMD_asinhf16 = "";
pub const __DECL_SIMD_asinhf32 = "";
pub const __DECL_SIMD_asinhf64 = "";
pub const __DECL_SIMD_asinhf128 = "";
pub const __DECL_SIMD_asinhf32x = "";
pub const __DECL_SIMD_asinhf64x = "";
pub const __DECL_SIMD_asinhf128x = "";
pub const __DECL_SIMD_erfc = "";
pub const __DECL_SIMD_erfcf = "";
pub const __DECL_SIMD_erfcl = "";
pub const __DECL_SIMD_erfcf16 = "";
pub const __DECL_SIMD_erfcf32 = "";
pub const __DECL_SIMD_erfcf64 = "";
pub const __DECL_SIMD_erfcf128 = "";
pub const __DECL_SIMD_erfcf32x = "";
pub const __DECL_SIMD_erfcf64x = "";
pub const __DECL_SIMD_erfcf128x = "";
pub const __DECL_SIMD_tan = "";
pub const __DECL_SIMD_tanf = "";
pub const __DECL_SIMD_tanl = "";
pub const __DECL_SIMD_tanf16 = "";
pub const __DECL_SIMD_tanf32 = "";
pub const __DECL_SIMD_tanf64 = "";
pub const __DECL_SIMD_tanf128 = "";
pub const __DECL_SIMD_tanf32x = "";
pub const __DECL_SIMD_tanf64x = "";
pub const __DECL_SIMD_tanf128x = "";
pub const HUGE_VALF = __builtin_huge_valf();
pub const INFINITY = __builtin_inff();
pub const NAN = __builtin_nanf("");
pub const __FP_LOGB0_IS_MIN = @as(c_int, 1);
pub const __FP_LOGBNAN_IS_MIN = @as(c_int, 1);
pub const FP_ILOGB0 = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const FP_ILOGBNAN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub inline fn __MATHCALL(function: anytype, suffix: anytype, args: anytype) @TypeOf(__MATHDECL(_Mdouble_, function, suffix, args)) {
    return __MATHDECL(_Mdouble_, function, suffix, args);
}
pub inline fn __MATHCALLX(function: anytype, suffix: anytype, args: anytype, attrib: anytype) @TypeOf(__MATHDECLX(_Mdouble_, function, suffix, args, attrib)) {
    return __MATHDECLX(_Mdouble_, function, suffix, args, attrib);
}
pub inline fn __MATHDECL_1(@"type": anytype, function: anytype, suffix: anytype, args: anytype) @TypeOf(__MATHDECL_1_IMPL(@"type", function, suffix, args)) {
    return __MATHDECL_1_IMPL(@"type", function, suffix, args);
}
pub inline fn __MATHDECL_ALIAS(@"type": anytype, function: anytype, suffix: anytype, args: anytype, alias: anytype) @TypeOf(__MATHDECL_1(@"type", function, suffix, args)) {
    _ = @TypeOf(alias);
    return __MATHDECL_1(@"type", function, suffix, args);
}
pub const _Mdouble_ = f64;
pub inline fn __MATH_PRECNAME(name: anytype, r: anytype) @TypeOf(__CONCAT(name, r)) {
    return __CONCAT(name, r);
}
pub const __MATH_DECLARING_DOUBLE = @as(c_int, 1);
pub const __MATH_DECLARING_FLOATN = @as(c_int, 0);
pub const __MATH_DECLARE_LDOUBLE = @as(c_int, 1);
pub inline fn __MATHCALL_NARROW(func: anytype, redir: anytype, nargs: anytype) @TypeOf(__MATHCALL_NARROW_NORMAL(func, nargs)) {
    _ = @TypeOf(redir);
    return __MATHCALL_NARROW_NORMAL(func, nargs);
}
pub inline fn signbit(x: anytype) @TypeOf(__builtin_signbit(x)) {
    return __builtin_signbit(x);
}
pub const MATH_ERRNO = @as(c_int, 1);
pub const MATH_ERREXCEPT = @as(c_int, 2);
pub const math_errhandling = MATH_ERRNO | MATH_ERREXCEPT;
pub const M_E = @as(f64, 2.7182818284590452354);
pub const M_LOG2E = @as(f64, 1.4426950408889634074);
pub const M_LOG10E = @as(f64, 0.43429448190325182765);
pub const M_LN2 = @as(f64, 0.69314718055994530942);
pub const M_LN10 = @as(f64, 2.30258509299404568402);
pub const M_PI = @as(f64, 3.14159265358979323846);
pub const M_PI_2 = @as(f64, 1.57079632679489661923);
pub const M_PI_4 = @as(f64, 0.78539816339744830962);
pub const M_1_PI = @as(f64, 0.31830988618379067154);
pub const M_2_PI = @as(f64, 0.63661977236758134308);
pub const M_2_SQRTPI = @as(f64, 1.12837916709551257390);
pub const M_SQRT2 = @as(f64, 1.41421356237309504880);
pub const M_SQRT1_2 = @as(f64, 0.70710678118654752440);
pub const pg_backend_random = pg_strong_random;
pub const HAVE_GETRLIMIT = @as(c_int, 1);
pub const HAVE_POLL = @as(c_int, 1);
pub const HAVE_POLL_H = @as(c_int, 1);
pub const HAVE_READLINK = @as(c_int, 1);
pub const HAVE_SETSID = @as(c_int, 1);
pub const HAVE_SHM_OPEN = @as(c_int, 1);
pub const HAVE_SYMLINK = @as(c_int, 1);
pub const ELOG_H = "";
pub const _SETJMP_H = @as(c_int, 1);
pub const _BITS_SETJMP_H = @as(c_int, 1);
pub const __jmp_buf_tag_defined = @as(c_int, 1);
pub inline fn sigsetjmp(env: anytype, savemask: anytype) @TypeOf(__sigsetjmp(env, savemask)) {
    return __sigsetjmp(env, savemask);
}
pub const STRINGINFO_H = "";
pub const DEBUG5 = @as(c_int, 10);
pub const DEBUG4 = @as(c_int, 11);
pub const DEBUG3 = @as(c_int, 12);
pub const DEBUG2 = @as(c_int, 13);
pub const DEBUG1 = @as(c_int, 14);
pub const LOG = @as(c_int, 15);
pub const LOG_SERVER_ONLY = @as(c_int, 16);
pub const COMMERROR = LOG_SERVER_ONLY;
pub const INFO = @as(c_int, 17);
pub const NOTICE = @as(c_int, 18);
pub const WARNING = @as(c_int, 19);
pub const PGWARNING = @as(c_int, 19);
pub const WARNING_CLIENT_ONLY = @as(c_int, 20);
pub const ERROR = @as(c_int, 21);
pub const PGERROR = @as(c_int, 21);
pub const FATAL = @as(c_int, 22);
pub const PANIC = @as(c_int, 23);
pub inline fn PGSIXBIT(ch: anytype) @TypeOf((ch - '0') & @as(c_int, 0x3F)) {
    return (ch - '0') & @as(c_int, 0x3F);
}
pub inline fn PGUNSIXBIT(val: anytype) @TypeOf((val & @as(c_int, 0x3F)) + '0') {
    return (val & @as(c_int, 0x3F)) + '0';
}
pub inline fn MAKE_SQLSTATE(ch1: anytype, ch2: anytype, ch3: anytype, ch4: anytype, ch5: anytype) @TypeOf((((PGSIXBIT(ch1) + (PGSIXBIT(ch2) << @as(c_int, 6))) + (PGSIXBIT(ch3) << @as(c_int, 12))) + (PGSIXBIT(ch4) << @as(c_int, 18))) + (PGSIXBIT(ch5) << @as(c_int, 24))) {
    return (((PGSIXBIT(ch1) + (PGSIXBIT(ch2) << @as(c_int, 6))) + (PGSIXBIT(ch3) << @as(c_int, 12))) + (PGSIXBIT(ch4) << @as(c_int, 18))) + (PGSIXBIT(ch5) << @as(c_int, 24));
}
pub inline fn ERRCODE_TO_CATEGORY(ec: anytype) @TypeOf(ec & ((@as(c_int, 1) << @as(c_int, 12)) - @as(c_int, 1))) {
    return ec & ((@as(c_int, 1) << @as(c_int, 12)) - @as(c_int, 1));
}
pub inline fn ERRCODE_IS_CATEGORY(ec: anytype) @TypeOf((ec & ~((@as(c_int, 1) << @as(c_int, 12)) - @as(c_int, 1))) == @as(c_int, 0)) {
    return (ec & ~((@as(c_int, 1) << @as(c_int, 12)) - @as(c_int, 1))) == @as(c_int, 0);
}
pub const ERRCODE_SUCCESSFUL_COMPLETION = MAKE_SQLSTATE('0', '0', '0', '0', '0');
pub const ERRCODE_WARNING = MAKE_SQLSTATE('0', '1', '0', '0', '0');
pub const ERRCODE_WARNING_DYNAMIC_RESULT_SETS_RETURNED = MAKE_SQLSTATE('0', '1', '0', '0', 'C');
pub const ERRCODE_WARNING_IMPLICIT_ZERO_BIT_PADDING = MAKE_SQLSTATE('0', '1', '0', '0', '8');
pub const ERRCODE_WARNING_NULL_VALUE_ELIMINATED_IN_SET_FUNCTION = MAKE_SQLSTATE('0', '1', '0', '0', '3');
pub const ERRCODE_WARNING_PRIVILEGE_NOT_GRANTED = MAKE_SQLSTATE('0', '1', '0', '0', '7');
pub const ERRCODE_WARNING_PRIVILEGE_NOT_REVOKED = MAKE_SQLSTATE('0', '1', '0', '0', '6');
pub const ERRCODE_WARNING_STRING_DATA_RIGHT_TRUNCATION = MAKE_SQLSTATE('0', '1', '0', '0', '4');
pub const ERRCODE_WARNING_DEPRECATED_FEATURE = MAKE_SQLSTATE('0', '1', 'P', '0', '1');
pub const ERRCODE_NO_DATA = MAKE_SQLSTATE('0', '2', '0', '0', '0');
pub const ERRCODE_NO_ADDITIONAL_DYNAMIC_RESULT_SETS_RETURNED = MAKE_SQLSTATE('0', '2', '0', '0', '1');
pub const ERRCODE_SQL_STATEMENT_NOT_YET_COMPLETE = MAKE_SQLSTATE('0', '3', '0', '0', '0');
pub const ERRCODE_CONNECTION_EXCEPTION = MAKE_SQLSTATE('0', '8', '0', '0', '0');
pub const ERRCODE_CONNECTION_DOES_NOT_EXIST = MAKE_SQLSTATE('0', '8', '0', '0', '3');
pub const ERRCODE_CONNECTION_FAILURE = MAKE_SQLSTATE('0', '8', '0', '0', '6');
pub const ERRCODE_SQLCLIENT_UNABLE_TO_ESTABLISH_SQLCONNECTION = MAKE_SQLSTATE('0', '8', '0', '0', '1');
pub const ERRCODE_SQLSERVER_REJECTED_ESTABLISHMENT_OF_SQLCONNECTION = MAKE_SQLSTATE('0', '8', '0', '0', '4');
pub const ERRCODE_TRANSACTION_RESOLUTION_UNKNOWN = MAKE_SQLSTATE('0', '8', '0', '0', '7');
pub const ERRCODE_PROTOCOL_VIOLATION = MAKE_SQLSTATE('0', '8', 'P', '0', '1');
pub const ERRCODE_TRIGGERED_ACTION_EXCEPTION = MAKE_SQLSTATE('0', '9', '0', '0', '0');
pub const ERRCODE_FEATURE_NOT_SUPPORTED = MAKE_SQLSTATE('0', 'A', '0', '0', '0');
pub const ERRCODE_INVALID_TRANSACTION_INITIATION = MAKE_SQLSTATE('0', 'B', '0', '0', '0');
pub const ERRCODE_LOCATOR_EXCEPTION = MAKE_SQLSTATE('0', 'F', '0', '0', '0');
pub const ERRCODE_L_E_INVALID_SPECIFICATION = MAKE_SQLSTATE('0', 'F', '0', '0', '1');
pub const ERRCODE_INVALID_GRANTOR = MAKE_SQLSTATE('0', 'L', '0', '0', '0');
pub const ERRCODE_INVALID_GRANT_OPERATION = MAKE_SQLSTATE('0', 'L', 'P', '0', '1');
pub const ERRCODE_INVALID_ROLE_SPECIFICATION = MAKE_SQLSTATE('0', 'P', '0', '0', '0');
pub const ERRCODE_DIAGNOSTICS_EXCEPTION = MAKE_SQLSTATE('0', 'Z', '0', '0', '0');
pub const ERRCODE_STACKED_DIAGNOSTICS_ACCESSED_WITHOUT_ACTIVE_HANDLER = MAKE_SQLSTATE('0', 'Z', '0', '0', '2');
pub const ERRCODE_CASE_NOT_FOUND = MAKE_SQLSTATE('2', '0', '0', '0', '0');
pub const ERRCODE_CARDINALITY_VIOLATION = MAKE_SQLSTATE('2', '1', '0', '0', '0');
pub const ERRCODE_DATA_EXCEPTION = MAKE_SQLSTATE('2', '2', '0', '0', '0');
pub const ERRCODE_ARRAY_ELEMENT_ERROR = MAKE_SQLSTATE('2', '2', '0', '2', 'E');
pub const ERRCODE_ARRAY_SUBSCRIPT_ERROR = MAKE_SQLSTATE('2', '2', '0', '2', 'E');
pub const ERRCODE_CHARACTER_NOT_IN_REPERTOIRE = MAKE_SQLSTATE('2', '2', '0', '2', '1');
pub const ERRCODE_DATETIME_FIELD_OVERFLOW = MAKE_SQLSTATE('2', '2', '0', '0', '8');
pub const ERRCODE_DATETIME_VALUE_OUT_OF_RANGE = MAKE_SQLSTATE('2', '2', '0', '0', '8');
pub const ERRCODE_DIVISION_BY_ZERO = MAKE_SQLSTATE('2', '2', '0', '1', '2');
pub const ERRCODE_ERROR_IN_ASSIGNMENT = MAKE_SQLSTATE('2', '2', '0', '0', '5');
pub const ERRCODE_ESCAPE_CHARACTER_CONFLICT = MAKE_SQLSTATE('2', '2', '0', '0', 'B');
pub const ERRCODE_INDICATOR_OVERFLOW = MAKE_SQLSTATE('2', '2', '0', '2', '2');
pub const ERRCODE_INTERVAL_FIELD_OVERFLOW = MAKE_SQLSTATE('2', '2', '0', '1', '5');
pub const ERRCODE_INVALID_ARGUMENT_FOR_LOG = MAKE_SQLSTATE('2', '2', '0', '1', 'E');
pub const ERRCODE_INVALID_ARGUMENT_FOR_NTILE = MAKE_SQLSTATE('2', '2', '0', '1', '4');
pub const ERRCODE_INVALID_ARGUMENT_FOR_NTH_VALUE = MAKE_SQLSTATE('2', '2', '0', '1', '6');
pub const ERRCODE_INVALID_ARGUMENT_FOR_POWER_FUNCTION = MAKE_SQLSTATE('2', '2', '0', '1', 'F');
pub const ERRCODE_INVALID_ARGUMENT_FOR_WIDTH_BUCKET_FUNCTION = MAKE_SQLSTATE('2', '2', '0', '1', 'G');
pub const ERRCODE_INVALID_CHARACTER_VALUE_FOR_CAST = MAKE_SQLSTATE('2', '2', '0', '1', '8');
pub const ERRCODE_INVALID_DATETIME_FORMAT = MAKE_SQLSTATE('2', '2', '0', '0', '7');
pub const ERRCODE_INVALID_ESCAPE_CHARACTER = MAKE_SQLSTATE('2', '2', '0', '1', '9');
pub const ERRCODE_INVALID_ESCAPE_OCTET = MAKE_SQLSTATE('2', '2', '0', '0', 'D');
pub const ERRCODE_INVALID_ESCAPE_SEQUENCE = MAKE_SQLSTATE('2', '2', '0', '2', '5');
pub const ERRCODE_NONSTANDARD_USE_OF_ESCAPE_CHARACTER = MAKE_SQLSTATE('2', '2', 'P', '0', '6');
pub const ERRCODE_INVALID_INDICATOR_PARAMETER_VALUE = MAKE_SQLSTATE('2', '2', '0', '1', '0');
pub const ERRCODE_INVALID_PARAMETER_VALUE = MAKE_SQLSTATE('2', '2', '0', '2', '3');
pub const ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE = MAKE_SQLSTATE('2', '2', '0', '1', '3');
pub const ERRCODE_INVALID_REGULAR_EXPRESSION = MAKE_SQLSTATE('2', '2', '0', '1', 'B');
pub const ERRCODE_INVALID_ROW_COUNT_IN_LIMIT_CLAUSE = MAKE_SQLSTATE('2', '2', '0', '1', 'W');
pub const ERRCODE_INVALID_ROW_COUNT_IN_RESULT_OFFSET_CLAUSE = MAKE_SQLSTATE('2', '2', '0', '1', 'X');
pub const ERRCODE_INVALID_TABLESAMPLE_ARGUMENT = MAKE_SQLSTATE('2', '2', '0', '2', 'H');
pub const ERRCODE_INVALID_TABLESAMPLE_REPEAT = MAKE_SQLSTATE('2', '2', '0', '2', 'G');
pub const ERRCODE_INVALID_TIME_ZONE_DISPLACEMENT_VALUE = MAKE_SQLSTATE('2', '2', '0', '0', '9');
pub const ERRCODE_INVALID_USE_OF_ESCAPE_CHARACTER = MAKE_SQLSTATE('2', '2', '0', '0', 'C');
pub const ERRCODE_MOST_SPECIFIC_TYPE_MISMATCH = MAKE_SQLSTATE('2', '2', '0', '0', 'G');
pub const ERRCODE_NULL_VALUE_NOT_ALLOWED = MAKE_SQLSTATE('2', '2', '0', '0', '4');
pub const ERRCODE_NULL_VALUE_NO_INDICATOR_PARAMETER = MAKE_SQLSTATE('2', '2', '0', '0', '2');
pub const ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE = MAKE_SQLSTATE('2', '2', '0', '0', '3');
pub const ERRCODE_SEQUENCE_GENERATOR_LIMIT_EXCEEDED = MAKE_SQLSTATE('2', '2', '0', '0', 'H');
pub const ERRCODE_STRING_DATA_LENGTH_MISMATCH = MAKE_SQLSTATE('2', '2', '0', '2', '6');
pub const ERRCODE_STRING_DATA_RIGHT_TRUNCATION = MAKE_SQLSTATE('2', '2', '0', '0', '1');
pub const ERRCODE_SUBSTRING_ERROR = MAKE_SQLSTATE('2', '2', '0', '1', '1');
pub const ERRCODE_TRIM_ERROR = MAKE_SQLSTATE('2', '2', '0', '2', '7');
pub const ERRCODE_UNTERMINATED_C_STRING = MAKE_SQLSTATE('2', '2', '0', '2', '4');
pub const ERRCODE_ZERO_LENGTH_CHARACTER_STRING = MAKE_SQLSTATE('2', '2', '0', '0', 'F');
pub const ERRCODE_FLOATING_POINT_EXCEPTION = MAKE_SQLSTATE('2', '2', 'P', '0', '1');
pub const ERRCODE_INVALID_TEXT_REPRESENTATION = MAKE_SQLSTATE('2', '2', 'P', '0', '2');
pub const ERRCODE_INVALID_BINARY_REPRESENTATION = MAKE_SQLSTATE('2', '2', 'P', '0', '3');
pub const ERRCODE_BAD_COPY_FILE_FORMAT = MAKE_SQLSTATE('2', '2', 'P', '0', '4');
pub const ERRCODE_UNTRANSLATABLE_CHARACTER = MAKE_SQLSTATE('2', '2', 'P', '0', '5');
pub const ERRCODE_NOT_AN_XML_DOCUMENT = MAKE_SQLSTATE('2', '2', '0', '0', 'L');
pub const ERRCODE_INVALID_XML_DOCUMENT = MAKE_SQLSTATE('2', '2', '0', '0', 'M');
pub const ERRCODE_INVALID_XML_CONTENT = MAKE_SQLSTATE('2', '2', '0', '0', 'N');
pub const ERRCODE_INVALID_XML_COMMENT = MAKE_SQLSTATE('2', '2', '0', '0', 'S');
pub const ERRCODE_INVALID_XML_PROCESSING_INSTRUCTION = MAKE_SQLSTATE('2', '2', '0', '0', 'T');
pub const ERRCODE_DUPLICATE_JSON_OBJECT_KEY_VALUE = MAKE_SQLSTATE('2', '2', '0', '3', '0');
pub const ERRCODE_INVALID_ARGUMENT_FOR_SQL_JSON_DATETIME_FUNCTION = MAKE_SQLSTATE('2', '2', '0', '3', '1');
pub const ERRCODE_INVALID_JSON_TEXT = MAKE_SQLSTATE('2', '2', '0', '3', '2');
pub const ERRCODE_INVALID_SQL_JSON_SUBSCRIPT = MAKE_SQLSTATE('2', '2', '0', '3', '3');
pub const ERRCODE_MORE_THAN_ONE_SQL_JSON_ITEM = MAKE_SQLSTATE('2', '2', '0', '3', '4');
pub const ERRCODE_NO_SQL_JSON_ITEM = MAKE_SQLSTATE('2', '2', '0', '3', '5');
pub const ERRCODE_NON_NUMERIC_SQL_JSON_ITEM = MAKE_SQLSTATE('2', '2', '0', '3', '6');
pub const ERRCODE_NON_UNIQUE_KEYS_IN_A_JSON_OBJECT = MAKE_SQLSTATE('2', '2', '0', '3', '7');
pub const ERRCODE_SINGLETON_SQL_JSON_ITEM_REQUIRED = MAKE_SQLSTATE('2', '2', '0', '3', '8');
pub const ERRCODE_SQL_JSON_ARRAY_NOT_FOUND = MAKE_SQLSTATE('2', '2', '0', '3', '9');
pub const ERRCODE_SQL_JSON_MEMBER_NOT_FOUND = MAKE_SQLSTATE('2', '2', '0', '3', 'A');
pub const ERRCODE_SQL_JSON_NUMBER_NOT_FOUND = MAKE_SQLSTATE('2', '2', '0', '3', 'B');
pub const ERRCODE_SQL_JSON_OBJECT_NOT_FOUND = MAKE_SQLSTATE('2', '2', '0', '3', 'C');
pub const ERRCODE_TOO_MANY_JSON_ARRAY_ELEMENTS = MAKE_SQLSTATE('2', '2', '0', '3', 'D');
pub const ERRCODE_TOO_MANY_JSON_OBJECT_MEMBERS = MAKE_SQLSTATE('2', '2', '0', '3', 'E');
pub const ERRCODE_SQL_JSON_SCALAR_REQUIRED = MAKE_SQLSTATE('2', '2', '0', '3', 'F');
pub const ERRCODE_SQL_JSON_ITEM_CANNOT_BE_CAST_TO_TARGET_TYPE = MAKE_SQLSTATE('2', '2', '0', '3', 'G');
pub const ERRCODE_INTEGRITY_CONSTRAINT_VIOLATION = MAKE_SQLSTATE('2', '3', '0', '0', '0');
pub const ERRCODE_RESTRICT_VIOLATION = MAKE_SQLSTATE('2', '3', '0', '0', '1');
pub const ERRCODE_NOT_NULL_VIOLATION = MAKE_SQLSTATE('2', '3', '5', '0', '2');
pub const ERRCODE_FOREIGN_KEY_VIOLATION = MAKE_SQLSTATE('2', '3', '5', '0', '3');
pub const ERRCODE_UNIQUE_VIOLATION = MAKE_SQLSTATE('2', '3', '5', '0', '5');
pub const ERRCODE_CHECK_VIOLATION = MAKE_SQLSTATE('2', '3', '5', '1', '4');
pub const ERRCODE_EXCLUSION_VIOLATION = MAKE_SQLSTATE('2', '3', 'P', '0', '1');
pub const ERRCODE_INVALID_CURSOR_STATE = MAKE_SQLSTATE('2', '4', '0', '0', '0');
pub const ERRCODE_INVALID_TRANSACTION_STATE = MAKE_SQLSTATE('2', '5', '0', '0', '0');
pub const ERRCODE_ACTIVE_SQL_TRANSACTION = MAKE_SQLSTATE('2', '5', '0', '0', '1');
pub const ERRCODE_BRANCH_TRANSACTION_ALREADY_ACTIVE = MAKE_SQLSTATE('2', '5', '0', '0', '2');
pub const ERRCODE_HELD_CURSOR_REQUIRES_SAME_ISOLATION_LEVEL = MAKE_SQLSTATE('2', '5', '0', '0', '8');
pub const ERRCODE_INAPPROPRIATE_ACCESS_MODE_FOR_BRANCH_TRANSACTION = MAKE_SQLSTATE('2', '5', '0', '0', '3');
pub const ERRCODE_INAPPROPRIATE_ISOLATION_LEVEL_FOR_BRANCH_TRANSACTION = MAKE_SQLSTATE('2', '5', '0', '0', '4');
pub const ERRCODE_NO_ACTIVE_SQL_TRANSACTION_FOR_BRANCH_TRANSACTION = MAKE_SQLSTATE('2', '5', '0', '0', '5');
pub const ERRCODE_READ_ONLY_SQL_TRANSACTION = MAKE_SQLSTATE('2', '5', '0', '0', '6');
pub const ERRCODE_SCHEMA_AND_DATA_STATEMENT_MIXING_NOT_SUPPORTED = MAKE_SQLSTATE('2', '5', '0', '0', '7');
pub const ERRCODE_NO_ACTIVE_SQL_TRANSACTION = MAKE_SQLSTATE('2', '5', 'P', '0', '1');
pub const ERRCODE_IN_FAILED_SQL_TRANSACTION = MAKE_SQLSTATE('2', '5', 'P', '0', '2');
pub const ERRCODE_IDLE_IN_TRANSACTION_SESSION_TIMEOUT = MAKE_SQLSTATE('2', '5', 'P', '0', '3');
pub const ERRCODE_INVALID_SQL_STATEMENT_NAME = MAKE_SQLSTATE('2', '6', '0', '0', '0');
pub const ERRCODE_TRIGGERED_DATA_CHANGE_VIOLATION = MAKE_SQLSTATE('2', '7', '0', '0', '0');
pub const ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION = MAKE_SQLSTATE('2', '8', '0', '0', '0');
pub const ERRCODE_INVALID_PASSWORD = MAKE_SQLSTATE('2', '8', 'P', '0', '1');
pub const ERRCODE_DEPENDENT_PRIVILEGE_DESCRIPTORS_STILL_EXIST = MAKE_SQLSTATE('2', 'B', '0', '0', '0');
pub const ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST = MAKE_SQLSTATE('2', 'B', 'P', '0', '1');
pub const ERRCODE_INVALID_TRANSACTION_TERMINATION = MAKE_SQLSTATE('2', 'D', '0', '0', '0');
pub const ERRCODE_SQL_ROUTINE_EXCEPTION = MAKE_SQLSTATE('2', 'F', '0', '0', '0');
pub const ERRCODE_S_R_E_FUNCTION_EXECUTED_NO_RETURN_STATEMENT = MAKE_SQLSTATE('2', 'F', '0', '0', '5');
pub const ERRCODE_S_R_E_MODIFYING_SQL_DATA_NOT_PERMITTED = MAKE_SQLSTATE('2', 'F', '0', '0', '2');
pub const ERRCODE_S_R_E_PROHIBITED_SQL_STATEMENT_ATTEMPTED = MAKE_SQLSTATE('2', 'F', '0', '0', '3');
pub const ERRCODE_S_R_E_READING_SQL_DATA_NOT_PERMITTED = MAKE_SQLSTATE('2', 'F', '0', '0', '4');
pub const ERRCODE_INVALID_CURSOR_NAME = MAKE_SQLSTATE('3', '4', '0', '0', '0');
pub const ERRCODE_EXTERNAL_ROUTINE_EXCEPTION = MAKE_SQLSTATE('3', '8', '0', '0', '0');
pub const ERRCODE_E_R_E_CONTAINING_SQL_NOT_PERMITTED = MAKE_SQLSTATE('3', '8', '0', '0', '1');
pub const ERRCODE_E_R_E_MODIFYING_SQL_DATA_NOT_PERMITTED = MAKE_SQLSTATE('3', '8', '0', '0', '2');
pub const ERRCODE_E_R_E_PROHIBITED_SQL_STATEMENT_ATTEMPTED = MAKE_SQLSTATE('3', '8', '0', '0', '3');
pub const ERRCODE_E_R_E_READING_SQL_DATA_NOT_PERMITTED = MAKE_SQLSTATE('3', '8', '0', '0', '4');
pub const ERRCODE_EXTERNAL_ROUTINE_INVOCATION_EXCEPTION = MAKE_SQLSTATE('3', '9', '0', '0', '0');
pub const ERRCODE_E_R_I_E_INVALID_SQLSTATE_RETURNED = MAKE_SQLSTATE('3', '9', '0', '0', '1');
pub const ERRCODE_E_R_I_E_NULL_VALUE_NOT_ALLOWED = MAKE_SQLSTATE('3', '9', '0', '0', '4');
pub const ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED = MAKE_SQLSTATE('3', '9', 'P', '0', '1');
pub const ERRCODE_E_R_I_E_SRF_PROTOCOL_VIOLATED = MAKE_SQLSTATE('3', '9', 'P', '0', '2');
pub const ERRCODE_E_R_I_E_EVENT_TRIGGER_PROTOCOL_VIOLATED = MAKE_SQLSTATE('3', '9', 'P', '0', '3');
pub const ERRCODE_SAVEPOINT_EXCEPTION = MAKE_SQLSTATE('3', 'B', '0', '0', '0');
pub const ERRCODE_S_E_INVALID_SPECIFICATION = MAKE_SQLSTATE('3', 'B', '0', '0', '1');
pub const ERRCODE_INVALID_CATALOG_NAME = MAKE_SQLSTATE('3', 'D', '0', '0', '0');
pub const ERRCODE_INVALID_SCHEMA_NAME = MAKE_SQLSTATE('3', 'F', '0', '0', '0');
pub const ERRCODE_TRANSACTION_ROLLBACK = MAKE_SQLSTATE('4', '0', '0', '0', '0');
pub const ERRCODE_T_R_INTEGRITY_CONSTRAINT_VIOLATION = MAKE_SQLSTATE('4', '0', '0', '0', '2');
pub const ERRCODE_T_R_SERIALIZATION_FAILURE = MAKE_SQLSTATE('4', '0', '0', '0', '1');
pub const ERRCODE_T_R_STATEMENT_COMPLETION_UNKNOWN = MAKE_SQLSTATE('4', '0', '0', '0', '3');
pub const ERRCODE_T_R_DEADLOCK_DETECTED = MAKE_SQLSTATE('4', '0', 'P', '0', '1');
pub const ERRCODE_SYNTAX_ERROR_OR_ACCESS_RULE_VIOLATION = MAKE_SQLSTATE('4', '2', '0', '0', '0');
pub const ERRCODE_SYNTAX_ERROR = MAKE_SQLSTATE('4', '2', '6', '0', '1');
pub const ERRCODE_INSUFFICIENT_PRIVILEGE = MAKE_SQLSTATE('4', '2', '5', '0', '1');
pub const ERRCODE_CANNOT_COERCE = MAKE_SQLSTATE('4', '2', '8', '4', '6');
pub const ERRCODE_GROUPING_ERROR = MAKE_SQLSTATE('4', '2', '8', '0', '3');
pub const ERRCODE_WINDOWING_ERROR = MAKE_SQLSTATE('4', '2', 'P', '2', '0');
pub const ERRCODE_INVALID_RECURSION = MAKE_SQLSTATE('4', '2', 'P', '1', '9');
pub const ERRCODE_INVALID_FOREIGN_KEY = MAKE_SQLSTATE('4', '2', '8', '3', '0');
pub const ERRCODE_INVALID_NAME = MAKE_SQLSTATE('4', '2', '6', '0', '2');
pub const ERRCODE_NAME_TOO_LONG = MAKE_SQLSTATE('4', '2', '6', '2', '2');
pub const ERRCODE_RESERVED_NAME = MAKE_SQLSTATE('4', '2', '9', '3', '9');
pub const ERRCODE_DATATYPE_MISMATCH = MAKE_SQLSTATE('4', '2', '8', '0', '4');
pub const ERRCODE_INDETERMINATE_DATATYPE = MAKE_SQLSTATE('4', '2', 'P', '1', '8');
pub const ERRCODE_COLLATION_MISMATCH = MAKE_SQLSTATE('4', '2', 'P', '2', '1');
pub const ERRCODE_INDETERMINATE_COLLATION = MAKE_SQLSTATE('4', '2', 'P', '2', '2');
pub const ERRCODE_WRONG_OBJECT_TYPE = MAKE_SQLSTATE('4', '2', '8', '0', '9');
pub const ERRCODE_GENERATED_ALWAYS = MAKE_SQLSTATE('4', '2', '8', 'C', '9');
pub const ERRCODE_UNDEFINED_COLUMN = MAKE_SQLSTATE('4', '2', '7', '0', '3');
pub const ERRCODE_UNDEFINED_CURSOR = MAKE_SQLSTATE('3', '4', '0', '0', '0');
pub const ERRCODE_UNDEFINED_DATABASE = MAKE_SQLSTATE('3', 'D', '0', '0', '0');
pub const ERRCODE_UNDEFINED_FUNCTION = MAKE_SQLSTATE('4', '2', '8', '8', '3');
pub const ERRCODE_UNDEFINED_PSTATEMENT = MAKE_SQLSTATE('2', '6', '0', '0', '0');
pub const ERRCODE_UNDEFINED_SCHEMA = MAKE_SQLSTATE('3', 'F', '0', '0', '0');
pub const ERRCODE_UNDEFINED_TABLE = MAKE_SQLSTATE('4', '2', 'P', '0', '1');
pub const ERRCODE_UNDEFINED_PARAMETER = MAKE_SQLSTATE('4', '2', 'P', '0', '2');
pub const ERRCODE_UNDEFINED_OBJECT = MAKE_SQLSTATE('4', '2', '7', '0', '4');
pub const ERRCODE_DUPLICATE_COLUMN = MAKE_SQLSTATE('4', '2', '7', '0', '1');
pub const ERRCODE_DUPLICATE_CURSOR = MAKE_SQLSTATE('4', '2', 'P', '0', '3');
pub const ERRCODE_DUPLICATE_DATABASE = MAKE_SQLSTATE('4', '2', 'P', '0', '4');
pub const ERRCODE_DUPLICATE_FUNCTION = MAKE_SQLSTATE('4', '2', '7', '2', '3');
pub const ERRCODE_DUPLICATE_PSTATEMENT = MAKE_SQLSTATE('4', '2', 'P', '0', '5');
pub const ERRCODE_DUPLICATE_SCHEMA = MAKE_SQLSTATE('4', '2', 'P', '0', '6');
pub const ERRCODE_DUPLICATE_TABLE = MAKE_SQLSTATE('4', '2', 'P', '0', '7');
pub const ERRCODE_DUPLICATE_ALIAS = MAKE_SQLSTATE('4', '2', '7', '1', '2');
pub const ERRCODE_DUPLICATE_OBJECT = MAKE_SQLSTATE('4', '2', '7', '1', '0');
pub const ERRCODE_AMBIGUOUS_COLUMN = MAKE_SQLSTATE('4', '2', '7', '0', '2');
pub const ERRCODE_AMBIGUOUS_FUNCTION = MAKE_SQLSTATE('4', '2', '7', '2', '5');
pub const ERRCODE_AMBIGUOUS_PARAMETER = MAKE_SQLSTATE('4', '2', 'P', '0', '8');
pub const ERRCODE_AMBIGUOUS_ALIAS = MAKE_SQLSTATE('4', '2', 'P', '0', '9');
pub const ERRCODE_INVALID_COLUMN_REFERENCE = MAKE_SQLSTATE('4', '2', 'P', '1', '0');
pub const ERRCODE_INVALID_COLUMN_DEFINITION = MAKE_SQLSTATE('4', '2', '6', '1', '1');
pub const ERRCODE_INVALID_CURSOR_DEFINITION = MAKE_SQLSTATE('4', '2', 'P', '1', '1');
pub const ERRCODE_INVALID_DATABASE_DEFINITION = MAKE_SQLSTATE('4', '2', 'P', '1', '2');
pub const ERRCODE_INVALID_FUNCTION_DEFINITION = MAKE_SQLSTATE('4', '2', 'P', '1', '3');
pub const ERRCODE_INVALID_PSTATEMENT_DEFINITION = MAKE_SQLSTATE('4', '2', 'P', '1', '4');
pub const ERRCODE_INVALID_SCHEMA_DEFINITION = MAKE_SQLSTATE('4', '2', 'P', '1', '5');
pub const ERRCODE_INVALID_TABLE_DEFINITION = MAKE_SQLSTATE('4', '2', 'P', '1', '6');
pub const ERRCODE_INVALID_OBJECT_DEFINITION = MAKE_SQLSTATE('4', '2', 'P', '1', '7');
pub const ERRCODE_WITH_CHECK_OPTION_VIOLATION = MAKE_SQLSTATE('4', '4', '0', '0', '0');
pub const ERRCODE_INSUFFICIENT_RESOURCES = MAKE_SQLSTATE('5', '3', '0', '0', '0');
pub const ERRCODE_DISK_FULL = MAKE_SQLSTATE('5', '3', '1', '0', '0');
pub const ERRCODE_OUT_OF_MEMORY = MAKE_SQLSTATE('5', '3', '2', '0', '0');
pub const ERRCODE_TOO_MANY_CONNECTIONS = MAKE_SQLSTATE('5', '3', '3', '0', '0');
pub const ERRCODE_CONFIGURATION_LIMIT_EXCEEDED = MAKE_SQLSTATE('5', '3', '4', '0', '0');
pub const ERRCODE_PROGRAM_LIMIT_EXCEEDED = MAKE_SQLSTATE('5', '4', '0', '0', '0');
pub const ERRCODE_STATEMENT_TOO_COMPLEX = MAKE_SQLSTATE('5', '4', '0', '0', '1');
pub const ERRCODE_TOO_MANY_COLUMNS = MAKE_SQLSTATE('5', '4', '0', '1', '1');
pub const ERRCODE_TOO_MANY_ARGUMENTS = MAKE_SQLSTATE('5', '4', '0', '2', '3');
pub const ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE = MAKE_SQLSTATE('5', '5', '0', '0', '0');
pub const ERRCODE_OBJECT_IN_USE = MAKE_SQLSTATE('5', '5', '0', '0', '6');
pub const ERRCODE_CANT_CHANGE_RUNTIME_PARAM = MAKE_SQLSTATE('5', '5', 'P', '0', '2');
pub const ERRCODE_LOCK_NOT_AVAILABLE = MAKE_SQLSTATE('5', '5', 'P', '0', '3');
pub const ERRCODE_UNSAFE_NEW_ENUM_VALUE_USAGE = MAKE_SQLSTATE('5', '5', 'P', '0', '4');
pub const ERRCODE_OPERATOR_INTERVENTION = MAKE_SQLSTATE('5', '7', '0', '0', '0');
pub const ERRCODE_QUERY_CANCELED = MAKE_SQLSTATE('5', '7', '0', '1', '4');
pub const ERRCODE_ADMIN_SHUTDOWN = MAKE_SQLSTATE('5', '7', 'P', '0', '1');
pub const ERRCODE_CRASH_SHUTDOWN = MAKE_SQLSTATE('5', '7', 'P', '0', '2');
pub const ERRCODE_CANNOT_CONNECT_NOW = MAKE_SQLSTATE('5', '7', 'P', '0', '3');
pub const ERRCODE_DATABASE_DROPPED = MAKE_SQLSTATE('5', '7', 'P', '0', '4');
pub const ERRCODE_IDLE_SESSION_TIMEOUT = MAKE_SQLSTATE('5', '7', 'P', '0', '5');
pub const ERRCODE_SYSTEM_ERROR = MAKE_SQLSTATE('5', '8', '0', '0', '0');
pub const ERRCODE_IO_ERROR = MAKE_SQLSTATE('5', '8', '0', '3', '0');
pub const ERRCODE_UNDEFINED_FILE = MAKE_SQLSTATE('5', '8', 'P', '0', '1');
pub const ERRCODE_DUPLICATE_FILE = MAKE_SQLSTATE('5', '8', 'P', '0', '2');
pub const ERRCODE_SNAPSHOT_TOO_OLD = MAKE_SQLSTATE('7', '2', '0', '0', '0');
pub const ERRCODE_CONFIG_FILE_ERROR = MAKE_SQLSTATE('F', '0', '0', '0', '0');
pub const ERRCODE_LOCK_FILE_EXISTS = MAKE_SQLSTATE('F', '0', '0', '0', '1');
pub const ERRCODE_FDW_ERROR = MAKE_SQLSTATE('H', 'V', '0', '0', '0');
pub const ERRCODE_FDW_COLUMN_NAME_NOT_FOUND = MAKE_SQLSTATE('H', 'V', '0', '0', '5');
pub const ERRCODE_FDW_DYNAMIC_PARAMETER_VALUE_NEEDED = MAKE_SQLSTATE('H', 'V', '0', '0', '2');
pub const ERRCODE_FDW_FUNCTION_SEQUENCE_ERROR = MAKE_SQLSTATE('H', 'V', '0', '1', '0');
pub const ERRCODE_FDW_INCONSISTENT_DESCRIPTOR_INFORMATION = MAKE_SQLSTATE('H', 'V', '0', '2', '1');
pub const ERRCODE_FDW_INVALID_ATTRIBUTE_VALUE = MAKE_SQLSTATE('H', 'V', '0', '2', '4');
pub const ERRCODE_FDW_INVALID_COLUMN_NAME = MAKE_SQLSTATE('H', 'V', '0', '0', '7');
pub const ERRCODE_FDW_INVALID_COLUMN_NUMBER = MAKE_SQLSTATE('H', 'V', '0', '0', '8');
pub const ERRCODE_FDW_INVALID_DATA_TYPE = MAKE_SQLSTATE('H', 'V', '0', '0', '4');
pub const ERRCODE_FDW_INVALID_DATA_TYPE_DESCRIPTORS = MAKE_SQLSTATE('H', 'V', '0', '0', '6');
pub const ERRCODE_FDW_INVALID_DESCRIPTOR_FIELD_IDENTIFIER = MAKE_SQLSTATE('H', 'V', '0', '9', '1');
pub const ERRCODE_FDW_INVALID_HANDLE = MAKE_SQLSTATE('H', 'V', '0', '0', 'B');
pub const ERRCODE_FDW_INVALID_OPTION_INDEX = MAKE_SQLSTATE('H', 'V', '0', '0', 'C');
pub const ERRCODE_FDW_INVALID_OPTION_NAME = MAKE_SQLSTATE('H', 'V', '0', '0', 'D');
pub const ERRCODE_FDW_INVALID_STRING_LENGTH_OR_BUFFER_LENGTH = MAKE_SQLSTATE('H', 'V', '0', '9', '0');
pub const ERRCODE_FDW_INVALID_STRING_FORMAT = MAKE_SQLSTATE('H', 'V', '0', '0', 'A');
pub const ERRCODE_FDW_INVALID_USE_OF_NULL_POINTER = MAKE_SQLSTATE('H', 'V', '0', '0', '9');
pub const ERRCODE_FDW_TOO_MANY_HANDLES = MAKE_SQLSTATE('H', 'V', '0', '1', '4');
pub const ERRCODE_FDW_OUT_OF_MEMORY = MAKE_SQLSTATE('H', 'V', '0', '0', '1');
pub const ERRCODE_FDW_NO_SCHEMAS = MAKE_SQLSTATE('H', 'V', '0', '0', 'P');
pub const ERRCODE_FDW_OPTION_NAME_NOT_FOUND = MAKE_SQLSTATE('H', 'V', '0', '0', 'J');
pub const ERRCODE_FDW_REPLY_HANDLE = MAKE_SQLSTATE('H', 'V', '0', '0', 'K');
pub const ERRCODE_FDW_SCHEMA_NOT_FOUND = MAKE_SQLSTATE('H', 'V', '0', '0', 'Q');
pub const ERRCODE_FDW_TABLE_NOT_FOUND = MAKE_SQLSTATE('H', 'V', '0', '0', 'R');
pub const ERRCODE_FDW_UNABLE_TO_CREATE_EXECUTION = MAKE_SQLSTATE('H', 'V', '0', '0', 'L');
pub const ERRCODE_FDW_UNABLE_TO_CREATE_REPLY = MAKE_SQLSTATE('H', 'V', '0', '0', 'M');
pub const ERRCODE_FDW_UNABLE_TO_ESTABLISH_CONNECTION = MAKE_SQLSTATE('H', 'V', '0', '0', 'N');
pub const ERRCODE_PLPGSQL_ERROR = MAKE_SQLSTATE('P', '0', '0', '0', '0');
pub const ERRCODE_RAISE_EXCEPTION = MAKE_SQLSTATE('P', '0', '0', '0', '1');
pub const ERRCODE_NO_DATA_FOUND = MAKE_SQLSTATE('P', '0', '0', '0', '2');
pub const ERRCODE_TOO_MANY_ROWS = MAKE_SQLSTATE('P', '0', '0', '0', '3');
pub const ERRCODE_ASSERT_FAILURE = MAKE_SQLSTATE('P', '0', '0', '0', '4');
pub const ERRCODE_INTERNAL_ERROR = MAKE_SQLSTATE('X', 'X', '0', '0', '0');
pub const ERRCODE_DATA_CORRUPTED = MAKE_SQLSTATE('X', 'X', '0', '0', '1');
pub const ERRCODE_INDEX_CORRUPTED = MAKE_SQLSTATE('X', 'X', '0', '0', '2');
pub inline fn pg_prevent_errno_in_scope() @TypeOf((c_int ++ __errno_location ++ pg_attribute_unused)()) {
    return (c_int ++ __errno_location ++ pg_attribute_unused)();
}
pub const TEXTDOMAIN = NULL;
pub const errcontext = blk: {
    _ = set_errcontext_domain(TEXTDOMAIN);
    break :blk errcontext_msg;
};
pub inline fn PG_RE_THROW() @TypeOf(pg_re_throw()) {
    return pg_re_throw();
}
pub const LOG_DESTINATION_STDERR = @as(c_int, 1);
pub const LOG_DESTINATION_SYSLOG = @as(c_int, 2);
pub const LOG_DESTINATION_EVENTLOG = @as(c_int, 4);
pub const LOG_DESTINATION_CSVLOG = @as(c_int, 8);
pub const LOG_DESTINATION_JSONLOG = @as(c_int, 16);
pub const PALLOC_H = "";
pub const MCXT_ALLOC_HUGE = @as(c_int, 0x01);
pub const MCXT_ALLOC_NO_OOM = @as(c_int, 0x02);
pub const MCXT_ALLOC_ZERO = @as(c_int, 0x04);
pub inline fn palloc0fast(sz: anytype) @TypeOf(if (MemSetTest(@as(c_int, 0), sz)) MemoryContextAllocZeroAligned(CurrentMemoryContext, sz) else MemoryContextAllocZero(CurrentMemoryContext, sz)) {
    return if (MemSetTest(@as(c_int, 0), sz)) MemoryContextAllocZeroAligned(CurrentMemoryContext, sz) else MemoryContextAllocZero(CurrentMemoryContext, sz);
}
pub const FIELDNO_NULLABLE_DATUM_DATUM = @as(c_int, 0);
pub const FIELDNO_NULLABLE_DATUM_ISNULL = @as(c_int, 1);
pub const SIZEOF_DATUM = SIZEOF_VOID_P;
pub inline fn Int64GetDatumFast(X: anytype) @TypeOf(Int64GetDatum(X)) {
    return blk_1: {
        _ = AssertVariableIsOfTypeMacro(X, int64);
        break :blk_1 Int64GetDatum(X);
    };
}
pub inline fn Float8GetDatumFast(X: anytype) @TypeOf(Float8GetDatum(X)) {
    return blk_1: {
        _ = AssertVariableIsOfTypeMacro(X, f64);
        break :blk_1 Float8GetDatum(X);
    };
}
pub const PG_TYPE_H = "";
pub const GENBKI_H = "";
pub const BKI_BOOTSTRAP = "";
pub const BKI_SHARED_RELATION = "";
pub const BKI_SCHEMA_MACRO = "";
pub const BKI_FORCE_NULL = "";
pub const BKI_FORCE_NOT_NULL = "";
pub const OBJECTADDRESS_H = "";
pub const HTUP_H = "";
pub const ITEMPTR_H = "";
pub const BLOCK_H = "";
pub const InvalidBlockNumber = @import("std").zig.c_translation.cast(BlockNumber, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hexadecimal));
pub const MaxBlockNumber = @import("std").zig.c_translation.cast(BlockNumber, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFE, .hexadecimal));
pub const OFF_H = "";
pub const ITEMID_H = "";
pub const LP_UNUSED = @as(c_int, 0);
pub const LP_NORMAL = @as(c_int, 1);
pub const LP_REDIRECT = @as(c_int, 2);
pub const LP_DEAD = @as(c_int, 3);
pub inline fn ItemIdGetLength(itemId: anytype) @TypeOf(itemId.*.lp_len) {
    return itemId.*.lp_len;
}
pub inline fn ItemIdGetOffset(itemId: anytype) @TypeOf(itemId.*.lp_off) {
    return itemId.*.lp_off;
}
pub inline fn ItemIdGetFlags(itemId: anytype) @TypeOf(itemId.*.lp_flags) {
    return itemId.*.lp_flags;
}
pub inline fn ItemIdGetRedirect(itemId: anytype) @TypeOf(itemId.*.lp_off) {
    return itemId.*.lp_off;
}
pub inline fn ItemIdIsValid(itemId: anytype) @TypeOf(PointerIsValid(itemId)) {
    return PointerIsValid(itemId);
}
pub inline fn ItemIdIsUsed(itemId: anytype) @TypeOf(itemId.*.lp_flags != LP_UNUSED) {
    return itemId.*.lp_flags != LP_UNUSED;
}
pub inline fn ItemIdIsNormal(itemId: anytype) @TypeOf(itemId.*.lp_flags == LP_NORMAL) {
    return itemId.*.lp_flags == LP_NORMAL;
}
pub inline fn ItemIdIsRedirected(itemId: anytype) @TypeOf(itemId.*.lp_flags == LP_REDIRECT) {
    return itemId.*.lp_flags == LP_REDIRECT;
}
pub inline fn ItemIdIsDead(itemId: anytype) @TypeOf(itemId.*.lp_flags == LP_DEAD) {
    return itemId.*.lp_flags == LP_DEAD;
}
pub inline fn ItemIdHasStorage(itemId: anytype) @TypeOf(itemId.*.lp_len != @as(c_int, 0)) {
    return itemId.*.lp_len != @as(c_int, 0);
}
pub const InvalidOffsetNumber = @import("std").zig.c_translation.cast(OffsetNumber, @as(c_int, 0));
pub const FirstOffsetNumber = @import("std").zig.c_translation.cast(OffsetNumber, @as(c_int, 1));
pub const MaxOffsetNumber = @import("std").zig.c_translation.cast(OffsetNumber, @import("std").zig.c_translation.MacroArithmetic.div(BLCKSZ, @import("std").zig.c_translation.sizeof(ItemIdData)));
pub inline fn OffsetNumberIsValid(offsetNumber: anytype) @TypeOf(@"bool"((offsetNumber != InvalidOffsetNumber) and (offsetNumber <= MaxOffsetNumber))) {
    return @"bool"((offsetNumber != InvalidOffsetNumber) and (offsetNumber <= MaxOffsetNumber));
}
pub inline fn OffsetNumberNext(offsetNumber: anytype) OffsetNumber {
    return @import("std").zig.c_translation.cast(OffsetNumber, @as(c_int, 1) + offsetNumber);
}
pub inline fn OffsetNumberPrev(offsetNumber: anytype) OffsetNumber {
    return @import("std").zig.c_translation.cast(OffsetNumber, -@as(c_int, 1) + offsetNumber);
}
pub const SpecTokenOffsetNumber = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfffe, .hexadecimal);
pub const MovedPartitionsOffsetNumber = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xfffd, .hexadecimal);
pub const MovedPartitionsBlockNumber = InvalidBlockNumber;
pub inline fn PG_GETARG_ITEMPOINTER(n: anytype) @TypeOf(DatumGetItemPointer(PG_GETARG_DATUM(n))) {
    return DatumGetItemPointer(PG_GETARG_DATUM(n));
}
pub const FIELDNO_HEAPTUPLEDATA_DATA = @as(c_int, 3);
pub const HEAPTUPLESIZE = MAXALIGN(@import("std").zig.c_translation.sizeof(HeapTupleData));
pub inline fn HeapTupleIsValid(tuple: anytype) @TypeOf(PointerIsValid(tuple)) {
    return PointerIsValid(tuple);
}
pub const PARSENODES_H = "";
pub const RELPATH_H = "";
pub const CATVERSION_H = "";
pub const CATALOG_VERSION_NO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 202306141, .decimal);
pub const InvalidRelFileNumber = @import("std").zig.c_translation.cast(RelFileNumber, InvalidOid);
pub inline fn RelFileNumberIsValid(relnumber: anytype) @TypeOf(@"bool"(relnumber != InvalidRelFileNumber)) {
    return @"bool"(relnumber != InvalidRelFileNumber);
}
pub const TABLESPACE_VERSION_DIRECTORY = ("PG_" ++ PG_MAJORVERSION ++ "_" ++ CppAsString2)(CATALOG_VERSION_NO);
pub const OIDCHARS = @as(c_int, 10);
pub const MAX_FORKNUM = INIT_FORKNUM;
pub const FORKNAMECHARS = @as(c_int, 4);
pub inline fn relpathbackend(rlocator: anytype, backend: anytype, forknum: anytype) @TypeOf(GetRelationPath(rlocator.dbOid, rlocator.spcOid, rlocator.relNumber, backend, forknum)) {
    return GetRelationPath(rlocator.dbOid, rlocator.spcOid, rlocator.relNumber, backend, forknum);
}
pub inline fn relpathperm(rlocator: anytype, forknum: anytype) @TypeOf(relpathbackend(rlocator, InvalidBackendId, forknum)) {
    return relpathbackend(rlocator, InvalidBackendId, forknum);
}
pub inline fn relpath(rlocator: anytype, forknum: anytype) @TypeOf(relpathbackend(rlocator.locator, rlocator.backend, forknum)) {
    return relpathbackend(rlocator.locator, rlocator.backend, forknum);
}
pub const BITMAPSET_H = "";
pub const NODES_H = "";
pub inline fn IS_OUTER_JOIN(jointype: anytype) @TypeOf(((@as(c_int, 1) << jointype) & (((((@as(c_int, 1) << JOIN_LEFT) | (@as(c_int, 1) << JOIN_FULL)) | (@as(c_int, 1) << JOIN_RIGHT)) | (@as(c_int, 1) << JOIN_ANTI)) | (@as(c_int, 1) << JOIN_RIGHT_ANTI))) != @as(c_int, 0)) {
    return ((@as(c_int, 1) << jointype) & (((((@as(c_int, 1) << JOIN_LEFT) | (@as(c_int, 1) << JOIN_FULL)) | (@as(c_int, 1) << JOIN_RIGHT)) | (@as(c_int, 1) << JOIN_ANTI)) | (@as(c_int, 1) << JOIN_RIGHT_ANTI))) != @as(c_int, 0);
}
pub const AGGSPLITOP_COMBINE = @as(c_int, 0x01);
pub const AGGSPLITOP_SKIPFINAL = @as(c_int, 0x02);
pub const AGGSPLITOP_SERIALIZE = @as(c_int, 0x04);
pub const AGGSPLITOP_DESERIALIZE = @as(c_int, 0x08);
pub inline fn DO_AGGSPLIT_COMBINE(as: anytype) @TypeOf((as & AGGSPLITOP_COMBINE) != @as(c_int, 0)) {
    return (as & AGGSPLITOP_COMBINE) != @as(c_int, 0);
}
pub inline fn DO_AGGSPLIT_SKIPFINAL(as: anytype) @TypeOf((as & AGGSPLITOP_SKIPFINAL) != @as(c_int, 0)) {
    return (as & AGGSPLITOP_SKIPFINAL) != @as(c_int, 0);
}
pub inline fn DO_AGGSPLIT_SERIALIZE(as: anytype) @TypeOf((as & AGGSPLITOP_SERIALIZE) != @as(c_int, 0)) {
    return (as & AGGSPLITOP_SERIALIZE) != @as(c_int, 0);
}
pub inline fn DO_AGGSPLIT_DESERIALIZE(as: anytype) @TypeOf((as & AGGSPLITOP_DESERIALIZE) != @as(c_int, 0)) {
    return (as & AGGSPLITOP_DESERIALIZE) != @as(c_int, 0);
}
pub const BITS_PER_BITMAPWORD = @as(c_int, 64);
pub inline fn bms_is_empty(a: anytype) @TypeOf(a == NULL) {
    return a == NULL;
}
pub const LOCKOPTIONS_H = "";
pub const PRIMNODES_H = "";
pub const ATTNUM_H = "";
pub const InvalidAttrNumber = @as(c_int, 0);
pub const MaxAttrNumber = @as(c_int, 32767);
pub inline fn AttributeNumberIsValid(attributeNumber: anytype) @TypeOf(@"bool"(attributeNumber != InvalidAttrNumber)) {
    return @"bool"(attributeNumber != InvalidAttrNumber);
}
pub inline fn AttrNumberIsForUserDefinedAttr(attributeNumber: anytype) @TypeOf(@"bool"(attributeNumber > @as(c_int, 0))) {
    return @"bool"(attributeNumber > @as(c_int, 0));
}
pub inline fn AttrNumberGetAttrOffset(attNum: anytype) @TypeOf(attNum - @as(c_int, 1)) {
    return blk_1: {
        _ = AssertMacro(AttrNumberIsForUserDefinedAttr(attNum));
        break :blk_1 attNum - @as(c_int, 1);
    };
}
pub inline fn AttrOffsetGetAttrNumber(attributeOffset: anytype) AttrNumber {
    return @import("std").zig.c_translation.cast(AttrNumber, @as(c_int, 1) + attributeOffset);
}
pub const PG_LIST_H = "";
pub const NIL = @import("std").zig.c_translation.cast([*c]List, NULL);
pub inline fn lfirst(lc: anytype) @TypeOf(lc.*.ptr_value) {
    return lc.*.ptr_value;
}
pub inline fn lfirst_int(lc: anytype) @TypeOf(lc.*.int_value) {
    return lc.*.int_value;
}
pub inline fn lfirst_oid(lc: anytype) @TypeOf(lc.*.oid_value) {
    return lc.*.oid_value;
}
pub inline fn lfirst_xid(lc: anytype) @TypeOf(lc.*.xid_value) {
    return lc.*.xid_value;
}
pub inline fn lfirst_node(@"type": anytype, lc: anytype) @TypeOf(castNode(@"type", lfirst(lc))) {
    return castNode(@"type", lfirst(lc));
}
pub inline fn linitial(l: anytype) @TypeOf(lfirst(list_nth_cell(l, @as(c_int, 0)))) {
    return lfirst(list_nth_cell(l, @as(c_int, 0)));
}
pub inline fn linitial_int(l: anytype) @TypeOf(lfirst_int(list_nth_cell(l, @as(c_int, 0)))) {
    return lfirst_int(list_nth_cell(l, @as(c_int, 0)));
}
pub inline fn linitial_oid(l: anytype) @TypeOf(lfirst_oid(list_nth_cell(l, @as(c_int, 0)))) {
    return lfirst_oid(list_nth_cell(l, @as(c_int, 0)));
}
pub inline fn linitial_node(@"type": anytype, l: anytype) @TypeOf(castNode(@"type", linitial(l))) {
    return castNode(@"type", linitial(l));
}
pub inline fn lsecond(l: anytype) @TypeOf(lfirst(list_nth_cell(l, @as(c_int, 1)))) {
    return lfirst(list_nth_cell(l, @as(c_int, 1)));
}
pub inline fn lsecond_int(l: anytype) @TypeOf(lfirst_int(list_nth_cell(l, @as(c_int, 1)))) {
    return lfirst_int(list_nth_cell(l, @as(c_int, 1)));
}
pub inline fn lsecond_oid(l: anytype) @TypeOf(lfirst_oid(list_nth_cell(l, @as(c_int, 1)))) {
    return lfirst_oid(list_nth_cell(l, @as(c_int, 1)));
}
pub inline fn lsecond_node(@"type": anytype, l: anytype) @TypeOf(castNode(@"type", lsecond(l))) {
    return castNode(@"type", lsecond(l));
}
pub inline fn lthird(l: anytype) @TypeOf(lfirst(list_nth_cell(l, @as(c_int, 2)))) {
    return lfirst(list_nth_cell(l, @as(c_int, 2)));
}
pub inline fn lthird_int(l: anytype) @TypeOf(lfirst_int(list_nth_cell(l, @as(c_int, 2)))) {
    return lfirst_int(list_nth_cell(l, @as(c_int, 2)));
}
pub inline fn lthird_oid(l: anytype) @TypeOf(lfirst_oid(list_nth_cell(l, @as(c_int, 2)))) {
    return lfirst_oid(list_nth_cell(l, @as(c_int, 2)));
}
pub inline fn lthird_node(@"type": anytype, l: anytype) @TypeOf(castNode(@"type", lthird(l))) {
    return castNode(@"type", lthird(l));
}
pub inline fn lfourth(l: anytype) @TypeOf(lfirst(list_nth_cell(l, @as(c_int, 3)))) {
    return lfirst(list_nth_cell(l, @as(c_int, 3)));
}
pub inline fn lfourth_int(l: anytype) @TypeOf(lfirst_int(list_nth_cell(l, @as(c_int, 3)))) {
    return lfirst_int(list_nth_cell(l, @as(c_int, 3)));
}
pub inline fn lfourth_oid(l: anytype) @TypeOf(lfirst_oid(list_nth_cell(l, @as(c_int, 3)))) {
    return lfirst_oid(list_nth_cell(l, @as(c_int, 3)));
}
pub inline fn lfourth_node(@"type": anytype, l: anytype) @TypeOf(castNode(@"type", lfourth(l))) {
    return castNode(@"type", lfourth(l));
}
pub inline fn llast(l: anytype) @TypeOf(lfirst(list_last_cell(l))) {
    return lfirst(list_last_cell(l));
}
pub inline fn llast_int(l: anytype) @TypeOf(lfirst_int(list_last_cell(l))) {
    return lfirst_int(list_last_cell(l));
}
pub inline fn llast_oid(l: anytype) @TypeOf(lfirst_oid(list_last_cell(l))) {
    return lfirst_oid(list_last_cell(l));
}
pub inline fn llast_xid(l: anytype) @TypeOf(lfirst_xid(list_last_cell(l))) {
    return lfirst_xid(list_last_cell(l));
}
pub inline fn llast_node(@"type": anytype, l: anytype) @TypeOf(castNode(@"type", llast(l))) {
    return castNode(@"type", llast(l));
}
pub inline fn list_make_ptr_cell(v: anytype) ListCell {
    return @import("std").mem.zeroInit(ListCell, .{
        .ptr_value = v,
    });
}
pub inline fn list_make_int_cell(v: anytype) ListCell {
    return @import("std").mem.zeroInit(ListCell, .{
        .int_value = v,
    });
}
pub inline fn list_make_oid_cell(v: anytype) ListCell {
    return @import("std").mem.zeroInit(ListCell, .{
        .oid_value = v,
    });
}
pub inline fn list_make_xid_cell(v: anytype) ListCell {
    return @import("std").mem.zeroInit(ListCell, .{
        .xid_value = v,
    });
}
pub inline fn list_make1(x1: anytype) @TypeOf(list_make1_impl(T_List, list_make_ptr_cell(x1))) {
    return list_make1_impl(T_List, list_make_ptr_cell(x1));
}
pub inline fn list_make2(x1: anytype, x2: anytype) @TypeOf(list_make2_impl(T_List, list_make_ptr_cell(x1), list_make_ptr_cell(x2))) {
    return list_make2_impl(T_List, list_make_ptr_cell(x1), list_make_ptr_cell(x2));
}
pub inline fn list_make3(x1: anytype, x2: anytype, x3: anytype) @TypeOf(list_make3_impl(T_List, list_make_ptr_cell(x1), list_make_ptr_cell(x2), list_make_ptr_cell(x3))) {
    return list_make3_impl(T_List, list_make_ptr_cell(x1), list_make_ptr_cell(x2), list_make_ptr_cell(x3));
}
pub inline fn list_make4(x1: anytype, x2: anytype, x3: anytype, x4: anytype) @TypeOf(list_make4_impl(T_List, list_make_ptr_cell(x1), list_make_ptr_cell(x2), list_make_ptr_cell(x3), list_make_ptr_cell(x4))) {
    return list_make4_impl(T_List, list_make_ptr_cell(x1), list_make_ptr_cell(x2), list_make_ptr_cell(x3), list_make_ptr_cell(x4));
}
pub inline fn list_make5(x1: anytype, x2: anytype, x3: anytype, x4: anytype, x5: anytype) @TypeOf(list_make5_impl(T_List, list_make_ptr_cell(x1), list_make_ptr_cell(x2), list_make_ptr_cell(x3), list_make_ptr_cell(x4), list_make_ptr_cell(x5))) {
    return list_make5_impl(T_List, list_make_ptr_cell(x1), list_make_ptr_cell(x2), list_make_ptr_cell(x3), list_make_ptr_cell(x4), list_make_ptr_cell(x5));
}
pub inline fn list_make1_int(x1: anytype) @TypeOf(list_make1_impl(T_IntList, list_make_int_cell(x1))) {
    return list_make1_impl(T_IntList, list_make_int_cell(x1));
}
pub inline fn list_make2_int(x1: anytype, x2: anytype) @TypeOf(list_make2_impl(T_IntList, list_make_int_cell(x1), list_make_int_cell(x2))) {
    return list_make2_impl(T_IntList, list_make_int_cell(x1), list_make_int_cell(x2));
}
pub inline fn list_make3_int(x1: anytype, x2: anytype, x3: anytype) @TypeOf(list_make3_impl(T_IntList, list_make_int_cell(x1), list_make_int_cell(x2), list_make_int_cell(x3))) {
    return list_make3_impl(T_IntList, list_make_int_cell(x1), list_make_int_cell(x2), list_make_int_cell(x3));
}
pub inline fn list_make4_int(x1: anytype, x2: anytype, x3: anytype, x4: anytype) @TypeOf(list_make4_impl(T_IntList, list_make_int_cell(x1), list_make_int_cell(x2), list_make_int_cell(x3), list_make_int_cell(x4))) {
    return list_make4_impl(T_IntList, list_make_int_cell(x1), list_make_int_cell(x2), list_make_int_cell(x3), list_make_int_cell(x4));
}
pub inline fn list_make5_int(x1: anytype, x2: anytype, x3: anytype, x4: anytype, x5: anytype) @TypeOf(list_make5_impl(T_IntList, list_make_int_cell(x1), list_make_int_cell(x2), list_make_int_cell(x3), list_make_int_cell(x4), list_make_int_cell(x5))) {
    return list_make5_impl(T_IntList, list_make_int_cell(x1), list_make_int_cell(x2), list_make_int_cell(x3), list_make_int_cell(x4), list_make_int_cell(x5));
}
pub inline fn list_make1_oid(x1: anytype) @TypeOf(list_make1_impl(T_OidList, list_make_oid_cell(x1))) {
    return list_make1_impl(T_OidList, list_make_oid_cell(x1));
}
pub inline fn list_make2_oid(x1: anytype, x2: anytype) @TypeOf(list_make2_impl(T_OidList, list_make_oid_cell(x1), list_make_oid_cell(x2))) {
    return list_make2_impl(T_OidList, list_make_oid_cell(x1), list_make_oid_cell(x2));
}
pub inline fn list_make3_oid(x1: anytype, x2: anytype, x3: anytype) @TypeOf(list_make3_impl(T_OidList, list_make_oid_cell(x1), list_make_oid_cell(x2), list_make_oid_cell(x3))) {
    return list_make3_impl(T_OidList, list_make_oid_cell(x1), list_make_oid_cell(x2), list_make_oid_cell(x3));
}
pub inline fn list_make4_oid(x1: anytype, x2: anytype, x3: anytype, x4: anytype) @TypeOf(list_make4_impl(T_OidList, list_make_oid_cell(x1), list_make_oid_cell(x2), list_make_oid_cell(x3), list_make_oid_cell(x4))) {
    return list_make4_impl(T_OidList, list_make_oid_cell(x1), list_make_oid_cell(x2), list_make_oid_cell(x3), list_make_oid_cell(x4));
}
pub inline fn list_make5_oid(x1: anytype, x2: anytype, x3: anytype, x4: anytype, x5: anytype) @TypeOf(list_make5_impl(T_OidList, list_make_oid_cell(x1), list_make_oid_cell(x2), list_make_oid_cell(x3), list_make_oid_cell(x4), list_make_oid_cell(x5))) {
    return list_make5_impl(T_OidList, list_make_oid_cell(x1), list_make_oid_cell(x2), list_make_oid_cell(x3), list_make_oid_cell(x4), list_make_oid_cell(x5));
}
pub inline fn list_make1_xid(x1: anytype) @TypeOf(list_make1_impl(T_XidList, list_make_xid_cell(x1))) {
    return list_make1_impl(T_XidList, list_make_xid_cell(x1));
}
pub inline fn list_make2_xid(x1: anytype, x2: anytype) @TypeOf(list_make2_impl(T_XidList, list_make_xid_cell(x1), list_make_xid_cell(x2))) {
    return list_make2_impl(T_XidList, list_make_xid_cell(x1), list_make_xid_cell(x2));
}
pub inline fn list_make3_xid(x1: anytype, x2: anytype, x3: anytype) @TypeOf(list_make3_impl(T_XidList, list_make_xid_cell(x1), list_make_xid_cell(x2), list_make_xid_cell(x3))) {
    return list_make3_impl(T_XidList, list_make_xid_cell(x1), list_make_xid_cell(x2), list_make_xid_cell(x3));
}
pub inline fn list_make4_xid(x1: anytype, x2: anytype, x3: anytype, x4: anytype) @TypeOf(list_make4_impl(T_XidList, list_make_xid_cell(x1), list_make_xid_cell(x2), list_make_xid_cell(x3), list_make_xid_cell(x4))) {
    return list_make4_impl(T_XidList, list_make_xid_cell(x1), list_make_xid_cell(x2), list_make_xid_cell(x3), list_make_xid_cell(x4));
}
pub inline fn list_make5_xid(x1: anytype, x2: anytype, x3: anytype, x4: anytype, x5: anytype) @TypeOf(list_make5_impl(T_XidList, list_make_xid_cell(x1), list_make_xid_cell(x2), list_make_xid_cell(x3), list_make_xid_cell(x4), list_make_xid_cell(x5))) {
    return list_make5_impl(T_XidList, list_make_xid_cell(x1), list_make_xid_cell(x2), list_make_xid_cell(x3), list_make_xid_cell(x4), list_make_xid_cell(x5));
}
pub inline fn list_nth_node(@"type": anytype, list: anytype, n: anytype) @TypeOf(castNode(@"type", list_nth(list, n))) {
    return castNode(@"type", list_nth(list, n));
}
pub const INNER_VAR = -@as(c_int, 1);
pub const OUTER_VAR = -@as(c_int, 2);
pub const INDEX_VAR = -@as(c_int, 3);
pub const ROWID_VAR = -@as(c_int, 4);
pub inline fn IS_SPECIAL_VARNO(varno: anytype) @TypeOf(@import("std").zig.c_translation.cast(c_int, varno) < @as(c_int, 0)) {
    return @import("std").zig.c_translation.cast(c_int, varno) < @as(c_int, 0);
}
pub const PRS2_OLD_VARNO = @as(c_int, 1);
pub const PRS2_NEW_VARNO = @as(c_int, 2);
pub const VALUE_H = "";
pub inline fn intVal(v: anytype) @TypeOf(castNode(Integer, v).*.ival) {
    return castNode(Integer, v).*.ival;
}
pub inline fn floatVal(v: anytype) @TypeOf(atof(castNode(Float, v).*.fval)) {
    return atof(castNode(Float, v).*.fval);
}
pub inline fn boolVal(v: anytype) @TypeOf(castNode(Boolean, v).*.boolval) {
    return castNode(Boolean, v).*.boolval;
}
pub inline fn strVal(v: anytype) @TypeOf(castNode(String, v).*.sval) {
    return castNode(String, v).*.sval;
}
pub const PARTDEFS_H = "";
pub const ACL_INSERT = @as(c_int, 1) << @as(c_int, 0);
pub const ACL_SELECT = @as(c_int, 1) << @as(c_int, 1);
pub const ACL_UPDATE = @as(c_int, 1) << @as(c_int, 2);
pub const ACL_DELETE = @as(c_int, 1) << @as(c_int, 3);
pub const ACL_TRUNCATE = @as(c_int, 1) << @as(c_int, 4);
pub const ACL_REFERENCES = @as(c_int, 1) << @as(c_int, 5);
pub const ACL_TRIGGER = @as(c_int, 1) << @as(c_int, 6);
pub const ACL_EXECUTE = @as(c_int, 1) << @as(c_int, 7);
pub const ACL_USAGE = @as(c_int, 1) << @as(c_int, 8);
pub const ACL_CREATE = @as(c_int, 1) << @as(c_int, 9);
pub const ACL_CREATE_TEMP = @as(c_int, 1) << @as(c_int, 10);
pub const ACL_CONNECT = @as(c_int, 1) << @as(c_int, 11);
pub const ACL_SET = @as(c_int, 1) << @as(c_int, 12);
pub const ACL_ALTER_SYSTEM = @as(c_int, 1) << @as(c_int, 13);
pub const ACL_MAINTAIN = @as(c_int, 1) << @as(c_int, 14);
pub const N_ACL_RIGHTS = @as(c_int, 15);
pub const ACL_NO_RIGHTS = @as(c_int, 0);
pub const ACL_SELECT_FOR_UPDATE = ACL_UPDATE;
pub const FRAMEOPTION_NONDEFAULT = @as(c_int, 0x00001);
pub const FRAMEOPTION_RANGE = @as(c_int, 0x00002);
pub const FRAMEOPTION_ROWS = @as(c_int, 0x00004);
pub const FRAMEOPTION_GROUPS = @as(c_int, 0x00008);
pub const FRAMEOPTION_BETWEEN = @as(c_int, 0x00010);
pub const FRAMEOPTION_START_UNBOUNDED_PRECEDING = @as(c_int, 0x00020);
pub const FRAMEOPTION_END_UNBOUNDED_PRECEDING = @as(c_int, 0x00040);
pub const FRAMEOPTION_START_UNBOUNDED_FOLLOWING = @as(c_int, 0x00080);
pub const FRAMEOPTION_END_UNBOUNDED_FOLLOWING = @as(c_int, 0x00100);
pub const FRAMEOPTION_START_CURRENT_ROW = @as(c_int, 0x00200);
pub const FRAMEOPTION_END_CURRENT_ROW = @as(c_int, 0x00400);
pub const FRAMEOPTION_START_OFFSET_PRECEDING = @as(c_int, 0x00800);
pub const FRAMEOPTION_END_OFFSET_PRECEDING = @as(c_int, 0x01000);
pub const FRAMEOPTION_START_OFFSET_FOLLOWING = @as(c_int, 0x02000);
pub const FRAMEOPTION_END_OFFSET_FOLLOWING = @as(c_int, 0x04000);
pub const FRAMEOPTION_EXCLUDE_CURRENT_ROW = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000, .hexadecimal);
pub const FRAMEOPTION_EXCLUDE_GROUP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hexadecimal);
pub const FRAMEOPTION_EXCLUDE_TIES = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000, .hexadecimal);
pub const FRAMEOPTION_START_OFFSET = FRAMEOPTION_START_OFFSET_PRECEDING | FRAMEOPTION_START_OFFSET_FOLLOWING;
pub const FRAMEOPTION_END_OFFSET = FRAMEOPTION_END_OFFSET_PRECEDING | FRAMEOPTION_END_OFFSET_FOLLOWING;
pub const FRAMEOPTION_EXCLUSION = (FRAMEOPTION_EXCLUDE_CURRENT_ROW | FRAMEOPTION_EXCLUDE_GROUP) | FRAMEOPTION_EXCLUDE_TIES;
pub const FRAMEOPTION_DEFAULTS = (FRAMEOPTION_RANGE | FRAMEOPTION_START_UNBOUNDED_PRECEDING) | FRAMEOPTION_END_CURRENT_ROW;
pub inline fn GetCTETargetList(cte: anytype) @TypeOf(if (@import("std").zig.c_translation.cast([*c]Query, cte.*.ctequery).*.commandType == CMD_SELECT) @import("std").zig.c_translation.cast([*c]Query, cte.*.ctequery).*.targetList else @import("std").zig.c_translation.cast([*c]Query, cte.*.ctequery).*.returningList) {
    return blk_1: {
        _ = AssertMacro(IsA(cte.*.ctequery, Query));
        break :blk_1 if (@import("std").zig.c_translation.cast([*c]Query, cte.*.ctequery).*.commandType == CMD_SELECT) @import("std").zig.c_translation.cast([*c]Query, cte.*.ctequery).*.targetList else @import("std").zig.c_translation.cast([*c]Query, cte.*.ctequery).*.returningList;
    };
}
pub const FKCONSTR_ACTION_NOACTION = 'a';
pub const FKCONSTR_ACTION_RESTRICT = 'r';
pub const FKCONSTR_ACTION_CASCADE = 'c';
pub const FKCONSTR_ACTION_SETNULL = 'n';
pub const FKCONSTR_ACTION_SETDEFAULT = 'd';
pub const FKCONSTR_MATCH_FULL = 'f';
pub const FKCONSTR_MATCH_PARTIAL = 'p';
pub const FKCONSTR_MATCH_SIMPLE = 's';
pub const OPCLASS_ITEM_OPERATOR = @as(c_int, 1);
pub const OPCLASS_ITEM_FUNCTION = @as(c_int, 2);
pub const OPCLASS_ITEM_STORAGETYPE = @as(c_int, 3);
pub const CURSOR_OPT_BINARY = @as(c_int, 0x0001);
pub const CURSOR_OPT_SCROLL = @as(c_int, 0x0002);
pub const CURSOR_OPT_NO_SCROLL = @as(c_int, 0x0004);
pub const CURSOR_OPT_INSENSITIVE = @as(c_int, 0x0008);
pub const CURSOR_OPT_ASENSITIVE = @as(c_int, 0x0010);
pub const CURSOR_OPT_HOLD = @as(c_int, 0x0020);
pub const CURSOR_OPT_FAST_PLAN = @as(c_int, 0x0100);
pub const CURSOR_OPT_GENERIC_PLAN = @as(c_int, 0x0200);
pub const CURSOR_OPT_CUSTOM_PLAN = @as(c_int, 0x0400);
pub const CURSOR_OPT_PARALLEL_OK = @as(c_int, 0x0800);
pub const FETCH_ALL = LONG_MAX;
pub const LOCKDEFS_H_ = "";
pub const NoLock = @as(c_int, 0);
pub const AccessShareLock = @as(c_int, 1);
pub const RowShareLock = @as(c_int, 2);
pub const RowExclusiveLock = @as(c_int, 3);
pub const ShareUpdateExclusiveLock = @as(c_int, 4);
pub const ShareLock = @as(c_int, 5);
pub const ShareRowExclusiveLock = @as(c_int, 6);
pub const ExclusiveLock = @as(c_int, 7);
pub const AccessExclusiveLock = @as(c_int, 8);
pub const MaxLockMode = @as(c_int, 8);
pub const RELCACHE_H = "";
pub const TUPDESC_H = "";
pub const PG_ATTRIBUTE_H = "";
pub const PG_ATTRIBUTE_D_H = "";
pub const AttributeRelationId = @as(c_int, 1249);
pub const AttributeRelation_Rowtype_Id = @as(c_int, 75);
pub const AttributeRelidNameIndexId = @as(c_int, 2658);
pub const AttributeRelidNumIndexId = @as(c_int, 2659);
pub const Anum_pg_attribute_attrelid = @as(c_int, 1);
pub const Anum_pg_attribute_attname = @as(c_int, 2);
pub const Anum_pg_attribute_atttypid = @as(c_int, 3);
pub const Anum_pg_attribute_attlen = @as(c_int, 4);
pub const Anum_pg_attribute_attnum = @as(c_int, 5);
pub const Anum_pg_attribute_attcacheoff = @as(c_int, 6);
pub const Anum_pg_attribute_atttypmod = @as(c_int, 7);
pub const Anum_pg_attribute_attndims = @as(c_int, 8);
pub const Anum_pg_attribute_attbyval = @as(c_int, 9);
pub const Anum_pg_attribute_attalign = @as(c_int, 10);
pub const Anum_pg_attribute_attstorage = @as(c_int, 11);
pub const Anum_pg_attribute_attcompression = @as(c_int, 12);
pub const Anum_pg_attribute_attnotnull = @as(c_int, 13);
pub const Anum_pg_attribute_atthasdef = @as(c_int, 14);
pub const Anum_pg_attribute_atthasmissing = @as(c_int, 15);
pub const Anum_pg_attribute_attidentity = @as(c_int, 16);
pub const Anum_pg_attribute_attgenerated = @as(c_int, 17);
pub const Anum_pg_attribute_attisdropped = @as(c_int, 18);
pub const Anum_pg_attribute_attislocal = @as(c_int, 19);
pub const Anum_pg_attribute_attinhcount = @as(c_int, 20);
pub const Anum_pg_attribute_attstattarget = @as(c_int, 21);
pub const Anum_pg_attribute_attcollation = @as(c_int, 22);
pub const Anum_pg_attribute_attacl = @as(c_int, 23);
pub const Anum_pg_attribute_attoptions = @as(c_int, 24);
pub const Anum_pg_attribute_attfdwoptions = @as(c_int, 25);
pub const Anum_pg_attribute_attmissingval = @as(c_int, 26);
pub const Natts_pg_attribute = @as(c_int, 26);
pub const ATTRIBUTE_IDENTITY_ALWAYS = 'a';
pub const ATTRIBUTE_IDENTITY_BY_DEFAULT = 'd';
pub const ATTRIBUTE_GENERATED_STORED = 's';
pub inline fn TupleDescAttr(tupdesc: anytype, i: anytype) @TypeOf(&tupdesc.*.attrs[@intCast(usize, i)]) {
    return &tupdesc.*.attrs[@intCast(usize, i)];
}
pub const RELCACHE_INIT_FILENAME = "pg_internal.init";
pub inline fn ObjectAddressSet(addr: anytype, class_id: anytype, object_id: anytype) @TypeOf(ObjectAddressSubSet(addr, class_id, object_id, @as(c_int, 0))) {
    return ObjectAddressSubSet(addr, class_id, object_id, @as(c_int, 0));
}
pub const PG_TYPE_D_H = "";
pub const TypeRelationId = @as(c_int, 1247);
pub const TypeRelation_Rowtype_Id = @as(c_int, 71);
pub const TypeOidIndexId = @as(c_int, 2703);
pub const TypeNameNspIndexId = @as(c_int, 2704);
pub const Anum_pg_type_oid = @as(c_int, 1);
pub const Anum_pg_type_typname = @as(c_int, 2);
pub const Anum_pg_type_typnamespace = @as(c_int, 3);
pub const Anum_pg_type_typowner = @as(c_int, 4);
pub const Anum_pg_type_typlen = @as(c_int, 5);
pub const Anum_pg_type_typbyval = @as(c_int, 6);
pub const Anum_pg_type_typtype = @as(c_int, 7);
pub const Anum_pg_type_typcategory = @as(c_int, 8);
pub const Anum_pg_type_typispreferred = @as(c_int, 9);
pub const Anum_pg_type_typisdefined = @as(c_int, 10);
pub const Anum_pg_type_typdelim = @as(c_int, 11);
pub const Anum_pg_type_typrelid = @as(c_int, 12);
pub const Anum_pg_type_typsubscript = @as(c_int, 13);
pub const Anum_pg_type_typelem = @as(c_int, 14);
pub const Anum_pg_type_typarray = @as(c_int, 15);
pub const Anum_pg_type_typinput = @as(c_int, 16);
pub const Anum_pg_type_typoutput = @as(c_int, 17);
pub const Anum_pg_type_typreceive = @as(c_int, 18);
pub const Anum_pg_type_typsend = @as(c_int, 19);
pub const Anum_pg_type_typmodin = @as(c_int, 20);
pub const Anum_pg_type_typmodout = @as(c_int, 21);
pub const Anum_pg_type_typanalyze = @as(c_int, 22);
pub const Anum_pg_type_typalign = @as(c_int, 23);
pub const Anum_pg_type_typstorage = @as(c_int, 24);
pub const Anum_pg_type_typnotnull = @as(c_int, 25);
pub const Anum_pg_type_typbasetype = @as(c_int, 26);
pub const Anum_pg_type_typtypmod = @as(c_int, 27);
pub const Anum_pg_type_typndims = @as(c_int, 28);
pub const Anum_pg_type_typcollation = @as(c_int, 29);
pub const Anum_pg_type_typdefaultbin = @as(c_int, 30);
pub const Anum_pg_type_typdefault = @as(c_int, 31);
pub const Anum_pg_type_typacl = @as(c_int, 32);
pub const Natts_pg_type = @as(c_int, 32);
pub const TYPTYPE_BASE = 'b';
pub const TYPTYPE_COMPOSITE = 'c';
pub const TYPTYPE_DOMAIN = 'd';
pub const TYPTYPE_ENUM = 'e';
pub const TYPTYPE_MULTIRANGE = 'm';
pub const TYPTYPE_PSEUDO = 'p';
pub const TYPTYPE_RANGE = 'r';
pub const TYPCATEGORY_INVALID = '\x00';
pub const TYPCATEGORY_ARRAY = 'A';
pub const TYPCATEGORY_BOOLEAN = 'B';
pub const TYPCATEGORY_COMPOSITE = 'C';
pub const TYPCATEGORY_DATETIME = 'D';
pub const TYPCATEGORY_ENUM = 'E';
pub const TYPCATEGORY_GEOMETRIC = 'G';
pub const TYPCATEGORY_NETWORK = 'I';
pub const TYPCATEGORY_NUMERIC = 'N';
pub const TYPCATEGORY_PSEUDOTYPE = 'P';
pub const TYPCATEGORY_RANGE = 'R';
pub const TYPCATEGORY_STRING = 'S';
pub const TYPCATEGORY_TIMESPAN = 'T';
pub const TYPCATEGORY_USER = 'U';
pub const TYPCATEGORY_BITSTRING = 'V';
pub const TYPCATEGORY_UNKNOWN = 'X';
pub const TYPCATEGORY_INTERNAL = 'Z';
pub const TYPALIGN_CHAR = 'c';
pub const TYPALIGN_SHORT = 's';
pub const TYPALIGN_INT = 'i';
pub const TYPALIGN_DOUBLE = 'd';
pub const TYPSTORAGE_PLAIN = 'p';
pub const TYPSTORAGE_EXTERNAL = 'e';
pub const TYPSTORAGE_EXTENDED = 'x';
pub const TYPSTORAGE_MAIN = 'm';
pub inline fn IsPolymorphicType(typid: anytype) @TypeOf((IsPolymorphicTypeFamily1(typid) != 0) or (IsPolymorphicTypeFamily2(typid) != 0)) {
    return (IsPolymorphicTypeFamily1(typid) != 0) or (IsPolymorphicTypeFamily2(typid) != 0);
}
pub inline fn IsPolymorphicTypeFamily1(typid: anytype) @TypeOf((((((typid == ANYELEMENTOID) or (typid == ANYARRAYOID)) or (typid == ANYNONARRAYOID)) or (typid == ANYENUMOID)) or (typid == ANYRANGEOID)) or (typid == ANYMULTIRANGEOID)) {
    return (((((typid == ANYELEMENTOID) or (typid == ANYARRAYOID)) or (typid == ANYNONARRAYOID)) or (typid == ANYENUMOID)) or (typid == ANYRANGEOID)) or (typid == ANYMULTIRANGEOID);
}
pub inline fn IsPolymorphicTypeFamily2(typid: anytype) @TypeOf(((((typid == ANYCOMPATIBLEOID) or (typid == ANYCOMPATIBLEARRAYOID)) or (typid == ANYCOMPATIBLENONARRAYOID)) or (typid == ANYCOMPATIBLERANGEOID)) or (typid == ANYCOMPATIBLEMULTIRANGEOID)) {
    return ((((typid == ANYCOMPATIBLEOID) or (typid == ANYCOMPATIBLEARRAYOID)) or (typid == ANYCOMPATIBLENONARRAYOID)) or (typid == ANYCOMPATIBLERANGEOID)) or (typid == ANYCOMPATIBLEMULTIRANGEOID);
}
pub const CASHOID = MONEYOID;
pub const LSNOID = PG_LSNOID;
pub const BOOLOID = @as(c_int, 16);
pub const BYTEAOID = @as(c_int, 17);
pub const CHAROID = @as(c_int, 18);
pub const NAMEOID = @as(c_int, 19);
pub const INT8OID = @as(c_int, 20);
pub const INT2OID = @as(c_int, 21);
pub const INT2VECTOROID = @as(c_int, 22);
pub const INT4OID = @as(c_int, 23);
pub const REGPROCOID = @as(c_int, 24);
pub const TEXTOID = @as(c_int, 25);
pub const OIDOID = @as(c_int, 26);
pub const TIDOID = @as(c_int, 27);
pub const XIDOID = @as(c_int, 28);
pub const CIDOID = @as(c_int, 29);
pub const OIDVECTOROID = @as(c_int, 30);
pub const JSONOID = @as(c_int, 114);
pub const XMLOID = @as(c_int, 142);
pub const PG_NODE_TREEOID = @as(c_int, 194);
pub const PG_NDISTINCTOID = @as(c_int, 3361);
pub const PG_DEPENDENCIESOID = @as(c_int, 3402);
pub const PG_MCV_LISTOID = @as(c_int, 5017);
pub const PG_DDL_COMMANDOID = @as(c_int, 32);
pub const XID8OID = @as(c_int, 5069);
pub const POINTOID = @as(c_int, 600);
pub const LSEGOID = @as(c_int, 601);
pub const PATHOID = @as(c_int, 602);
pub const BOXOID = @as(c_int, 603);
pub const POLYGONOID = @as(c_int, 604);
pub const LINEOID = @as(c_int, 628);
pub const FLOAT4OID = @as(c_int, 700);
pub const FLOAT8OID = @as(c_int, 701);
pub const UNKNOWNOID = @as(c_int, 705);
pub const CIRCLEOID = @as(c_int, 718);
pub const MONEYOID = @as(c_int, 790);
pub const MACADDROID = @as(c_int, 829);
pub const INETOID = @as(c_int, 869);
pub const CIDROID = @as(c_int, 650);
pub const MACADDR8OID = @as(c_int, 774);
pub const ACLITEMOID = @as(c_int, 1033);
pub const BPCHAROID = @as(c_int, 1042);
pub const VARCHAROID = @as(c_int, 1043);
pub const DATEOID = @as(c_int, 1082);
pub const TIMEOID = @as(c_int, 1083);
pub const TIMESTAMPOID = @as(c_int, 1114);
pub const TIMESTAMPTZOID = @as(c_int, 1184);
pub const INTERVALOID = @as(c_int, 1186);
pub const TIMETZOID = @as(c_int, 1266);
pub const BITOID = @as(c_int, 1560);
pub const VARBITOID = @as(c_int, 1562);
pub const NUMERICOID = @as(c_int, 1700);
pub const REFCURSOROID = @as(c_int, 1790);
pub const REGPROCEDUREOID = @as(c_int, 2202);
pub const REGOPEROID = @as(c_int, 2203);
pub const REGOPERATOROID = @as(c_int, 2204);
pub const REGCLASSOID = @as(c_int, 2205);
pub const REGCOLLATIONOID = @as(c_int, 4191);
pub const REGTYPEOID = @as(c_int, 2206);
pub const REGROLEOID = @as(c_int, 4096);
pub const REGNAMESPACEOID = @as(c_int, 4089);
pub const UUIDOID = @as(c_int, 2950);
pub const PG_LSNOID = @as(c_int, 3220);
pub const TSVECTOROID = @as(c_int, 3614);
pub const GTSVECTOROID = @as(c_int, 3642);
pub const TSQUERYOID = @as(c_int, 3615);
pub const REGCONFIGOID = @as(c_int, 3734);
pub const REGDICTIONARYOID = @as(c_int, 3769);
pub const JSONBOID = @as(c_int, 3802);
pub const JSONPATHOID = @as(c_int, 4072);
pub const TXID_SNAPSHOTOID = @as(c_int, 2970);
pub const PG_SNAPSHOTOID = @as(c_int, 5038);
pub const INT4RANGEOID = @as(c_int, 3904);
pub const NUMRANGEOID = @as(c_int, 3906);
pub const TSRANGEOID = @as(c_int, 3908);
pub const TSTZRANGEOID = @as(c_int, 3910);
pub const DATERANGEOID = @as(c_int, 3912);
pub const INT8RANGEOID = @as(c_int, 3926);
pub const INT4MULTIRANGEOID = @as(c_int, 4451);
pub const NUMMULTIRANGEOID = @as(c_int, 4532);
pub const TSMULTIRANGEOID = @as(c_int, 4533);
pub const TSTZMULTIRANGEOID = @as(c_int, 4534);
pub const DATEMULTIRANGEOID = @as(c_int, 4535);
pub const INT8MULTIRANGEOID = @as(c_int, 4536);
pub const RECORDOID = @as(c_int, 2249);
pub const RECORDARRAYOID = @as(c_int, 2287);
pub const CSTRINGOID = @as(c_int, 2275);
pub const ANYOID = @as(c_int, 2276);
pub const ANYARRAYOID = @as(c_int, 2277);
pub const VOIDOID = @as(c_int, 2278);
pub const TRIGGEROID = @as(c_int, 2279);
pub const EVENT_TRIGGEROID = @as(c_int, 3838);
pub const LANGUAGE_HANDLEROID = @as(c_int, 2280);
pub const INTERNALOID = @as(c_int, 2281);
pub const ANYELEMENTOID = @as(c_int, 2283);
pub const ANYNONARRAYOID = @as(c_int, 2776);
pub const ANYENUMOID = @as(c_int, 3500);
pub const FDW_HANDLEROID = @as(c_int, 3115);
pub const INDEX_AM_HANDLEROID = @as(c_int, 325);
pub const TSM_HANDLEROID = @as(c_int, 3310);
pub const TABLE_AM_HANDLEROID = @as(c_int, 269);
pub const ANYRANGEOID = @as(c_int, 3831);
pub const ANYCOMPATIBLEOID = @as(c_int, 5077);
pub const ANYCOMPATIBLEARRAYOID = @as(c_int, 5078);
pub const ANYCOMPATIBLENONARRAYOID = @as(c_int, 5079);
pub const ANYCOMPATIBLERANGEOID = @as(c_int, 5080);
pub const ANYMULTIRANGEOID = @as(c_int, 4537);
pub const ANYCOMPATIBLEMULTIRANGEOID = @as(c_int, 4538);
pub const PG_BRIN_BLOOM_SUMMARYOID = @as(c_int, 4600);
pub const PG_BRIN_MINMAX_MULTI_SUMMARYOID = @as(c_int, 4601);
pub const BOOLARRAYOID = @as(c_int, 1000);
pub const BYTEAARRAYOID = @as(c_int, 1001);
pub const CHARARRAYOID = @as(c_int, 1002);
pub const NAMEARRAYOID = @as(c_int, 1003);
pub const INT8ARRAYOID = @as(c_int, 1016);
pub const INT2ARRAYOID = @as(c_int, 1005);
pub const INT2VECTORARRAYOID = @as(c_int, 1006);
pub const INT4ARRAYOID = @as(c_int, 1007);
pub const REGPROCARRAYOID = @as(c_int, 1008);
pub const TEXTARRAYOID = @as(c_int, 1009);
pub const OIDARRAYOID = @as(c_int, 1028);
pub const TIDARRAYOID = @as(c_int, 1010);
pub const XIDARRAYOID = @as(c_int, 1011);
pub const CIDARRAYOID = @as(c_int, 1012);
pub const OIDVECTORARRAYOID = @as(c_int, 1013);
pub const PG_TYPEARRAYOID = @as(c_int, 210);
pub const PG_ATTRIBUTEARRAYOID = @as(c_int, 270);
pub const PG_PROCARRAYOID = @as(c_int, 272);
pub const PG_CLASSARRAYOID = @as(c_int, 273);
pub const JSONARRAYOID = @as(c_int, 199);
pub const XMLARRAYOID = @as(c_int, 143);
pub const XID8ARRAYOID = @as(c_int, 271);
pub const POINTARRAYOID = @as(c_int, 1017);
pub const LSEGARRAYOID = @as(c_int, 1018);
pub const PATHARRAYOID = @as(c_int, 1019);
pub const BOXARRAYOID = @as(c_int, 1020);
pub const POLYGONARRAYOID = @as(c_int, 1027);
pub const LINEARRAYOID = @as(c_int, 629);
pub const FLOAT4ARRAYOID = @as(c_int, 1021);
pub const FLOAT8ARRAYOID = @as(c_int, 1022);
pub const CIRCLEARRAYOID = @as(c_int, 719);
pub const MONEYARRAYOID = @as(c_int, 791);
pub const MACADDRARRAYOID = @as(c_int, 1040);
pub const INETARRAYOID = @as(c_int, 1041);
pub const CIDRARRAYOID = @as(c_int, 651);
pub const MACADDR8ARRAYOID = @as(c_int, 775);
pub const ACLITEMARRAYOID = @as(c_int, 1034);
pub const BPCHARARRAYOID = @as(c_int, 1014);
pub const VARCHARARRAYOID = @as(c_int, 1015);
pub const DATEARRAYOID = @as(c_int, 1182);
pub const TIMEARRAYOID = @as(c_int, 1183);
pub const TIMESTAMPARRAYOID = @as(c_int, 1115);
pub const TIMESTAMPTZARRAYOID = @as(c_int, 1185);
pub const INTERVALARRAYOID = @as(c_int, 1187);
pub const TIMETZARRAYOID = @as(c_int, 1270);
pub const BITARRAYOID = @as(c_int, 1561);
pub const VARBITARRAYOID = @as(c_int, 1563);
pub const NUMERICARRAYOID = @as(c_int, 1231);
pub const REFCURSORARRAYOID = @as(c_int, 2201);
pub const REGPROCEDUREARRAYOID = @as(c_int, 2207);
pub const REGOPERARRAYOID = @as(c_int, 2208);
pub const REGOPERATORARRAYOID = @as(c_int, 2209);
pub const REGCLASSARRAYOID = @as(c_int, 2210);
pub const REGCOLLATIONARRAYOID = @as(c_int, 4192);
pub const REGTYPEARRAYOID = @as(c_int, 2211);
pub const REGROLEARRAYOID = @as(c_int, 4097);
pub const REGNAMESPACEARRAYOID = @as(c_int, 4090);
pub const UUIDARRAYOID = @as(c_int, 2951);
pub const PG_LSNARRAYOID = @as(c_int, 3221);
pub const TSVECTORARRAYOID = @as(c_int, 3643);
pub const GTSVECTORARRAYOID = @as(c_int, 3644);
pub const TSQUERYARRAYOID = @as(c_int, 3645);
pub const REGCONFIGARRAYOID = @as(c_int, 3735);
pub const REGDICTIONARYARRAYOID = @as(c_int, 3770);
pub const JSONBARRAYOID = @as(c_int, 3807);
pub const JSONPATHARRAYOID = @as(c_int, 4073);
pub const TXID_SNAPSHOTARRAYOID = @as(c_int, 2949);
pub const PG_SNAPSHOTARRAYOID = @as(c_int, 5039);
pub const INT4RANGEARRAYOID = @as(c_int, 3905);
pub const NUMRANGEARRAYOID = @as(c_int, 3907);
pub const TSRANGEARRAYOID = @as(c_int, 3909);
pub const TSTZRANGEARRAYOID = @as(c_int, 3911);
pub const DATERANGEARRAYOID = @as(c_int, 3913);
pub const INT8RANGEARRAYOID = @as(c_int, 3927);
pub const INT4MULTIRANGEARRAYOID = @as(c_int, 6150);
pub const NUMMULTIRANGEARRAYOID = @as(c_int, 6151);
pub const TSMULTIRANGEARRAYOID = @as(c_int, 6152);
pub const TSTZMULTIRANGEARRAYOID = @as(c_int, 6153);
pub const DATEMULTIRANGEARRAYOID = @as(c_int, 6155);
pub const INT8MULTIRANGEARRAYOID = @as(c_int, 6157);
pub const CSTRINGARRAYOID = @as(c_int, 1263);
pub const LOGICAL_H = "";
pub const XLOG_H = "";
pub const XLOG_BACKUP_H = "";
pub const XLOG_DEFS_H = "";
pub const _FCNTL_H = @as(c_int, 1);
pub const __O_LARGEFILE = @as(c_int, 0);
pub const F_GETLK64 = @as(c_int, 5);
pub const F_SETLK64 = @as(c_int, 6);
pub const F_SETLKW64 = @as(c_int, 7);
pub const O_ACCMODE = @as(c_int, 0o003);
pub const O_RDONLY = @as(c_int, 0o0);
pub const O_WRONLY = @as(c_int, 0o1);
pub const O_RDWR = @as(c_int, 0o2);
pub const O_CREAT = @as(c_int, 0o100);
pub const O_EXCL = @as(c_int, 0o200);
pub const O_NOCTTY = @as(c_int, 0o400);
pub const O_TRUNC = @as(c_int, 0o1000);
pub const O_APPEND = @as(c_int, 0o2000);
pub const O_NONBLOCK = @as(c_int, 0o4000);
pub const O_NDELAY = O_NONBLOCK;
pub const O_SYNC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o4010000, .octal);
pub const O_FSYNC = O_SYNC;
pub const O_ASYNC = @as(c_int, 0o20000);
pub const __O_DIRECTORY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o200000, .octal);
pub const __O_NOFOLLOW = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o400000, .octal);
pub const __O_CLOEXEC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o2000000, .octal);
pub const __O_DIRECT = @as(c_int, 0o40000);
pub const __O_NOATIME = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o1000000, .octal);
pub const __O_PATH = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o10000000, .octal);
pub const __O_DSYNC = @as(c_int, 0o10000);
pub const __O_TMPFILE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o20000000, .octal) | __O_DIRECTORY;
pub const F_GETLK = @as(c_int, 5);
pub const F_SETLK = @as(c_int, 6);
pub const F_SETLKW = @as(c_int, 7);
pub const O_DIRECTORY = __O_DIRECTORY;
pub const O_NOFOLLOW = __O_NOFOLLOW;
pub const O_CLOEXEC = __O_CLOEXEC;
pub const O_DSYNC = __O_DSYNC;
pub const O_RSYNC = O_SYNC;
pub const F_DUPFD = @as(c_int, 0);
pub const F_GETFD = @as(c_int, 1);
pub const F_SETFD = @as(c_int, 2);
pub const F_GETFL = @as(c_int, 3);
pub const F_SETFL = @as(c_int, 4);
pub const __F_SETOWN = @as(c_int, 8);
pub const __F_GETOWN = @as(c_int, 9);
pub const F_SETOWN = __F_SETOWN;
pub const F_GETOWN = __F_GETOWN;
pub const __F_SETSIG = @as(c_int, 10);
pub const __F_GETSIG = @as(c_int, 11);
pub const __F_SETOWN_EX = @as(c_int, 15);
pub const __F_GETOWN_EX = @as(c_int, 16);
pub const F_DUPFD_CLOEXEC = @as(c_int, 1030);
pub const FD_CLOEXEC = @as(c_int, 1);
pub const F_RDLCK = @as(c_int, 0);
pub const F_WRLCK = @as(c_int, 1);
pub const F_UNLCK = @as(c_int, 2);
pub const F_EXLCK = @as(c_int, 4);
pub const F_SHLCK = @as(c_int, 8);
pub const LOCK_SH = @as(c_int, 1);
pub const LOCK_EX = @as(c_int, 2);
pub const LOCK_NB = @as(c_int, 4);
pub const LOCK_UN = @as(c_int, 8);
pub const FAPPEND = O_APPEND;
pub const FFSYNC = O_FSYNC;
pub const FASYNC = O_ASYNC;
pub const FNONBLOCK = O_NONBLOCK;
pub const FNDELAY = O_NDELAY;
pub const __POSIX_FADV_DONTNEED = @as(c_int, 4);
pub const __POSIX_FADV_NOREUSE = @as(c_int, 5);
pub const POSIX_FADV_NORMAL = @as(c_int, 0);
pub const POSIX_FADV_RANDOM = @as(c_int, 1);
pub const POSIX_FADV_SEQUENTIAL = @as(c_int, 2);
pub const POSIX_FADV_WILLNEED = @as(c_int, 3);
pub const POSIX_FADV_DONTNEED = __POSIX_FADV_DONTNEED;
pub const POSIX_FADV_NOREUSE = __POSIX_FADV_NOREUSE;
pub inline fn __OPEN_NEEDS_MODE(oflag: anytype) @TypeOf(((oflag & O_CREAT) != @as(c_int, 0)) or ((oflag & __O_TMPFILE) == __O_TMPFILE)) {
    return ((oflag & O_CREAT) != @as(c_int, 0)) or ((oflag & __O_TMPFILE) == __O_TMPFILE);
}
pub const _BITS_STAT_H = @as(c_int, 1);
pub const _BITS_STRUCT_STAT_H = @as(c_int, 1);
pub const _STATBUF_ST_BLKSIZE = "";
pub const _STATBUF_ST_RDEV = "";
pub const _STATBUF_ST_NSEC = "";
pub const __S_IFMT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal);
pub const __S_IFDIR = @as(c_int, 0o040000);
pub const __S_IFCHR = @as(c_int, 0o020000);
pub const __S_IFBLK = @as(c_int, 0o060000);
pub const __S_IFREG = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o100000, .octal);
pub const __S_IFIFO = @as(c_int, 0o010000);
pub const __S_IFLNK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o120000, .octal);
pub const __S_IFSOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o140000, .octal);
pub inline fn __S_TYPEISMQ(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    return buf.*.st_mode - buf.*.st_mode;
}
pub inline fn __S_TYPEISSEM(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    return buf.*.st_mode - buf.*.st_mode;
}
pub inline fn __S_TYPEISSHM(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    return buf.*.st_mode - buf.*.st_mode;
}
pub const __S_ISUID = @as(c_int, 0o4000);
pub const __S_ISGID = @as(c_int, 0o2000);
pub const __S_ISVTX = @as(c_int, 0o1000);
pub const __S_IREAD = @as(c_int, 0o400);
pub const __S_IWRITE = @as(c_int, 0o200);
pub const __S_IEXEC = @as(c_int, 0o100);
pub const UTIME_NOW = (@as(c_long, 1) << @as(c_int, 30)) - @as(c_long, 1);
pub const UTIME_OMIT = (@as(c_long, 1) << @as(c_int, 30)) - @as(c_long, 2);
pub const S_IFMT = __S_IFMT;
pub const S_IFDIR = __S_IFDIR;
pub const S_IFCHR = __S_IFCHR;
pub const S_IFBLK = __S_IFBLK;
pub const S_IFREG = __S_IFREG;
pub const S_IFIFO = __S_IFIFO;
pub const S_IFLNK = __S_IFLNK;
pub const S_IFSOCK = __S_IFSOCK;
pub const S_ISUID = __S_ISUID;
pub const S_ISGID = __S_ISGID;
pub const S_ISVTX = __S_ISVTX;
pub const S_IRUSR = __S_IREAD;
pub const S_IWUSR = __S_IWRITE;
pub const S_IXUSR = __S_IEXEC;
pub const S_IRWXU = (__S_IREAD | __S_IWRITE) | __S_IEXEC;
pub const S_IRGRP = S_IRUSR >> @as(c_int, 3);
pub const S_IWGRP = S_IWUSR >> @as(c_int, 3);
pub const S_IXGRP = S_IXUSR >> @as(c_int, 3);
pub const S_IRWXG = S_IRWXU >> @as(c_int, 3);
pub const S_IROTH = S_IRGRP >> @as(c_int, 3);
pub const S_IWOTH = S_IWGRP >> @as(c_int, 3);
pub const S_IXOTH = S_IXGRP >> @as(c_int, 3);
pub const S_IRWXO = S_IRWXG >> @as(c_int, 3);
pub const R_OK = @as(c_int, 4);
pub const W_OK = @as(c_int, 2);
pub const X_OK = @as(c_int, 1);
pub const F_OK = @as(c_int, 0);
pub const AT_FDCWD = -@as(c_int, 100);
pub const AT_SYMLINK_NOFOLLOW = @as(c_int, 0x100);
pub const AT_REMOVEDIR = @as(c_int, 0x200);
pub const AT_SYMLINK_FOLLOW = @as(c_int, 0x400);
pub const AT_EACCESS = @as(c_int, 0x200);
pub const F_ULOCK = @as(c_int, 0);
pub const F_LOCK = @as(c_int, 1);
pub const F_TLOCK = @as(c_int, 2);
pub const F_TEST = @as(c_int, 3);
pub const InvalidXLogRecPtr = @as(c_int, 0);
pub inline fn XLogRecPtrIsInvalid(r: anytype) @TypeOf(r == InvalidXLogRecPtr) {
    return r == InvalidXLogRecPtr;
}
pub const FirstNormalUnloggedLSN = @import("std").zig.c_translation.cast(XLogRecPtr, @as(c_int, 1000));
pub inline fn LSN_FORMAT_ARGS(lsn: anytype) uint32 {
    return blk: {
        _ = blk_1: {
            _ = AssertVariableIsOfTypeMacro(lsn, XLogRecPtr);
            break :blk_1 @import("std").zig.c_translation.cast(uint32, lsn >> @as(c_int, 32));
        };
        break :blk @import("std").zig.c_translation.cast(uint32, lsn);
    };
}
pub const DEFAULT_SYNC_METHOD = PLATFORM_DEFAULT_SYNC_METHOD;
pub const _PGTIME_H = "";
pub const TZ_STRLEN_MAX = @as(c_int, 255);
pub const DATATYPE_TIMESTAMP_H = "";
pub const MAX_TIMESTAMP_PRECISION = @as(c_int, 6);
pub const MAX_INTERVAL_PRECISION = @as(c_int, 6);
pub const TS_PREC_INV = @as(f64, 1000000.0);
pub inline fn TSROUND(j: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(rint(@import("std").zig.c_translation.cast(f64, j) * TS_PREC_INV), TS_PREC_INV)) {
    return @import("std").zig.c_translation.MacroArithmetic.div(rint(@import("std").zig.c_translation.cast(f64, j) * TS_PREC_INV), TS_PREC_INV);
}
pub const DAYS_PER_YEAR = @as(f64, 365.25);
pub const MONTHS_PER_YEAR = @as(c_int, 12);
pub const DAYS_PER_MONTH = @as(c_int, 30);
pub const HOURS_PER_DAY = @as(c_int, 24);
pub const SECS_PER_YEAR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 36525, .decimal) * @as(c_int, 864);
pub const SECS_PER_DAY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 86400, .decimal);
pub const SECS_PER_HOUR = @as(c_int, 3600);
pub const SECS_PER_MINUTE = @as(c_int, 60);
pub const MINS_PER_HOUR = @as(c_int, 60);
pub const USECS_PER_DAY = INT64CONST(@import("std").zig.c_translation.promoteIntLiteral(c_int, 86400000000, .decimal));
pub const USECS_PER_HOUR = INT64CONST(@import("std").zig.c_translation.promoteIntLiteral(c_int, 3600000000, .decimal));
pub const USECS_PER_MINUTE = INT64CONST(@import("std").zig.c_translation.promoteIntLiteral(c_int, 60000000, .decimal));
pub const USECS_PER_SEC = INT64CONST(@import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const MAX_TZDISP_HOUR = @as(c_int, 15);
pub const TZDISP_LIMIT = (MAX_TZDISP_HOUR + @as(c_int, 1)) * SECS_PER_HOUR;
pub const TIMESTAMP_MINUS_INFINITY = PG_INT64_MIN;
pub const TIMESTAMP_INFINITY = PG_INT64_MAX;
pub const DT_NOBEGIN = TIMESTAMP_MINUS_INFINITY;
pub const DT_NOEND = TIMESTAMP_INFINITY;
pub inline fn TIMESTAMP_IS_NOBEGIN(j: anytype) @TypeOf(j == DT_NOBEGIN) {
    return j == DT_NOBEGIN;
}
pub inline fn TIMESTAMP_IS_NOEND(j: anytype) @TypeOf(j == DT_NOEND) {
    return j == DT_NOEND;
}
pub inline fn TIMESTAMP_NOT_FINITE(j: anytype) @TypeOf((TIMESTAMP_IS_NOBEGIN(j) != 0) or (TIMESTAMP_IS_NOEND(j) != 0)) {
    return (TIMESTAMP_IS_NOBEGIN(j) != 0) or (TIMESTAMP_IS_NOEND(j) != 0);
}
pub const JULIAN_MINYEAR = -@as(c_int, 4713);
pub const JULIAN_MINMONTH = @as(c_int, 11);
pub const JULIAN_MINDAY = @as(c_int, 24);
pub const JULIAN_MAXYEAR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 5874898, .decimal);
pub const JULIAN_MAXMONTH = @as(c_int, 6);
pub const JULIAN_MAXDAY = @as(c_int, 3);
pub inline fn IS_VALID_JULIAN(y: anytype, m: anytype, d: anytype) @TypeOf(((y > JULIAN_MINYEAR) or ((y == JULIAN_MINYEAR) and (m >= JULIAN_MINMONTH))) and ((y < JULIAN_MAXYEAR) or ((y == JULIAN_MAXYEAR) and (m < JULIAN_MAXMONTH)))) {
    _ = @TypeOf(d);
    return ((y > JULIAN_MINYEAR) or ((y == JULIAN_MINYEAR) and (m >= JULIAN_MINMONTH))) and ((y < JULIAN_MAXYEAR) or ((y == JULIAN_MAXYEAR) and (m < JULIAN_MAXMONTH)));
}
pub const UNIX_EPOCH_JDATE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2440588, .decimal);
pub const POSTGRES_EPOCH_JDATE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2451545, .decimal);
pub const DATETIME_MIN_JULIAN = @as(c_int, 0);
pub const DATE_END_JULIAN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483494, .decimal);
pub const TIMESTAMP_END_JULIAN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 109203528, .decimal);
pub const MIN_TIMESTAMP = INT64CONST(-@import("std").zig.c_translation.promoteIntLiteral(c_int, 211813488000000000, .decimal));
pub const END_TIMESTAMP = INT64CONST(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223371331200000000, .decimal));
pub inline fn IS_VALID_DATE(d: anytype) @TypeOf(((DATETIME_MIN_JULIAN - POSTGRES_EPOCH_JDATE) <= d) and (d < (DATE_END_JULIAN - POSTGRES_EPOCH_JDATE))) {
    return ((DATETIME_MIN_JULIAN - POSTGRES_EPOCH_JDATE) <= d) and (d < (DATE_END_JULIAN - POSTGRES_EPOCH_JDATE));
}
pub inline fn IS_VALID_TIMESTAMP(t: anytype) @TypeOf((MIN_TIMESTAMP <= t) and (t < END_TIMESTAMP)) {
    return (MIN_TIMESTAMP <= t) and (t < END_TIMESTAMP);
}
pub const SYNC_METHOD_FSYNC = @as(c_int, 0);
pub const SYNC_METHOD_FDATASYNC = @as(c_int, 1);
pub const SYNC_METHOD_OPEN = @as(c_int, 2);
pub const SYNC_METHOD_FSYNC_WRITETHROUGH = @as(c_int, 3);
pub const SYNC_METHOD_OPEN_DSYNC = @as(c_int, 4);
pub inline fn XLogArchivingActive() @TypeOf(XLogArchiveMode > ARCHIVE_MODE_OFF) {
    return blk_1: {
        _ = AssertMacro((XLogArchiveMode == ARCHIVE_MODE_OFF) or (wal_level >= WAL_LEVEL_REPLICA));
        break :blk_1 XLogArchiveMode > ARCHIVE_MODE_OFF;
    };
}
pub inline fn XLogArchivingAlways() @TypeOf(XLogArchiveMode == ARCHIVE_MODE_ALWAYS) {
    return blk_1: {
        _ = AssertMacro((XLogArchiveMode == ARCHIVE_MODE_OFF) or (wal_level >= WAL_LEVEL_REPLICA));
        break :blk_1 XLogArchiveMode == ARCHIVE_MODE_ALWAYS;
    };
}
pub inline fn XLogIsNeeded() @TypeOf(wal_level >= WAL_LEVEL_REPLICA) {
    return wal_level >= WAL_LEVEL_REPLICA;
}
pub inline fn XLogHintBitIsNeeded() @TypeOf((DataChecksumsEnabled() != 0) or (wal_log_hints != 0)) {
    return (DataChecksumsEnabled() != 0) or (wal_log_hints != 0);
}
pub inline fn XLogStandbyInfoActive() @TypeOf(wal_level >= WAL_LEVEL_REPLICA) {
    return wal_level >= WAL_LEVEL_REPLICA;
}
pub inline fn XLogLogicalInfoActive() @TypeOf(wal_level >= WAL_LEVEL_LOGICAL) {
    return wal_level >= WAL_LEVEL_LOGICAL;
}
pub const CHECKPOINT_IS_SHUTDOWN = @as(c_int, 0x0001);
pub const CHECKPOINT_END_OF_RECOVERY = @as(c_int, 0x0002);
pub const CHECKPOINT_IMMEDIATE = @as(c_int, 0x0004);
pub const CHECKPOINT_FORCE = @as(c_int, 0x0008);
pub const CHECKPOINT_FLUSH_ALL = @as(c_int, 0x0010);
pub const CHECKPOINT_WAIT = @as(c_int, 0x0020);
pub const CHECKPOINT_REQUESTED = @as(c_int, 0x0040);
pub const CHECKPOINT_CAUSE_XLOG = @as(c_int, 0x0080);
pub const CHECKPOINT_CAUSE_TIME = @as(c_int, 0x0100);
pub const XLOG_INCLUDE_ORIGIN = @as(c_int, 0x01);
pub const XLOG_MARK_UNIMPORTANT = @as(c_int, 0x02);
pub const RECOVERY_SIGNAL_FILE = "recovery.signal";
pub const STANDBY_SIGNAL_FILE = "standby.signal";
pub const BACKUP_LABEL_FILE = "backup_label";
pub const BACKUP_LABEL_OLD = "backup_label.old";
pub const TABLESPACE_MAP = "tablespace_map";
pub const TABLESPACE_MAP_OLD = "tablespace_map.old";
pub const PROMOTE_SIGNAL_FILE = "promote";
pub const XLOGREADER_H = "";
pub const TRANSAM_H = "";
pub const InvalidTransactionId = @import("std").zig.c_translation.cast(TransactionId, @as(c_int, 0));
pub const BootstrapTransactionId = @import("std").zig.c_translation.cast(TransactionId, @as(c_int, 1));
pub const FrozenTransactionId = @import("std").zig.c_translation.cast(TransactionId, @as(c_int, 2));
pub const FirstNormalTransactionId = @import("std").zig.c_translation.cast(TransactionId, @as(c_int, 3));
pub const MaxTransactionId = @import("std").zig.c_translation.cast(TransactionId, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFFFFFF, .hexadecimal));
pub inline fn TransactionIdIsValid(xid: anytype) @TypeOf(xid != InvalidTransactionId) {
    return xid != InvalidTransactionId;
}
pub inline fn TransactionIdIsNormal(xid: anytype) @TypeOf(xid >= FirstNormalTransactionId) {
    return xid >= FirstNormalTransactionId;
}
pub inline fn TransactionIdEquals(id1: anytype, id2: anytype) @TypeOf(id1 == id2) {
    return id1 == id2;
}
pub inline fn EpochFromFullTransactionId(x: anytype) uint32 {
    return @import("std").zig.c_translation.cast(uint32, x.value >> @as(c_int, 32));
}
pub inline fn XidFromFullTransactionId(x: anytype) uint32 {
    return @import("std").zig.c_translation.cast(uint32, x.value);
}
pub inline fn U64FromFullTransactionId(x: anytype) @TypeOf(x.value) {
    return x.value;
}
pub inline fn FullTransactionIdEquals(a: anytype, b: anytype) @TypeOf(a.value == b.value) {
    return a.value == b.value;
}
pub inline fn FullTransactionIdPrecedes(a: anytype, b: anytype) @TypeOf(a.value < b.value) {
    return a.value < b.value;
}
pub inline fn FullTransactionIdPrecedesOrEquals(a: anytype, b: anytype) @TypeOf(a.value <= b.value) {
    return a.value <= b.value;
}
pub inline fn FullTransactionIdFollows(a: anytype, b: anytype) @TypeOf(a.value > b.value) {
    return a.value > b.value;
}
pub inline fn FullTransactionIdFollowsOrEquals(a: anytype, b: anytype) @TypeOf(a.value >= b.value) {
    return a.value >= b.value;
}
pub inline fn FullTransactionIdIsValid(x: anytype) @TypeOf(TransactionIdIsValid(XidFromFullTransactionId(x))) {
    return TransactionIdIsValid(XidFromFullTransactionId(x));
}
pub const InvalidFullTransactionId = FullTransactionIdFromEpochAndXid(@as(c_int, 0), InvalidTransactionId);
pub const FirstNormalFullTransactionId = FullTransactionIdFromEpochAndXid(@as(c_int, 0), FirstNormalTransactionId);
pub inline fn FullTransactionIdIsNormal(x: anytype) @TypeOf(FullTransactionIdFollowsOrEquals(x, FirstNormalFullTransactionId)) {
    return FullTransactionIdFollowsOrEquals(x, FirstNormalFullTransactionId);
}
pub inline fn NormalTransactionIdPrecedes(id1: anytype, id2: anytype) @TypeOf(@import("std").zig.c_translation.cast(int32, id1 - id2) < @as(c_int, 0)) {
    return blk_1: {
        _ = AssertMacro((TransactionIdIsNormal(id1) != 0) and (TransactionIdIsNormal(id2) != 0));
        break :blk_1 @import("std").zig.c_translation.cast(int32, id1 - id2) < @as(c_int, 0);
    };
}
pub inline fn NormalTransactionIdFollows(id1: anytype, id2: anytype) @TypeOf(@import("std").zig.c_translation.cast(int32, id1 - id2) > @as(c_int, 0)) {
    return blk_1: {
        _ = AssertMacro((TransactionIdIsNormal(id1) != 0) and (TransactionIdIsNormal(id2) != 0));
        break :blk_1 @import("std").zig.c_translation.cast(int32, id1 - id2) > @as(c_int, 0);
    };
}
pub const FirstGenbkiObjectId = @as(c_int, 10000);
pub const FirstUnpinnedObjectId = @as(c_int, 12000);
pub const FirstNormalObjectId = @as(c_int, 16384);
pub inline fn AssertTransactionIdInAllowableRange(xid: anytype) anyopaque {
    _ = @TypeOf(xid);
    return @import("std").zig.c_translation.cast(anyopaque, @"true");
}
pub const XLOGRECORD_H = "";
pub const RMGR_H = "";
pub const RM_MAX_ID = UINT8_MAX;
pub const RM_MAX_BUILTIN_ID = RM_NEXT_ID - @as(c_int, 1);
pub const RM_MIN_CUSTOM_ID = @as(c_int, 128);
pub const RM_MAX_CUSTOM_ID = UINT8_MAX;
pub const RM_N_IDS = UINT8_MAX + @as(c_int, 1);
pub const RM_N_BUILTIN_IDS = RM_MAX_BUILTIN_ID + @as(c_int, 1);
pub const RM_N_CUSTOM_IDS = (RM_MAX_CUSTOM_ID - RM_MIN_CUSTOM_ID) + @as(c_int, 1);
pub inline fn RmgrIdIsValid(rmid: anytype) @TypeOf((RmgrIdIsBuiltin(rmid) != 0) or (RmgrIdIsCustom(rmid) != 0)) {
    return (RmgrIdIsBuiltin(rmid) != 0) or (RmgrIdIsCustom(rmid) != 0);
}
pub const RM_EXPERIMENTAL_ID = @as(c_int, 128);
pub const PG_CRC32C_H = "";
pub const PG_BSWAP_H = "";
pub inline fn pg_bswap16(x: anytype) @TypeOf(__builtin_bswap16(x)) {
    return __builtin_bswap16(x);
}
pub inline fn pg_bswap32(x: anytype) @TypeOf(__builtin_bswap32(x)) {
    return __builtin_bswap32(x);
}
pub inline fn pg_bswap64(x: anytype) @TypeOf(__builtin_bswap64(x)) {
    return __builtin_bswap64(x);
}
pub inline fn pg_hton16(x: anytype) @TypeOf(pg_bswap16(x)) {
    return pg_bswap16(x);
}
pub inline fn pg_hton32(x: anytype) @TypeOf(pg_bswap32(x)) {
    return pg_bswap32(x);
}
pub inline fn pg_hton64(x: anytype) @TypeOf(pg_bswap64(x)) {
    return pg_bswap64(x);
}
pub inline fn pg_ntoh16(x: anytype) @TypeOf(pg_bswap16(x)) {
    return pg_bswap16(x);
}
pub inline fn pg_ntoh32(x: anytype) @TypeOf(pg_bswap32(x)) {
    return pg_bswap32(x);
}
pub inline fn pg_ntoh64(x: anytype) @TypeOf(pg_bswap64(x)) {
    return pg_bswap64(x);
}
pub inline fn DatumBigEndianToNative(x: anytype) @TypeOf(pg_bswap64(x)) {
    return pg_bswap64(x);
}
pub inline fn EQ_CRC32C(c1: anytype, c2: anytype) @TypeOf(c1 == c2) {
    return c1 == c2;
}
pub const RELFILELOCATOR_H = "";
pub const BACKENDID_H = "";
pub const InvalidBackendId = -@as(c_int, 1);
pub inline fn BackendIdForTempRelations() @TypeOf(if (ParallelLeaderBackendId == InvalidBackendId) MyBackendId else ParallelLeaderBackendId) {
    return if (ParallelLeaderBackendId == InvalidBackendId) MyBackendId else ParallelLeaderBackendId;
}
pub inline fn RelFileLocatorBackendIsTemp(rlocator: anytype) @TypeOf(rlocator.backend != InvalidBackendId) {
    return rlocator.backend != InvalidBackendId;
}
pub inline fn RelFileLocatorEquals(locator1: anytype, locator2: anytype) @TypeOf(((locator1.relNumber == locator2.relNumber) and (locator1.dbOid == locator2.dbOid)) and (locator1.spcOid == locator2.spcOid)) {
    return ((locator1.relNumber == locator2.relNumber) and (locator1.dbOid == locator2.dbOid)) and (locator1.spcOid == locator2.spcOid);
}
pub inline fn RelFileLocatorBackendEquals(locator1: anytype, locator2: anytype) @TypeOf((((locator1.locator.relNumber == locator2.locator.relNumber) and (locator1.locator.dbOid == locator2.locator.dbOid)) and (locator1.backend == locator2.backend)) and (locator1.locator.spcOid == locator2.locator.spcOid)) {
    return (((locator1.locator.relNumber == locator2.locator.relNumber) and (locator1.locator.dbOid == locator2.locator.dbOid)) and (locator1.backend == locator2.backend)) and (locator1.locator.spcOid == locator2.locator.spcOid);
}
pub const XLR_INFO_MASK = @as(c_int, 0x0F);
pub const XLR_RMGR_INFO_MASK = @as(c_int, 0xF0);
pub const XLogRecordMaxSize = (@as(c_int, 1020) * @as(c_int, 1024)) * @as(c_int, 1024);
pub const XLR_SPECIAL_REL_UPDATE = @as(c_int, 0x01);
pub const XLR_CHECK_CONSISTENCY = @as(c_int, 0x02);
pub const BKPIMAGE_HAS_HOLE = @as(c_int, 0x01);
pub const BKPIMAGE_APPLY = @as(c_int, 0x02);
pub const BKPIMAGE_COMPRESS_PGLZ = @as(c_int, 0x04);
pub const BKPIMAGE_COMPRESS_LZ4 = @as(c_int, 0x08);
pub const BKPIMAGE_COMPRESS_ZSTD = @as(c_int, 0x10);
pub inline fn BKPIMAGE_COMPRESSED(info: anytype) @TypeOf((info & ((BKPIMAGE_COMPRESS_PGLZ | BKPIMAGE_COMPRESS_LZ4) | BKPIMAGE_COMPRESS_ZSTD)) != @as(c_int, 0)) {
    return (info & ((BKPIMAGE_COMPRESS_PGLZ | BKPIMAGE_COMPRESS_LZ4) | BKPIMAGE_COMPRESS_ZSTD)) != @as(c_int, 0);
}
pub const SizeOfXLogRecordBlockCompressHeader = @import("std").zig.c_translation.sizeof(XLogRecordBlockCompressHeader);
pub const MaxSizeOfXLogRecordBlockHeader = (((SizeOfXLogRecordBlockHeader + SizeOfXLogRecordBlockImageHeader) + SizeOfXLogRecordBlockCompressHeader) + @import("std").zig.c_translation.sizeof(RelFileLocator)) + @import("std").zig.c_translation.sizeof(BlockNumber);
pub const BKPBLOCK_FORK_MASK = @as(c_int, 0x0F);
pub const BKPBLOCK_FLAG_MASK = @as(c_int, 0xF0);
pub const BKPBLOCK_HAS_IMAGE = @as(c_int, 0x10);
pub const BKPBLOCK_HAS_DATA = @as(c_int, 0x20);
pub const BKPBLOCK_WILL_INIT = @as(c_int, 0x40);
pub const BKPBLOCK_SAME_REL = @as(c_int, 0x80);
pub const SizeOfXLogRecordDataHeaderShort = @import("std").zig.c_translation.sizeof(uint8) * @as(c_int, 2);
pub const SizeOfXLogRecordDataHeaderLong = @import("std").zig.c_translation.sizeof(uint8) + @import("std").zig.c_translation.sizeof(uint32);
pub const XLR_MAX_BLOCK_ID = @as(c_int, 32);
pub const XLR_BLOCK_ID_DATA_SHORT = @as(c_int, 255);
pub const XLR_BLOCK_ID_DATA_LONG = @as(c_int, 254);
pub const XLR_BLOCK_ID_ORIGIN = @as(c_int, 253);
pub const XLR_BLOCK_ID_TOPLEVEL_XID = @as(c_int, 252);
pub const BUF_H = "";
pub const InvalidBuffer = @as(c_int, 0);
pub inline fn BufferIsInvalid(buffer: anytype) @TypeOf(buffer == InvalidBuffer) {
    return buffer == InvalidBuffer;
}
pub inline fn BufferIsLocal(buffer: anytype) @TypeOf(buffer < @as(c_int, 0)) {
    return buffer < @as(c_int, 0);
}
pub inline fn XLogRecGetTotalLen(decoder: anytype) @TypeOf(decoder.*.record.*.header.xl_tot_len) {
    return decoder.*.record.*.header.xl_tot_len;
}
pub inline fn XLogRecGetPrev(decoder: anytype) @TypeOf(decoder.*.record.*.header.xl_prev) {
    return decoder.*.record.*.header.xl_prev;
}
pub inline fn XLogRecGetInfo(decoder: anytype) @TypeOf(decoder.*.record.*.header.xl_info) {
    return decoder.*.record.*.header.xl_info;
}
pub inline fn XLogRecGetRmid(decoder: anytype) @TypeOf(decoder.*.record.*.header.xl_rmid) {
    return decoder.*.record.*.header.xl_rmid;
}
pub inline fn XLogRecGetXid(decoder: anytype) @TypeOf(decoder.*.record.*.header.xl_xid) {
    return decoder.*.record.*.header.xl_xid;
}
pub inline fn XLogRecGetOrigin(decoder: anytype) @TypeOf(decoder.*.record.*.record_origin) {
    return decoder.*.record.*.record_origin;
}
pub inline fn XLogRecGetTopXid(decoder: anytype) @TypeOf(decoder.*.record.*.toplevel_xid) {
    return decoder.*.record.*.toplevel_xid;
}
pub inline fn XLogRecGetData(decoder: anytype) @TypeOf(decoder.*.record.*.main_data) {
    return decoder.*.record.*.main_data;
}
pub inline fn XLogRecGetDataLen(decoder: anytype) @TypeOf(decoder.*.record.*.main_data_len) {
    return decoder.*.record.*.main_data_len;
}
pub inline fn XLogRecHasAnyBlockRefs(decoder: anytype) @TypeOf(decoder.*.record.*.max_block_id >= @as(c_int, 0)) {
    return decoder.*.record.*.max_block_id >= @as(c_int, 0);
}
pub inline fn XLogRecMaxBlockId(decoder: anytype) @TypeOf(decoder.*.record.*.max_block_id) {
    return decoder.*.record.*.max_block_id;
}
pub inline fn XLogRecGetBlock(decoder: anytype, i: anytype) @TypeOf(&decoder.*.record.*.blocks[@intCast(usize, i)]) {
    return &decoder.*.record.*.blocks[@intCast(usize, i)];
}
pub inline fn XLogRecHasBlockRef(decoder: anytype, block_id: anytype) @TypeOf((decoder.*.record.*.max_block_id >= block_id) and (decoder.*.record.*.blocks[@intCast(usize, block_id)].in_use != 0)) {
    return (decoder.*.record.*.max_block_id >= block_id) and (decoder.*.record.*.blocks[@intCast(usize, block_id)].in_use != 0);
}
pub inline fn XLogRecHasBlockImage(decoder: anytype, block_id: anytype) @TypeOf(decoder.*.record.*.blocks[@intCast(usize, block_id)].has_image) {
    return decoder.*.record.*.blocks[@intCast(usize, block_id)].has_image;
}
pub inline fn XLogRecBlockImageApply(decoder: anytype, block_id: anytype) @TypeOf(decoder.*.record.*.blocks[@intCast(usize, block_id)].apply_image) {
    return decoder.*.record.*.blocks[@intCast(usize, block_id)].apply_image;
}
pub inline fn XLogRecHasBlockData(decoder: anytype, block_id: anytype) @TypeOf(decoder.*.record.*.blocks[@intCast(usize, block_id)].has_data) {
    return decoder.*.record.*.blocks[@intCast(usize, block_id)].has_data;
}
pub const OUTPUT_PLUGIN_H = "";
pub const REORDERBUFFER_H = "";
pub const HTUP_DETAILS_H = "";
pub const TUPMACS_H = "";
pub inline fn fetchatt(A: anytype, T: anytype) @TypeOf(fetch_att(T, A.*.attbyval, A.*.attlen)) {
    return fetch_att(T, A.*.attbyval, A.*.attlen);
}
pub inline fn att_align_datum(cur_offset: anytype, attalign: anytype, attlen: anytype, attdatum: anytype) @TypeOf(if ((attlen == -@as(c_int, 1)) and (VARATT_IS_SHORT(DatumGetPointer(attdatum)) != 0)) @import("std").zig.c_translation.cast(usize, cur_offset) else att_align_nominal(cur_offset, attalign)) {
    return if ((attlen == -@as(c_int, 1)) and (VARATT_IS_SHORT(DatumGetPointer(attdatum)) != 0)) @import("std").zig.c_translation.cast(usize, cur_offset) else att_align_nominal(cur_offset, attalign);
}
pub inline fn att_align_pointer(cur_offset: anytype, attalign: anytype, attlen: anytype, attptr: anytype) @TypeOf(if ((attlen == -@as(c_int, 1)) and (VARATT_NOT_PAD_BYTE(attptr) != 0)) @import("std").zig.c_translation.cast(usize, cur_offset) else att_align_nominal(cur_offset, attalign)) {
    return if ((attlen == -@as(c_int, 1)) and (VARATT_NOT_PAD_BYTE(attptr) != 0)) @import("std").zig.c_translation.cast(usize, cur_offset) else att_align_nominal(cur_offset, attalign);
}
pub inline fn att_align_nominal(cur_offset: anytype, attalign: anytype) @TypeOf(if (attalign == TYPALIGN_INT) INTALIGN(cur_offset) else if (attalign == TYPALIGN_CHAR) @import("std").zig.c_translation.cast(usize, cur_offset) else if (attalign == TYPALIGN_DOUBLE) DOUBLEALIGN(cur_offset) else blk_4: {
    _ = AssertMacro(attalign == TYPALIGN_SHORT);
    break :blk_4 SHORTALIGN(cur_offset);
}) {
    return if (attalign == TYPALIGN_INT) INTALIGN(cur_offset) else if (attalign == TYPALIGN_CHAR) @import("std").zig.c_translation.cast(usize, cur_offset) else if (attalign == TYPALIGN_DOUBLE) DOUBLEALIGN(cur_offset) else blk_4: {
        _ = AssertMacro(attalign == TYPALIGN_SHORT);
        break :blk_4 SHORTALIGN(cur_offset);
    };
}
pub inline fn att_addlength_datum(cur_offset: anytype, attlen: anytype, attdatum: anytype) @TypeOf(att_addlength_pointer(cur_offset, attlen, DatumGetPointer(attdatum))) {
    return att_addlength_pointer(cur_offset, attlen, DatumGetPointer(attdatum));
}
pub inline fn att_addlength_pointer(cur_offset: anytype, attlen: anytype, attptr: anytype) @TypeOf(if (attlen > @as(c_int, 0)) cur_offset + attlen else if (attlen == -@as(c_int, 1)) cur_offset + VARSIZE_ANY(attptr) else blk_3: {
    _ = AssertMacro(attlen == -@as(c_int, 2));
    break :blk_3 cur_offset + (strlen(@import("std").zig.c_translation.cast([*c]u8, attptr)) + @as(c_int, 1));
}) {
    return if (attlen > @as(c_int, 0)) cur_offset + attlen else if (attlen == -@as(c_int, 1)) cur_offset + VARSIZE_ANY(attptr) else blk_3: {
        _ = AssertMacro(attlen == -@as(c_int, 2));
        break :blk_3 cur_offset + (strlen(@import("std").zig.c_translation.cast([*c]u8, attptr)) + @as(c_int, 1));
    };
}
pub const BUFPAGE_H = "";
pub const ITEM_H = "";
pub const PD_HAS_FREE_LINES = @as(c_int, 0x0001);
pub const PD_PAGE_FULL = @as(c_int, 0x0002);
pub const PD_ALL_VISIBLE = @as(c_int, 0x0004);
pub const PD_VALID_FLAG_BITS = @as(c_int, 0x0007);
pub const PG_PAGE_LAYOUT_VERSION = @as(c_int, 4);
pub const PG_DATA_CHECKSUM_VERSION = @as(c_int, 1);
pub const PAI_OVERWRITE = @as(c_int, 1) << @as(c_int, 0);
pub const PAI_IS_HEAP = @as(c_int, 1) << @as(c_int, 1);
pub const PIV_LOG_WARNING = @as(c_int, 1) << @as(c_int, 0);
pub const PIV_REPORT_STAT = @as(c_int, 1) << @as(c_int, 1);
pub inline fn PageAddItem(page: anytype, item: anytype, size: anytype, offsetNumber: anytype, overwrite: anytype, is_heap: anytype) @TypeOf(PageAddItemExtended(page, item, size, offsetNumber, (if (overwrite) PAI_OVERWRITE else @as(c_int, 0)) | (if (is_heap) PAI_IS_HEAP else @as(c_int, 0)))) {
    return PageAddItemExtended(page, item, size, offsetNumber, (if (overwrite) PAI_OVERWRITE else @as(c_int, 0)) | (if (is_heap) PAI_IS_HEAP else @as(c_int, 0)));
}
pub inline fn PageIsVerified(page: anytype, blkno: anytype) @TypeOf(PageIsVerifiedExtended(page, blkno, PIV_LOG_WARNING | PIV_REPORT_STAT)) {
    return PageIsVerifiedExtended(page, blkno, PIV_LOG_WARNING | PIV_REPORT_STAT);
}
pub const VARATT_H = "";
pub const VARLENA_EXTSIZE_BITS = @as(c_int, 30);
pub const VARLENA_EXTSIZE_MASK = (@as(c_uint, 1) << VARLENA_EXTSIZE_BITS) - @as(c_int, 1);
pub inline fn VARTAG_IS_EXPANDED(tag: anytype) @TypeOf((tag & ~@as(c_int, 1)) == VARTAG_EXPANDED_RO) {
    return (tag & ~@as(c_int, 1)) == VARTAG_EXPANDED_RO;
}
pub inline fn VARTAG_SIZE(tag: anytype) @TypeOf(if (tag == VARTAG_INDIRECT) @import("std").zig.c_translation.sizeof(varatt_indirect) else if (VARTAG_IS_EXPANDED(tag)) @import("std").zig.c_translation.sizeof(varatt_expanded) else if (tag == VARTAG_ONDISK) @import("std").zig.c_translation.sizeof(varatt_external) else blk_2: {
    _ = AssertMacro(@"false");
    break :blk_2 @as(c_int, 0);
}) {
    return if (tag == VARTAG_INDIRECT) @import("std").zig.c_translation.sizeof(varatt_indirect) else if (VARTAG_IS_EXPANDED(tag)) @import("std").zig.c_translation.sizeof(varatt_expanded) else if (tag == VARTAG_ONDISK) @import("std").zig.c_translation.sizeof(varatt_external) else blk_2: {
        _ = AssertMacro(@"false");
        break :blk_2 @as(c_int, 0);
    };
}
pub inline fn VARATT_IS_4B(PTR: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header & @as(c_int, 0x01)) == @as(c_int, 0x00)) {
    return (@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header & @as(c_int, 0x01)) == @as(c_int, 0x00);
}
pub inline fn VARATT_IS_4B_U(PTR: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header & @as(c_int, 0x03)) == @as(c_int, 0x00)) {
    return (@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header & @as(c_int, 0x03)) == @as(c_int, 0x00);
}
pub inline fn VARATT_IS_4B_C(PTR: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header & @as(c_int, 0x03)) == @as(c_int, 0x02)) {
    return (@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header & @as(c_int, 0x03)) == @as(c_int, 0x02);
}
pub inline fn VARATT_IS_1B(PTR: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header & @as(c_int, 0x01)) == @as(c_int, 0x01)) {
    return (@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header & @as(c_int, 0x01)) == @as(c_int, 0x01);
}
pub inline fn VARATT_IS_1B_E(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header == @as(c_int, 0x01)) {
    return @import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header == @as(c_int, 0x01);
}
pub inline fn VARATT_NOT_PAD_BYTE(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]uint8, PTR).* != @as(c_int, 0)) {
    return @import("std").zig.c_translation.cast([*c]uint8, PTR).* != @as(c_int, 0);
}
pub inline fn VARSIZE_4B(PTR: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_4byte.va_header >> @as(c_int, 2)) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x3FFFFFFF, .hexadecimal)) {
    return (@import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_4byte.va_header >> @as(c_int, 2)) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x3FFFFFFF, .hexadecimal);
}
pub inline fn VARSIZE_1B(PTR: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header >> @as(c_int, 1)) & @as(c_int, 0x7F)) {
    return (@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_header >> @as(c_int, 1)) & @as(c_int, 0x7F);
}
pub inline fn VARTAG_1B_E(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]varattrib_1b_e, PTR).*.va_tag) {
    return @import("std").zig.c_translation.cast([*c]varattrib_1b_e, PTR).*.va_tag;
}
pub inline fn VARDATA_4B(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_4byte.va_data) {
    return @import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_4byte.va_data;
}
pub inline fn VARDATA_4B_C(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_compressed.va_data) {
    return @import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_compressed.va_data;
}
pub inline fn VARDATA_1B(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_data) {
    return @import("std").zig.c_translation.cast([*c]varattrib_1b, PTR).*.va_data;
}
pub inline fn VARDATA_1B_E(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]varattrib_1b_e, PTR).*.va_data) {
    return @import("std").zig.c_translation.cast([*c]varattrib_1b_e, PTR).*.va_data;
}
pub const VARATT_SHORT_MAX = @as(c_int, 0x7F);
pub inline fn VARATT_CAN_MAKE_SHORT(PTR: anytype) @TypeOf((VARATT_IS_4B_U(PTR) != 0) and (((VARSIZE(PTR) - VARHDRSZ) + VARHDRSZ_SHORT) <= VARATT_SHORT_MAX)) {
    return (VARATT_IS_4B_U(PTR) != 0) and (((VARSIZE(PTR) - VARHDRSZ) + VARHDRSZ_SHORT) <= VARATT_SHORT_MAX);
}
pub inline fn VARATT_CONVERTED_SHORT_SIZE(PTR: anytype) @TypeOf((VARSIZE(PTR) - VARHDRSZ) + VARHDRSZ_SHORT) {
    return (VARSIZE(PTR) - VARHDRSZ) + VARHDRSZ_SHORT;
}
pub inline fn VARDATA(PTR: anytype) @TypeOf(VARDATA_4B(PTR)) {
    return VARDATA_4B(PTR);
}
pub inline fn VARSIZE(PTR: anytype) @TypeOf(VARSIZE_4B(PTR)) {
    return VARSIZE_4B(PTR);
}
pub inline fn VARSIZE_SHORT(PTR: anytype) @TypeOf(VARSIZE_1B(PTR)) {
    return VARSIZE_1B(PTR);
}
pub inline fn VARDATA_SHORT(PTR: anytype) @TypeOf(VARDATA_1B(PTR)) {
    return VARDATA_1B(PTR);
}
pub inline fn VARTAG_EXTERNAL(PTR: anytype) @TypeOf(VARTAG_1B_E(PTR)) {
    return VARTAG_1B_E(PTR);
}
pub inline fn VARSIZE_EXTERNAL(PTR: anytype) @TypeOf(VARHDRSZ_EXTERNAL + VARTAG_SIZE(VARTAG_EXTERNAL(PTR))) {
    return VARHDRSZ_EXTERNAL + VARTAG_SIZE(VARTAG_EXTERNAL(PTR));
}
pub inline fn VARDATA_EXTERNAL(PTR: anytype) @TypeOf(VARDATA_1B_E(PTR)) {
    return VARDATA_1B_E(PTR);
}
pub inline fn VARATT_IS_COMPRESSED(PTR: anytype) @TypeOf(VARATT_IS_4B_C(PTR)) {
    return VARATT_IS_4B_C(PTR);
}
pub inline fn VARATT_IS_EXTERNAL(PTR: anytype) @TypeOf(VARATT_IS_1B_E(PTR)) {
    return VARATT_IS_1B_E(PTR);
}
pub inline fn VARATT_IS_EXTERNAL_ONDISK(PTR: anytype) @TypeOf((VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_EXTERNAL(PTR) == VARTAG_ONDISK)) {
    return (VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_EXTERNAL(PTR) == VARTAG_ONDISK);
}
pub inline fn VARATT_IS_EXTERNAL_INDIRECT(PTR: anytype) @TypeOf((VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_EXTERNAL(PTR) == VARTAG_INDIRECT)) {
    return (VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_EXTERNAL(PTR) == VARTAG_INDIRECT);
}
pub inline fn VARATT_IS_EXTERNAL_EXPANDED_RO(PTR: anytype) @TypeOf((VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_EXTERNAL(PTR) == VARTAG_EXPANDED_RO)) {
    return (VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_EXTERNAL(PTR) == VARTAG_EXPANDED_RO);
}
pub inline fn VARATT_IS_EXTERNAL_EXPANDED_RW(PTR: anytype) @TypeOf((VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_EXTERNAL(PTR) == VARTAG_EXPANDED_RW)) {
    return (VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_EXTERNAL(PTR) == VARTAG_EXPANDED_RW);
}
pub inline fn VARATT_IS_EXTERNAL_EXPANDED(PTR: anytype) @TypeOf((VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_IS_EXPANDED(VARTAG_EXTERNAL(PTR)) != 0)) {
    return (VARATT_IS_EXTERNAL(PTR) != 0) and (VARTAG_IS_EXPANDED(VARTAG_EXTERNAL(PTR)) != 0);
}
pub inline fn VARATT_IS_EXTERNAL_NON_EXPANDED(PTR: anytype) @TypeOf((VARATT_IS_EXTERNAL(PTR) != 0) and !(VARTAG_IS_EXPANDED(VARTAG_EXTERNAL(PTR)) != 0)) {
    return (VARATT_IS_EXTERNAL(PTR) != 0) and !(VARTAG_IS_EXPANDED(VARTAG_EXTERNAL(PTR)) != 0);
}
pub inline fn VARATT_IS_SHORT(PTR: anytype) @TypeOf(VARATT_IS_1B(PTR)) {
    return VARATT_IS_1B(PTR);
}
pub inline fn VARATT_IS_EXTENDED(PTR: anytype) @TypeOf(!(VARATT_IS_4B_U(PTR) != 0)) {
    return !(VARATT_IS_4B_U(PTR) != 0);
}
pub inline fn SET_VARSIZE(PTR: anytype, len: anytype) @TypeOf(SET_VARSIZE_4B(PTR, len)) {
    return SET_VARSIZE_4B(PTR, len);
}
pub inline fn SET_VARSIZE_SHORT(PTR: anytype, len: anytype) @TypeOf(SET_VARSIZE_1B(PTR, len)) {
    return SET_VARSIZE_1B(PTR, len);
}
pub inline fn SET_VARSIZE_COMPRESSED(PTR: anytype, len: anytype) @TypeOf(SET_VARSIZE_4B_C(PTR, len)) {
    return SET_VARSIZE_4B_C(PTR, len);
}
pub inline fn SET_VARTAG_EXTERNAL(PTR: anytype, tag: anytype) @TypeOf(SET_VARTAG_1B_E(PTR, tag)) {
    return SET_VARTAG_1B_E(PTR, tag);
}
pub inline fn VARSIZE_ANY(PTR: anytype) @TypeOf(if (VARATT_IS_1B_E(PTR)) VARSIZE_EXTERNAL(PTR) else if (VARATT_IS_1B(PTR)) VARSIZE_1B(PTR) else VARSIZE_4B(PTR)) {
    return if (VARATT_IS_1B_E(PTR)) VARSIZE_EXTERNAL(PTR) else if (VARATT_IS_1B(PTR)) VARSIZE_1B(PTR) else VARSIZE_4B(PTR);
}
pub inline fn VARSIZE_ANY_EXHDR(PTR: anytype) @TypeOf(if (VARATT_IS_1B_E(PTR)) VARSIZE_EXTERNAL(PTR) - VARHDRSZ_EXTERNAL else if (VARATT_IS_1B(PTR)) VARSIZE_1B(PTR) - VARHDRSZ_SHORT else VARSIZE_4B(PTR) - VARHDRSZ) {
    return if (VARATT_IS_1B_E(PTR)) VARSIZE_EXTERNAL(PTR) - VARHDRSZ_EXTERNAL else if (VARATT_IS_1B(PTR)) VARSIZE_1B(PTR) - VARHDRSZ_SHORT else VARSIZE_4B(PTR) - VARHDRSZ;
}
pub inline fn VARDATA_ANY(PTR: anytype) @TypeOf(if (VARATT_IS_1B(PTR)) VARDATA_1B(PTR) else VARDATA_4B(PTR)) {
    return if (VARATT_IS_1B(PTR)) VARDATA_1B(PTR) else VARDATA_4B(PTR);
}
pub inline fn VARDATA_COMPRESSED_GET_EXTSIZE(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_compressed.va_tcinfo & VARLENA_EXTSIZE_MASK) {
    return @import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_compressed.va_tcinfo & VARLENA_EXTSIZE_MASK;
}
pub inline fn VARDATA_COMPRESSED_GET_COMPRESS_METHOD(PTR: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_compressed.va_tcinfo >> VARLENA_EXTSIZE_BITS) {
    return @import("std").zig.c_translation.cast([*c]varattrib_4b, PTR).*.va_compressed.va_tcinfo >> VARLENA_EXTSIZE_BITS;
}
pub inline fn VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer: anytype) @TypeOf(toast_pointer.va_extinfo & VARLENA_EXTSIZE_MASK) {
    return toast_pointer.va_extinfo & VARLENA_EXTSIZE_MASK;
}
pub inline fn VARATT_EXTERNAL_GET_COMPRESS_METHOD(toast_pointer: anytype) @TypeOf(toast_pointer.va_extinfo >> VARLENA_EXTSIZE_BITS) {
    return toast_pointer.va_extinfo >> VARLENA_EXTSIZE_BITS;
}
pub inline fn VARATT_EXTERNAL_IS_COMPRESSED(toast_pointer: anytype) @TypeOf(VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer) < (toast_pointer.va_rawsize - VARHDRSZ)) {
    return VARATT_EXTERNAL_GET_EXTSIZE(toast_pointer) < (toast_pointer.va_rawsize - VARHDRSZ);
}
pub const MaxTupleAttributeNumber = @as(c_int, 1664);
pub const MaxHeapAttributeNumber = @as(c_int, 1600);
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK2 = @as(c_int, 2);
pub const FIELDNO_HEAPTUPLEHEADERDATA_INFOMASK = @as(c_int, 3);
pub const FIELDNO_HEAPTUPLEHEADERDATA_HOFF = @as(c_int, 4);
pub const FIELDNO_HEAPTUPLEHEADERDATA_BITS = @as(c_int, 5);
pub const HEAP_HASNULL = @as(c_int, 0x0001);
pub const HEAP_HASVARWIDTH = @as(c_int, 0x0002);
pub const HEAP_HASEXTERNAL = @as(c_int, 0x0004);
pub const HEAP_HASOID_OLD = @as(c_int, 0x0008);
pub const HEAP_XMAX_KEYSHR_LOCK = @as(c_int, 0x0010);
pub const HEAP_COMBOCID = @as(c_int, 0x0020);
pub const HEAP_XMAX_EXCL_LOCK = @as(c_int, 0x0040);
pub const HEAP_XMAX_LOCK_ONLY = @as(c_int, 0x0080);
pub const HEAP_XMAX_SHR_LOCK = HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK;
pub const HEAP_LOCK_MASK = (HEAP_XMAX_SHR_LOCK | HEAP_XMAX_EXCL_LOCK) | HEAP_XMAX_KEYSHR_LOCK;
pub const HEAP_XMIN_COMMITTED = @as(c_int, 0x0100);
pub const HEAP_XMIN_INVALID = @as(c_int, 0x0200);
pub const HEAP_XMIN_FROZEN = HEAP_XMIN_COMMITTED | HEAP_XMIN_INVALID;
pub const HEAP_XMAX_COMMITTED = @as(c_int, 0x0400);
pub const HEAP_XMAX_INVALID = @as(c_int, 0x0800);
pub const HEAP_XMAX_IS_MULTI = @as(c_int, 0x1000);
pub const HEAP_UPDATED = @as(c_int, 0x2000);
pub const HEAP_MOVED_OFF = @as(c_int, 0x4000);
pub const HEAP_MOVED_IN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hexadecimal);
pub const HEAP_MOVED = HEAP_MOVED_OFF | HEAP_MOVED_IN;
pub const HEAP_XACT_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFF0, .hexadecimal);
pub inline fn HEAP_XMAX_IS_LOCKED_ONLY(infomask: anytype) @TypeOf(((infomask & HEAP_XMAX_LOCK_ONLY) != 0) or ((infomask & (HEAP_XMAX_IS_MULTI | HEAP_LOCK_MASK)) == HEAP_XMAX_EXCL_LOCK)) {
    return ((infomask & HEAP_XMAX_LOCK_ONLY) != 0) or ((infomask & (HEAP_XMAX_IS_MULTI | HEAP_LOCK_MASK)) == HEAP_XMAX_EXCL_LOCK);
}
pub inline fn HEAP_LOCKED_UPGRADED(infomask: anytype) @TypeOf((((infomask & HEAP_XMAX_IS_MULTI) != @as(c_int, 0)) and ((infomask & HEAP_XMAX_LOCK_ONLY) != @as(c_int, 0))) and ((infomask & (HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)) == @as(c_int, 0))) {
    return (((infomask & HEAP_XMAX_IS_MULTI) != @as(c_int, 0)) and ((infomask & HEAP_XMAX_LOCK_ONLY) != @as(c_int, 0))) and ((infomask & (HEAP_XMAX_EXCL_LOCK | HEAP_XMAX_KEYSHR_LOCK)) == @as(c_int, 0));
}
pub inline fn HEAP_XMAX_IS_SHR_LOCKED(infomask: anytype) @TypeOf((infomask & HEAP_LOCK_MASK) == HEAP_XMAX_SHR_LOCK) {
    return (infomask & HEAP_LOCK_MASK) == HEAP_XMAX_SHR_LOCK;
}
pub inline fn HEAP_XMAX_IS_EXCL_LOCKED(infomask: anytype) @TypeOf((infomask & HEAP_LOCK_MASK) == HEAP_XMAX_EXCL_LOCK) {
    return (infomask & HEAP_LOCK_MASK) == HEAP_XMAX_EXCL_LOCK;
}
pub inline fn HEAP_XMAX_IS_KEYSHR_LOCKED(infomask: anytype) @TypeOf((infomask & HEAP_LOCK_MASK) == HEAP_XMAX_KEYSHR_LOCK) {
    return (infomask & HEAP_LOCK_MASK) == HEAP_XMAX_KEYSHR_LOCK;
}
pub const HEAP_XMAX_BITS = (((HEAP_XMAX_COMMITTED | HEAP_XMAX_INVALID) | HEAP_XMAX_IS_MULTI) | HEAP_LOCK_MASK) | HEAP_XMAX_LOCK_ONLY;
pub const HEAP_NATTS_MASK = @as(c_int, 0x07FF);
pub const HEAP_KEYS_UPDATED = @as(c_int, 0x2000);
pub const HEAP_HOT_UPDATED = @as(c_int, 0x4000);
pub const HEAP_ONLY_TUPLE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hexadecimal);
pub const HEAP2_XACT_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xE000, .hexadecimal);
pub const HEAP_TUPLE_HAS_MATCH = HEAP_ONLY_TUPLE;
pub inline fn HeapTupleHeaderGetRawXmin(tup: anytype) @TypeOf(tup.*.t_choice.t_heap.t_xmin) {
    return tup.*.t_choice.t_heap.t_xmin;
}
pub inline fn HeapTupleHeaderGetXmin(tup: anytype) @TypeOf(if (HeapTupleHeaderXminFrozen(tup)) FrozenTransactionId else HeapTupleHeaderGetRawXmin(tup)) {
    return if (HeapTupleHeaderXminFrozen(tup)) FrozenTransactionId else HeapTupleHeaderGetRawXmin(tup);
}
pub inline fn HeapTupleHeaderXminCommitted(tup: anytype) @TypeOf((tup.*.t_infomask & HEAP_XMIN_COMMITTED) != @as(c_int, 0)) {
    return (tup.*.t_infomask & HEAP_XMIN_COMMITTED) != @as(c_int, 0);
}
pub inline fn HeapTupleHeaderXminInvalid(tup: anytype) @TypeOf((tup.*.t_infomask & (HEAP_XMIN_COMMITTED | HEAP_XMIN_INVALID)) == HEAP_XMIN_INVALID) {
    return (tup.*.t_infomask & (HEAP_XMIN_COMMITTED | HEAP_XMIN_INVALID)) == HEAP_XMIN_INVALID;
}
pub inline fn HeapTupleHeaderXminFrozen(tup: anytype) @TypeOf((tup.*.t_infomask & HEAP_XMIN_FROZEN) == HEAP_XMIN_FROZEN) {
    return (tup.*.t_infomask & HEAP_XMIN_FROZEN) == HEAP_XMIN_FROZEN;
}
pub inline fn HeapTupleHeaderGetUpdateXid(tup: anytype) @TypeOf(if ((!((tup.*.t_infomask & HEAP_XMAX_INVALID) != 0) and ((tup.*.t_infomask & HEAP_XMAX_IS_MULTI) != 0)) and !((tup.*.t_infomask & HEAP_XMAX_LOCK_ONLY) != 0)) HeapTupleGetUpdateXid(tup) else HeapTupleHeaderGetRawXmax(tup)) {
    return if ((!((tup.*.t_infomask & HEAP_XMAX_INVALID) != 0) and ((tup.*.t_infomask & HEAP_XMAX_IS_MULTI) != 0)) and !((tup.*.t_infomask & HEAP_XMAX_LOCK_ONLY) != 0)) HeapTupleGetUpdateXid(tup) else HeapTupleHeaderGetRawXmax(tup);
}
pub inline fn HeapTupleHeaderGetRawXmax(tup: anytype) @TypeOf(tup.*.t_choice.t_heap.t_xmax) {
    return tup.*.t_choice.t_heap.t_xmax;
}
pub inline fn HeapTupleHeaderGetRawCommandId(tup: anytype) @TypeOf(tup.*.t_choice.t_heap.t_field3.t_cid) {
    return tup.*.t_choice.t_heap.t_field3.t_cid;
}
pub inline fn HeapTupleHeaderGetXvac(tup: anytype) @TypeOf(if (tup.*.t_infomask & HEAP_MOVED) tup.*.t_choice.t_heap.t_field3.t_xvac else InvalidTransactionId) {
    return if (tup.*.t_infomask & HEAP_MOVED) tup.*.t_choice.t_heap.t_field3.t_xvac else InvalidTransactionId;
}
pub inline fn HeapTupleHeaderIsSpeculative(tup: anytype) @TypeOf(ItemPointerGetOffsetNumberNoCheck(&tup.*.t_ctid) == SpecTokenOffsetNumber) {
    return ItemPointerGetOffsetNumberNoCheck(&tup.*.t_ctid) == SpecTokenOffsetNumber;
}
pub inline fn HeapTupleHeaderGetSpeculativeToken(tup: anytype) @TypeOf(ItemPointerGetBlockNumber(&tup.*.t_ctid)) {
    return blk_1: {
        _ = AssertMacro(HeapTupleHeaderIsSpeculative(tup));
        break :blk_1 ItemPointerGetBlockNumber(&tup.*.t_ctid);
    };
}
pub inline fn HeapTupleHeaderSetSpeculativeToken(tup: anytype, token: anytype) @TypeOf(ItemPointerSet(&tup.*.t_ctid, token, SpecTokenOffsetNumber)) {
    return ItemPointerSet(&tup.*.t_ctid, token, SpecTokenOffsetNumber);
}
pub inline fn HeapTupleHeaderIndicatesMovedPartitions(tup: anytype) @TypeOf(ItemPointerIndicatesMovedPartitions(&tup.*.t_ctid)) {
    return ItemPointerIndicatesMovedPartitions(&tup.*.t_ctid);
}
pub inline fn HeapTupleHeaderSetMovedPartitions(tup: anytype) @TypeOf(ItemPointerSetMovedPartitions(&tup.*.t_ctid)) {
    return ItemPointerSetMovedPartitions(&tup.*.t_ctid);
}
pub inline fn HeapTupleHeaderGetDatumLength(tup: anytype) @TypeOf(VARSIZE(tup)) {
    return VARSIZE(tup);
}
pub inline fn HeapTupleHeaderSetDatumLength(tup: anytype, len: anytype) @TypeOf(SET_VARSIZE(tup, len)) {
    return SET_VARSIZE(tup, len);
}
pub inline fn HeapTupleHeaderGetTypeId(tup: anytype) @TypeOf(tup.*.t_choice.t_datum.datum_typeid) {
    return tup.*.t_choice.t_datum.datum_typeid;
}
pub inline fn HeapTupleHeaderGetTypMod(tup: anytype) @TypeOf(tup.*.t_choice.t_datum.datum_typmod) {
    return tup.*.t_choice.t_datum.datum_typmod;
}
pub inline fn HeapTupleHeaderIsHotUpdated(tup: anytype) @TypeOf((((tup.*.t_infomask2 & HEAP_HOT_UPDATED) != @as(c_int, 0)) and ((tup.*.t_infomask & HEAP_XMAX_INVALID) == @as(c_int, 0))) and !(HeapTupleHeaderXminInvalid(tup) != 0)) {
    return (((tup.*.t_infomask2 & HEAP_HOT_UPDATED) != @as(c_int, 0)) and ((tup.*.t_infomask & HEAP_XMAX_INVALID) == @as(c_int, 0))) and !(HeapTupleHeaderXminInvalid(tup) != 0);
}
pub inline fn HeapTupleHeaderIsHeapOnly(tup: anytype) @TypeOf((tup.*.t_infomask2 & HEAP_ONLY_TUPLE) != @as(c_int, 0)) {
    return (tup.*.t_infomask2 & HEAP_ONLY_TUPLE) != @as(c_int, 0);
}
pub inline fn HeapTupleHeaderHasMatch(tup: anytype) @TypeOf((tup.*.t_infomask2 & HEAP_TUPLE_HAS_MATCH) != @as(c_int, 0)) {
    return (tup.*.t_infomask2 & HEAP_TUPLE_HAS_MATCH) != @as(c_int, 0);
}
pub inline fn HeapTupleHeaderGetNatts(tup: anytype) @TypeOf(tup.*.t_infomask2 & HEAP_NATTS_MASK) {
    return tup.*.t_infomask2 & HEAP_NATTS_MASK;
}
pub inline fn HeapTupleHeaderHasExternal(tup: anytype) @TypeOf((tup.*.t_infomask & HEAP_HASEXTERNAL) != @as(c_int, 0)) {
    return (tup.*.t_infomask & HEAP_HASEXTERNAL) != @as(c_int, 0);
}
pub inline fn BITMAPLEN(NATTS: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(@import("std").zig.c_translation.cast(c_int, NATTS) + @as(c_int, 7), @as(c_int, 8))) {
    return @import("std").zig.c_translation.MacroArithmetic.div(@import("std").zig.c_translation.cast(c_int, NATTS) + @as(c_int, 7), @as(c_int, 8));
}
pub const MaxHeapTupleSize = BLCKSZ - MAXALIGN(SizeOfPageHeaderData + @import("std").zig.c_translation.sizeof(ItemIdData));
pub const MinHeapTupleSize = MAXALIGN(SizeofHeapTupleHeader);
pub const MaxHeapTuplesPerPage = @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.MacroArithmetic.div(BLCKSZ - SizeOfPageHeaderData, MAXALIGN(SizeofHeapTupleHeader) + @import("std").zig.c_translation.sizeof(ItemIdData)));
pub const MaxAttrSize = (@as(c_int, 10) * @as(c_int, 1024)) * @as(c_int, 1024);
pub inline fn GETSTRUCT(TUP: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]u8, TUP.*.t_data) + TUP.*.t_data.*.t_hoff) {
    return @import("std").zig.c_translation.cast([*c]u8, TUP.*.t_data) + TUP.*.t_data.*.t_hoff;
}
pub inline fn HeapTupleHasNulls(tuple: anytype) @TypeOf((tuple.*.t_data.*.t_infomask & HEAP_HASNULL) != @as(c_int, 0)) {
    return (tuple.*.t_data.*.t_infomask & HEAP_HASNULL) != @as(c_int, 0);
}
pub inline fn HeapTupleNoNulls(tuple: anytype) @TypeOf(!((tuple.*.t_data.*.t_infomask & HEAP_HASNULL) != 0)) {
    return !((tuple.*.t_data.*.t_infomask & HEAP_HASNULL) != 0);
}
pub inline fn HeapTupleHasVarWidth(tuple: anytype) @TypeOf((tuple.*.t_data.*.t_infomask & HEAP_HASVARWIDTH) != @as(c_int, 0)) {
    return (tuple.*.t_data.*.t_infomask & HEAP_HASVARWIDTH) != @as(c_int, 0);
}
pub inline fn HeapTupleAllFixed(tuple: anytype) @TypeOf(!((tuple.*.t_data.*.t_infomask & HEAP_HASVARWIDTH) != 0)) {
    return !((tuple.*.t_data.*.t_infomask & HEAP_HASVARWIDTH) != 0);
}
pub inline fn HeapTupleHasExternal(tuple: anytype) @TypeOf((tuple.*.t_data.*.t_infomask & HEAP_HASEXTERNAL) != @as(c_int, 0)) {
    return (tuple.*.t_data.*.t_infomask & HEAP_HASEXTERNAL) != @as(c_int, 0);
}
pub inline fn HeapTupleIsHotUpdated(tuple: anytype) @TypeOf(HeapTupleHeaderIsHotUpdated(tuple.*.t_data)) {
    return HeapTupleHeaderIsHotUpdated(tuple.*.t_data);
}
pub inline fn HeapTupleSetHotUpdated(tuple: anytype) @TypeOf(HeapTupleHeaderSetHotUpdated(tuple.*.t_data)) {
    return HeapTupleHeaderSetHotUpdated(tuple.*.t_data);
}
pub inline fn HeapTupleClearHotUpdated(tuple: anytype) @TypeOf(HeapTupleHeaderClearHotUpdated(tuple.*.t_data)) {
    return HeapTupleHeaderClearHotUpdated(tuple.*.t_data);
}
pub inline fn HeapTupleIsHeapOnly(tuple: anytype) @TypeOf(HeapTupleHeaderIsHeapOnly(tuple.*.t_data)) {
    return HeapTupleHeaderIsHeapOnly(tuple.*.t_data);
}
pub inline fn HeapTupleSetHeapOnly(tuple: anytype) @TypeOf(HeapTupleHeaderSetHeapOnly(tuple.*.t_data)) {
    return HeapTupleHeaderSetHeapOnly(tuple.*.t_data);
}
pub inline fn HeapTupleClearHeapOnly(tuple: anytype) @TypeOf(HeapTupleHeaderClearHeapOnly(tuple.*.t_data)) {
    return HeapTupleHeaderClearHeapOnly(tuple.*.t_data);
}
pub const ILIST_H = "";
pub inline fn dlist_member_check(head: anytype, node: anytype) anyopaque {
    _ = @TypeOf(node);
    return @import("std").zig.c_translation.cast(anyopaque, head);
}
pub const dlist_check = @import("std").zig.c_translation.Macros.DISCARD;
pub const slist_check = @import("std").zig.c_translation.Macros.DISCARD;
pub inline fn dclist_container(@"type": anytype, membername: anytype, ptr: anytype) @TypeOf(dlist_container(@"type", membername, ptr)) {
    return dlist_container(@"type", membername, ptr);
}
pub inline fn dclist_foreach(iter: anytype, lhead: anytype) @TypeOf(dlist_foreach(iter, &lhead.*.dlist)) {
    return dlist_foreach(iter, &lhead.*.dlist);
}
pub inline fn dclist_foreach_modify(iter: anytype, lhead: anytype) @TypeOf(dlist_foreach_modify(iter, &lhead.*.dlist)) {
    return dlist_foreach_modify(iter, &lhead.*.dlist);
}
pub inline fn dclist_reverse_foreach(iter: anytype, lhead: anytype) @TypeOf(dlist_reverse_foreach(iter, &lhead.*.dlist)) {
    return dlist_reverse_foreach(iter, &lhead.*.dlist);
}
pub const SINVAL_H = "";
pub const _SIGNAL_H = "";
pub const _BITS_SIGNUM_GENERIC_H = @as(c_int, 1);
pub const SIG_ERR = @import("std").zig.c_translation.cast(__sighandler_t, -@as(c_int, 1));
pub const SIG_DFL = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 0));
pub const SIG_IGN = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 1));
pub const SIGINT = @as(c_int, 2);
pub const SIGILL = @as(c_int, 4);
pub const SIGABRT = @as(c_int, 6);
pub const SIGFPE = @as(c_int, 8);
pub const SIGSEGV = @as(c_int, 11);
pub const SIGTERM = @as(c_int, 15);
pub const SIGHUP = @as(c_int, 1);
pub const SIGQUIT = @as(c_int, 3);
pub const SIGTRAP = @as(c_int, 5);
pub const SIGKILL = @as(c_int, 9);
pub const SIGPIPE = @as(c_int, 13);
pub const SIGALRM = @as(c_int, 14);
pub const SIGIO = SIGPOLL;
pub const SIGIOT = SIGABRT;
pub const SIGCLD = SIGCHLD;
pub const _BITS_SIGNUM_ARCH_H = @as(c_int, 1);
pub const SIGSTKFLT = @as(c_int, 16);
pub const SIGPWR = @as(c_int, 30);
pub const SIGBUS = @as(c_int, 7);
pub const SIGSYS = @as(c_int, 31);
pub const SIGURG = @as(c_int, 23);
pub const SIGSTOP = @as(c_int, 19);
pub const SIGTSTP = @as(c_int, 20);
pub const SIGCONT = @as(c_int, 18);
pub const SIGCHLD = @as(c_int, 17);
pub const SIGTTIN = @as(c_int, 21);
pub const SIGTTOU = @as(c_int, 22);
pub const SIGPOLL = @as(c_int, 29);
pub const SIGXFSZ = @as(c_int, 25);
pub const SIGXCPU = @as(c_int, 24);
pub const SIGVTALRM = @as(c_int, 26);
pub const SIGPROF = @as(c_int, 27);
pub const SIGUSR1 = @as(c_int, 10);
pub const SIGUSR2 = @as(c_int, 12);
pub const SIGWINCH = @as(c_int, 28);
pub const __SIGRTMIN = @as(c_int, 32);
pub const __SIGRTMAX = @as(c_int, 64);
pub const _NSIG = __SIGRTMAX + @as(c_int, 1);
pub const __sig_atomic_t_defined = @as(c_int, 1);
pub const __siginfo_t_defined = @as(c_int, 1);
pub const ____sigval_t_defined = "";
pub const __SI_MAX_SIZE = @as(c_int, 128);
pub const __SI_PAD_SIZE = @import("std").zig.c_translation.MacroArithmetic.div(__SI_MAX_SIZE, @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const _BITS_SIGINFO_ARCH_H = @as(c_int, 1);
pub const __SI_ALIGNMENT = "";
pub const __SI_BAND_TYPE = c_long;
pub const __SI_CLOCK_T = __clock_t;
pub const __SI_ERRNO_THEN_CODE = @as(c_int, 1);
pub const __SI_HAVE_SIGSYS = @as(c_int, 1);
pub const __SI_SIGFAULT_ADDL = "";
pub const _BITS_SIGINFO_CONSTS_H = @as(c_int, 1);
pub const __SI_ASYNCIO_AFTER_SIGIO = @as(c_int, 1);
pub const __sigval_t_defined = "";
pub const __sigevent_t_defined = @as(c_int, 1);
pub const __SIGEV_MAX_SIZE = @as(c_int, 64);
pub const __SIGEV_PAD_SIZE = @import("std").zig.c_translation.MacroArithmetic.div(__SIGEV_MAX_SIZE, @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const _BITS_SIGEVENT_CONSTS_H = @as(c_int, 1);
pub inline fn sigmask(sig: anytype) @TypeOf(__glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))))) {
    return __glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))));
}
pub const NSIG = _NSIG;
pub const _BITS_SIGACTION_H = @as(c_int, 1);
pub const SA_NOCLDSTOP = @as(c_int, 1);
pub const SA_NOCLDWAIT = @as(c_int, 2);
pub const SA_SIGINFO = @as(c_int, 4);
pub const SA_ONSTACK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hexadecimal);
pub const SA_RESTART = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hexadecimal);
pub const SA_NODEFER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hexadecimal);
pub const SA_RESETHAND = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal);
pub const SA_INTERRUPT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hexadecimal);
pub const SA_NOMASK = SA_NODEFER;
pub const SA_ONESHOT = SA_RESETHAND;
pub const SA_STACK = SA_ONSTACK;
pub const SIG_BLOCK = @as(c_int, 0);
pub const SIG_UNBLOCK = @as(c_int, 1);
pub const SIG_SETMASK = @as(c_int, 2);
pub const _BITS_SIGCONTEXT_H = @as(c_int, 1);
pub const FP_XSTATE_MAGIC1 = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x46505853, .hexadecimal);
pub const FP_XSTATE_MAGIC2 = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x46505845, .hexadecimal);
pub const FP_XSTATE_MAGIC2_SIZE = @import("std").zig.c_translation.sizeof(FP_XSTATE_MAGIC2);
pub const __stack_t_defined = @as(c_int, 1);
pub const _SYS_UCONTEXT_H = @as(c_int, 1);
pub inline fn __ctx(fld: anytype) @TypeOf(fld) {
    return fld;
}
pub const __NGREG = @as(c_int, 23);
pub const NGREG = __NGREG;
pub const _BITS_SIGSTACK_H = @as(c_int, 1);
pub const MINSIGSTKSZ = @as(c_int, 2048);
pub const SIGSTKSZ = @as(c_int, 8192);
pub const _BITS_SS_FLAGS_H = @as(c_int, 1);
pub const __sigstack_defined = @as(c_int, 1);
pub const _BITS_SIGTHREAD_H = @as(c_int, 1);
pub const SIGRTMIN = __libc_current_sigrtmin();
pub const SIGRTMAX = __libc_current_sigrtmax();
pub const SHAREDINVALCATALOG_ID = -@as(c_int, 1);
pub const SHAREDINVALRELCACHE_ID = -@as(c_int, 2);
pub const SHAREDINVALSMGR_ID = -@as(c_int, 3);
pub const SHAREDINVALRELMAP_ID = -@as(c_int, 4);
pub const SHAREDINVALSNAPSHOT_ID = -@as(c_int, 5);
pub const HSEARCH_H = "";
pub const HASH_PARTITION = @as(c_int, 0x0001);
pub const HASH_SEGMENT = @as(c_int, 0x0002);
pub const HASH_DIRSIZE = @as(c_int, 0x0004);
pub const HASH_ELEM = @as(c_int, 0x0008);
pub const HASH_STRINGS = @as(c_int, 0x0010);
pub const HASH_BLOBS = @as(c_int, 0x0020);
pub const HASH_FUNCTION = @as(c_int, 0x0040);
pub const HASH_COMPARE = @as(c_int, 0x0080);
pub const HASH_KEYCOPY = @as(c_int, 0x0100);
pub const HASH_ALLOC = @as(c_int, 0x0200);
pub const HASH_CONTEXT = @as(c_int, 0x0400);
pub const HASH_SHARED_MEM = @as(c_int, 0x0800);
pub const HASH_ATTACH = @as(c_int, 0x1000);
pub const HASH_FIXED_SIZE = @as(c_int, 0x2000);
pub const NO_MAX_DSIZE = -@as(c_int, 1);
pub const SNAPSHOT_H = "";
pub const PAIRINGHEAP_H = "";
pub inline fn pairingheap_is_empty(h: anytype) @TypeOf(h.*.ph_root == NULL) {
    return h.*.ph_root == NULL;
}
pub inline fn pairingheap_is_singular(h: anytype) @TypeOf((h.*.ph_root != 0) and (h.*.ph_root.*.first_child == NULL)) {
    return (h.*.ph_root != 0) and (h.*.ph_root.*.first_child == NULL);
}
pub const InvalidSnapshot = @import("std").zig.c_translation.cast(Snapshot, NULL);
pub const TIMESTAMP_H = "";
pub const FMGR_H = "";
pub const FIELDNO_FUNCTIONCALLINFODATA_ISNULL = @as(c_int, 4);
pub const FIELDNO_FUNCTIONCALLINFODATA_ARGS = @as(c_int, 6);
pub inline fn FunctionCallInvoke(fcinfo: anytype) @TypeOf(fcinfo.*.flinfo.*.fn_addr.*(fcinfo)) {
    return fcinfo.*.flinfo.*.fn_addr.*(fcinfo);
}
pub inline fn PG_DETOAST_DATUM(datum: anytype) @TypeOf(pg_detoast_datum(@import("std").zig.c_translation.cast([*c]struct_varlena, DatumGetPointer(datum)))) {
    return pg_detoast_datum(@import("std").zig.c_translation.cast([*c]struct_varlena, DatumGetPointer(datum)));
}
pub inline fn PG_DETOAST_DATUM_COPY(datum: anytype) @TypeOf(pg_detoast_datum_copy(@import("std").zig.c_translation.cast([*c]struct_varlena, DatumGetPointer(datum)))) {
    return pg_detoast_datum_copy(@import("std").zig.c_translation.cast([*c]struct_varlena, DatumGetPointer(datum)));
}
pub inline fn PG_DETOAST_DATUM_SLICE(datum: anytype, f: anytype, c: anytype) @TypeOf(pg_detoast_datum_slice(@import("std").zig.c_translation.cast([*c]struct_varlena, DatumGetPointer(datum)), @import("std").zig.c_translation.cast(int32, f), @import("std").zig.c_translation.cast(int32, c))) {
    return pg_detoast_datum_slice(@import("std").zig.c_translation.cast([*c]struct_varlena, DatumGetPointer(datum)), @import("std").zig.c_translation.cast(int32, f), @import("std").zig.c_translation.cast(int32, c));
}
pub inline fn PG_DETOAST_DATUM_PACKED(datum: anytype) @TypeOf(pg_detoast_datum_packed(@import("std").zig.c_translation.cast([*c]struct_varlena, DatumGetPointer(datum)))) {
    return pg_detoast_datum_packed(@import("std").zig.c_translation.cast([*c]struct_varlena, DatumGetPointer(datum)));
}
pub inline fn PG_GETARG_INT32(n: anytype) @TypeOf(DatumGetInt32(PG_GETARG_DATUM(n))) {
    return DatumGetInt32(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_UINT32(n: anytype) @TypeOf(DatumGetUInt32(PG_GETARG_DATUM(n))) {
    return DatumGetUInt32(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_INT16(n: anytype) @TypeOf(DatumGetInt16(PG_GETARG_DATUM(n))) {
    return DatumGetInt16(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_UINT16(n: anytype) @TypeOf(DatumGetUInt16(PG_GETARG_DATUM(n))) {
    return DatumGetUInt16(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_CHAR(n: anytype) @TypeOf(DatumGetChar(PG_GETARG_DATUM(n))) {
    return DatumGetChar(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_BOOL(n: anytype) @TypeOf(DatumGetBool(PG_GETARG_DATUM(n))) {
    return DatumGetBool(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_OID(n: anytype) @TypeOf(DatumGetObjectId(PG_GETARG_DATUM(n))) {
    return DatumGetObjectId(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_POINTER(n: anytype) @TypeOf(DatumGetPointer(PG_GETARG_DATUM(n))) {
    return DatumGetPointer(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_CSTRING(n: anytype) @TypeOf(DatumGetCString(PG_GETARG_DATUM(n))) {
    return DatumGetCString(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_NAME(n: anytype) @TypeOf(DatumGetName(PG_GETARG_DATUM(n))) {
    return DatumGetName(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_TRANSACTIONID(n: anytype) @TypeOf(DatumGetTransactionId(PG_GETARG_DATUM(n))) {
    return DatumGetTransactionId(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_FLOAT4(n: anytype) @TypeOf(DatumGetFloat4(PG_GETARG_DATUM(n))) {
    return DatumGetFloat4(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_FLOAT8(n: anytype) @TypeOf(DatumGetFloat8(PG_GETARG_DATUM(n))) {
    return DatumGetFloat8(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_INT64(n: anytype) @TypeOf(DatumGetInt64(PG_GETARG_DATUM(n))) {
    return DatumGetInt64(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_RAW_VARLENA_P(n: anytype) [*c]struct_varlena {
    return @import("std").zig.c_translation.cast([*c]struct_varlena, PG_GETARG_POINTER(n));
}
pub inline fn PG_GETARG_VARLENA_P(n: anytype) @TypeOf(PG_DETOAST_DATUM(PG_GETARG_DATUM(n))) {
    return PG_DETOAST_DATUM(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_VARLENA_PP(n: anytype) @TypeOf(PG_DETOAST_DATUM_PACKED(PG_GETARG_DATUM(n))) {
    return PG_DETOAST_DATUM_PACKED(PG_GETARG_DATUM(n));
}
pub inline fn DatumGetByteaPP(X: anytype) [*c]bytea {
    return @import("std").zig.c_translation.cast([*c]bytea, PG_DETOAST_DATUM_PACKED(X));
}
pub inline fn DatumGetTextPP(X: anytype) [*c]text {
    return @import("std").zig.c_translation.cast([*c]text, PG_DETOAST_DATUM_PACKED(X));
}
pub inline fn DatumGetBpCharPP(X: anytype) [*c]BpChar {
    return @import("std").zig.c_translation.cast([*c]BpChar, PG_DETOAST_DATUM_PACKED(X));
}
pub inline fn DatumGetVarCharPP(X: anytype) [*c]VarChar {
    return @import("std").zig.c_translation.cast([*c]VarChar, PG_DETOAST_DATUM_PACKED(X));
}
pub inline fn DatumGetHeapTupleHeader(X: anytype) HeapTupleHeader {
    return @import("std").zig.c_translation.cast(HeapTupleHeader, PG_DETOAST_DATUM(X));
}
pub inline fn DatumGetByteaPCopy(X: anytype) [*c]bytea {
    return @import("std").zig.c_translation.cast([*c]bytea, PG_DETOAST_DATUM_COPY(X));
}
pub inline fn DatumGetTextPCopy(X: anytype) [*c]text {
    return @import("std").zig.c_translation.cast([*c]text, PG_DETOAST_DATUM_COPY(X));
}
pub inline fn DatumGetBpCharPCopy(X: anytype) [*c]BpChar {
    return @import("std").zig.c_translation.cast([*c]BpChar, PG_DETOAST_DATUM_COPY(X));
}
pub inline fn DatumGetVarCharPCopy(X: anytype) [*c]VarChar {
    return @import("std").zig.c_translation.cast([*c]VarChar, PG_DETOAST_DATUM_COPY(X));
}
pub inline fn DatumGetHeapTupleHeaderCopy(X: anytype) HeapTupleHeader {
    return @import("std").zig.c_translation.cast(HeapTupleHeader, PG_DETOAST_DATUM_COPY(X));
}
pub inline fn DatumGetByteaPSlice(X: anytype, m: anytype, n: anytype) [*c]bytea {
    return @import("std").zig.c_translation.cast([*c]bytea, PG_DETOAST_DATUM_SLICE(X, m, n));
}
pub inline fn DatumGetTextPSlice(X: anytype, m: anytype, n: anytype) [*c]text {
    return @import("std").zig.c_translation.cast([*c]text, PG_DETOAST_DATUM_SLICE(X, m, n));
}
pub inline fn DatumGetBpCharPSlice(X: anytype, m: anytype, n: anytype) [*c]BpChar {
    return @import("std").zig.c_translation.cast([*c]BpChar, PG_DETOAST_DATUM_SLICE(X, m, n));
}
pub inline fn DatumGetVarCharPSlice(X: anytype, m: anytype, n: anytype) [*c]VarChar {
    return @import("std").zig.c_translation.cast([*c]VarChar, PG_DETOAST_DATUM_SLICE(X, m, n));
}
pub inline fn PG_GETARG_BYTEA_PP(n: anytype) @TypeOf(DatumGetByteaPP(PG_GETARG_DATUM(n))) {
    return DatumGetByteaPP(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_TEXT_PP(n: anytype) @TypeOf(DatumGetTextPP(PG_GETARG_DATUM(n))) {
    return DatumGetTextPP(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_BPCHAR_PP(n: anytype) @TypeOf(DatumGetBpCharPP(PG_GETARG_DATUM(n))) {
    return DatumGetBpCharPP(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_VARCHAR_PP(n: anytype) @TypeOf(DatumGetVarCharPP(PG_GETARG_DATUM(n))) {
    return DatumGetVarCharPP(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_HEAPTUPLEHEADER(n: anytype) @TypeOf(DatumGetHeapTupleHeader(PG_GETARG_DATUM(n))) {
    return DatumGetHeapTupleHeader(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_BYTEA_P_COPY(n: anytype) @TypeOf(DatumGetByteaPCopy(PG_GETARG_DATUM(n))) {
    return DatumGetByteaPCopy(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_TEXT_P_COPY(n: anytype) @TypeOf(DatumGetTextPCopy(PG_GETARG_DATUM(n))) {
    return DatumGetTextPCopy(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_BPCHAR_P_COPY(n: anytype) @TypeOf(DatumGetBpCharPCopy(PG_GETARG_DATUM(n))) {
    return DatumGetBpCharPCopy(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_VARCHAR_P_COPY(n: anytype) @TypeOf(DatumGetVarCharPCopy(PG_GETARG_DATUM(n))) {
    return DatumGetVarCharPCopy(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_HEAPTUPLEHEADER_COPY(n: anytype) @TypeOf(DatumGetHeapTupleHeaderCopy(PG_GETARG_DATUM(n))) {
    return DatumGetHeapTupleHeaderCopy(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_BYTEA_P_SLICE(n: anytype, a: anytype, b: anytype) @TypeOf(DatumGetByteaPSlice(PG_GETARG_DATUM(n), a, b)) {
    return DatumGetByteaPSlice(PG_GETARG_DATUM(n), a, b);
}
pub inline fn PG_GETARG_TEXT_P_SLICE(n: anytype, a: anytype, b: anytype) @TypeOf(DatumGetTextPSlice(PG_GETARG_DATUM(n), a, b)) {
    return DatumGetTextPSlice(PG_GETARG_DATUM(n), a, b);
}
pub inline fn PG_GETARG_BPCHAR_P_SLICE(n: anytype, a: anytype, b: anytype) @TypeOf(DatumGetBpCharPSlice(PG_GETARG_DATUM(n), a, b)) {
    return DatumGetBpCharPSlice(PG_GETARG_DATUM(n), a, b);
}
pub inline fn PG_GETARG_VARCHAR_P_SLICE(n: anytype, a: anytype, b: anytype) @TypeOf(DatumGetVarCharPSlice(PG_GETARG_DATUM(n), a, b)) {
    return DatumGetVarCharPSlice(PG_GETARG_DATUM(n), a, b);
}
pub inline fn DatumGetByteaP(X: anytype) [*c]bytea {
    return @import("std").zig.c_translation.cast([*c]bytea, PG_DETOAST_DATUM(X));
}
pub inline fn DatumGetTextP(X: anytype) [*c]text {
    return @import("std").zig.c_translation.cast([*c]text, PG_DETOAST_DATUM(X));
}
pub inline fn DatumGetBpCharP(X: anytype) [*c]BpChar {
    return @import("std").zig.c_translation.cast([*c]BpChar, PG_DETOAST_DATUM(X));
}
pub inline fn DatumGetVarCharP(X: anytype) [*c]VarChar {
    return @import("std").zig.c_translation.cast([*c]VarChar, PG_DETOAST_DATUM(X));
}
pub inline fn PG_GETARG_BYTEA_P(n: anytype) @TypeOf(DatumGetByteaP(PG_GETARG_DATUM(n))) {
    return DatumGetByteaP(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_TEXT_P(n: anytype) @TypeOf(DatumGetTextP(PG_GETARG_DATUM(n))) {
    return DatumGetTextP(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_BPCHAR_P(n: anytype) @TypeOf(DatumGetBpCharP(PG_GETARG_DATUM(n))) {
    return DatumGetBpCharP(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_VARCHAR_P(n: anytype) @TypeOf(DatumGetVarCharP(PG_GETARG_DATUM(n))) {
    return DatumGetVarCharP(PG_GETARG_DATUM(n));
}
pub inline fn PG_RETURN_BYTEA_P(x: anytype) @TypeOf(PG_RETURN_POINTER(x)) {
    return PG_RETURN_POINTER(x);
}
pub inline fn PG_RETURN_TEXT_P(x: anytype) @TypeOf(PG_RETURN_POINTER(x)) {
    return PG_RETURN_POINTER(x);
}
pub inline fn PG_RETURN_BPCHAR_P(x: anytype) @TypeOf(PG_RETURN_POINTER(x)) {
    return PG_RETURN_POINTER(x);
}
pub inline fn PG_RETURN_VARCHAR_P(x: anytype) @TypeOf(PG_RETURN_POINTER(x)) {
    return PG_RETURN_POINTER(x);
}
pub const PG_MAGIC_FUNCTION_NAME = Pg_magic_func;
pub const PG_MAGIC_FUNCTION_NAME_STRING = "Pg_magic_func";
pub inline fn DirectFunctionCall1(func: anytype, arg1: anytype) @TypeOf(DirectFunctionCall1Coll(func, InvalidOid, arg1)) {
    return DirectFunctionCall1Coll(func, InvalidOid, arg1);
}
pub inline fn DirectFunctionCall2(func: anytype, arg1: anytype, arg2: anytype) @TypeOf(DirectFunctionCall2Coll(func, InvalidOid, arg1, arg2)) {
    return DirectFunctionCall2Coll(func, InvalidOid, arg1, arg2);
}
pub inline fn DirectFunctionCall3(func: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(DirectFunctionCall3Coll(func, InvalidOid, arg1, arg2, arg3)) {
    return DirectFunctionCall3Coll(func, InvalidOid, arg1, arg2, arg3);
}
pub inline fn DirectFunctionCall4(func: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(DirectFunctionCall4Coll(func, InvalidOid, arg1, arg2, arg3, arg4)) {
    return DirectFunctionCall4Coll(func, InvalidOid, arg1, arg2, arg3, arg4);
}
pub inline fn DirectFunctionCall5(func: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(DirectFunctionCall5Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5)) {
    return DirectFunctionCall5Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5);
}
pub inline fn DirectFunctionCall6(func: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(DirectFunctionCall6Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6)) {
    return DirectFunctionCall6Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6);
}
pub inline fn DirectFunctionCall7(func: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(DirectFunctionCall7Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7)) {
    return DirectFunctionCall7Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
}
pub inline fn DirectFunctionCall8(func: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(DirectFunctionCall8Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)) {
    return DirectFunctionCall8Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
}
pub inline fn DirectFunctionCall9(func: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype, arg9: anytype) @TypeOf(DirectFunctionCall9Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)) {
    return DirectFunctionCall9Coll(func, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
}
pub inline fn FunctionCall1(flinfo: anytype, arg1: anytype) @TypeOf(FunctionCall1Coll(flinfo, InvalidOid, arg1)) {
    return FunctionCall1Coll(flinfo, InvalidOid, arg1);
}
pub inline fn FunctionCall2(flinfo: anytype, arg1: anytype, arg2: anytype) @TypeOf(FunctionCall2Coll(flinfo, InvalidOid, arg1, arg2)) {
    return FunctionCall2Coll(flinfo, InvalidOid, arg1, arg2);
}
pub inline fn FunctionCall3(flinfo: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(FunctionCall3Coll(flinfo, InvalidOid, arg1, arg2, arg3)) {
    return FunctionCall3Coll(flinfo, InvalidOid, arg1, arg2, arg3);
}
pub inline fn FunctionCall4(flinfo: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(FunctionCall4Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4)) {
    return FunctionCall4Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4);
}
pub inline fn FunctionCall5(flinfo: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(FunctionCall5Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5)) {
    return FunctionCall5Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5);
}
pub inline fn FunctionCall6(flinfo: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(FunctionCall6Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6)) {
    return FunctionCall6Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6);
}
pub inline fn FunctionCall7(flinfo: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(FunctionCall7Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7)) {
    return FunctionCall7Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
}
pub inline fn FunctionCall8(flinfo: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(FunctionCall8Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)) {
    return FunctionCall8Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
}
pub inline fn FunctionCall9(flinfo: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype, arg9: anytype) @TypeOf(FunctionCall9Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)) {
    return FunctionCall9Coll(flinfo, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
}
pub inline fn OidFunctionCall0(functionId: anytype) @TypeOf(OidFunctionCall0Coll(functionId, InvalidOid)) {
    return OidFunctionCall0Coll(functionId, InvalidOid);
}
pub inline fn OidFunctionCall1(functionId: anytype, arg1: anytype) @TypeOf(OidFunctionCall1Coll(functionId, InvalidOid, arg1)) {
    return OidFunctionCall1Coll(functionId, InvalidOid, arg1);
}
pub inline fn OidFunctionCall2(functionId: anytype, arg1: anytype, arg2: anytype) @TypeOf(OidFunctionCall2Coll(functionId, InvalidOid, arg1, arg2)) {
    return OidFunctionCall2Coll(functionId, InvalidOid, arg1, arg2);
}
pub inline fn OidFunctionCall3(functionId: anytype, arg1: anytype, arg2: anytype, arg3: anytype) @TypeOf(OidFunctionCall3Coll(functionId, InvalidOid, arg1, arg2, arg3)) {
    return OidFunctionCall3Coll(functionId, InvalidOid, arg1, arg2, arg3);
}
pub inline fn OidFunctionCall4(functionId: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype) @TypeOf(OidFunctionCall4Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4)) {
    return OidFunctionCall4Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4);
}
pub inline fn OidFunctionCall5(functionId: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype) @TypeOf(OidFunctionCall5Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5)) {
    return OidFunctionCall5Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5);
}
pub inline fn OidFunctionCall6(functionId: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype) @TypeOf(OidFunctionCall6Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6)) {
    return OidFunctionCall6Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6);
}
pub inline fn OidFunctionCall7(functionId: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype) @TypeOf(OidFunctionCall7Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7)) {
    return OidFunctionCall7Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
}
pub inline fn OidFunctionCall8(functionId: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype) @TypeOf(OidFunctionCall8Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)) {
    return OidFunctionCall8Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
}
pub inline fn OidFunctionCall9(functionId: anytype, arg1: anytype, arg2: anytype, arg3: anytype, arg4: anytype, arg5: anytype, arg6: anytype, arg7: anytype, arg8: anytype, arg9: anytype) @TypeOf(OidFunctionCall9Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)) {
    return OidFunctionCall9Coll(functionId, InvalidOid, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
}
pub const AGG_CONTEXT_AGGREGATE = @as(c_int, 1);
pub const AGG_CONTEXT_WINDOW = @as(c_int, 2);
pub inline fn FmgrHookIsNeeded(fn_oid: anytype) @TypeOf(if (!(needs_fmgr_hook != 0)) @"false" else needs_fmgr_hook.*(fn_oid)) {
    return if (!(needs_fmgr_hook != 0)) @"false" else needs_fmgr_hook.*(fn_oid);
}
pub inline fn PG_GETARG_TIMESTAMP(n: anytype) @TypeOf(DatumGetTimestamp(PG_GETARG_DATUM(n))) {
    return DatumGetTimestamp(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_TIMESTAMPTZ(n: anytype) @TypeOf(DatumGetTimestampTz(PG_GETARG_DATUM(n))) {
    return DatumGetTimestampTz(PG_GETARG_DATUM(n));
}
pub inline fn PG_GETARG_INTERVAL_P(n: anytype) @TypeOf(DatumGetIntervalP(PG_GETARG_DATUM(n))) {
    return DatumGetIntervalP(PG_GETARG_DATUM(n));
}
pub inline fn TIMESTAMP_MASK(b: anytype) @TypeOf(@as(c_int, 1) << b) {
    return @as(c_int, 1) << b;
}
pub inline fn INTERVAL_MASK(b: anytype) @TypeOf(@as(c_int, 1) << b) {
    return @as(c_int, 1) << b;
}
pub const INTERVAL_FULL_RANGE = @as(c_int, 0x7FFF);
pub const INTERVAL_RANGE_MASK = @as(c_int, 0x7FFF);
pub const INTERVAL_FULL_PRECISION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFF, .hexadecimal);
pub const INTERVAL_PRECISION_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFF, .hexadecimal);
pub inline fn INTERVAL_TYPMOD(p: anytype, r: anytype) @TypeOf(((r & INTERVAL_RANGE_MASK) << @as(c_int, 16)) | (p & INTERVAL_PRECISION_MASK)) {
    return ((r & INTERVAL_RANGE_MASK) << @as(c_int, 16)) | (p & INTERVAL_PRECISION_MASK);
}
pub inline fn INTERVAL_PRECISION(t: anytype) @TypeOf(t & INTERVAL_PRECISION_MASK) {
    return t & INTERVAL_PRECISION_MASK;
}
pub inline fn INTERVAL_RANGE(t: anytype) @TypeOf((t >> @as(c_int, 16)) & INTERVAL_RANGE_MASK) {
    return (t >> @as(c_int, 16)) & INTERVAL_RANGE_MASK;
}
pub inline fn TimestampTzPlusMilliseconds(tz: anytype, ms: anytype) @TypeOf(tz + (ms * @import("std").zig.c_translation.cast(int64, @as(c_int, 1000)))) {
    return tz + (ms * @import("std").zig.c_translation.cast(int64, @as(c_int, 1000)));
}
pub inline fn TimestampTzPlusSeconds(tz: anytype, s: anytype) @TypeOf(tz + (s * @import("std").zig.c_translation.cast(int64, @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal)))) {
    return tz + (s * @import("std").zig.c_translation.cast(int64, @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal)));
}
pub inline fn timestamptz_cmp_internal(dt1: anytype, dt2: anytype) @TypeOf(timestamp_cmp_internal(dt1, dt2)) {
    return timestamp_cmp_internal(dt1, dt2);
}
pub inline fn ReorderBufferTupleBufData(p: anytype) HeapTupleHeader {
    return @import("std").zig.c_translation.cast(HeapTupleHeader, MAXALIGN(@import("std").zig.c_translation.cast([*c]u8, p) + @import("std").zig.c_translation.sizeof(ReorderBufferTupleBuf)));
}
pub const RBTXN_HAS_CATALOG_CHANGES = @as(c_int, 0x0001);
pub const RBTXN_IS_SUBXACT = @as(c_int, 0x0002);
pub const RBTXN_IS_SERIALIZED = @as(c_int, 0x0004);
pub const RBTXN_IS_SERIALIZED_CLEAR = @as(c_int, 0x0008);
pub const RBTXN_IS_STREAMED = @as(c_int, 0x0010);
pub const RBTXN_HAS_PARTIAL_CHANGE = @as(c_int, 0x0020);
pub const RBTXN_PREPARE = @as(c_int, 0x0040);
pub const RBTXN_SKIPPED_PREPARE = @as(c_int, 0x0080);
pub const RBTXN_HAS_STREAMABLE_CHANGE = @as(c_int, 0x0100);
pub inline fn rbtxn_has_catalog_changes(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_HAS_CATALOG_CHANGES) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_HAS_CATALOG_CHANGES) != @as(c_int, 0);
}
pub inline fn rbtxn_is_known_subxact(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_IS_SUBXACT) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_IS_SUBXACT) != @as(c_int, 0);
}
pub inline fn rbtxn_is_serialized(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_IS_SERIALIZED) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_IS_SERIALIZED) != @as(c_int, 0);
}
pub inline fn rbtxn_is_serialized_clear(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_IS_SERIALIZED_CLEAR) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_IS_SERIALIZED_CLEAR) != @as(c_int, 0);
}
pub inline fn rbtxn_has_partial_change(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_HAS_PARTIAL_CHANGE) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_HAS_PARTIAL_CHANGE) != @as(c_int, 0);
}
pub inline fn rbtxn_has_streamable_change(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_HAS_STREAMABLE_CHANGE) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_HAS_STREAMABLE_CHANGE) != @as(c_int, 0);
}
pub inline fn rbtxn_is_streamed(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_IS_STREAMED) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_IS_STREAMED) != @as(c_int, 0);
}
pub inline fn rbtxn_prepared(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_PREPARE) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_PREPARE) != @as(c_int, 0);
}
pub inline fn rbtxn_skip_prepared(txn: anytype) @TypeOf((txn.*.txn_flags & RBTXN_SKIPPED_PREPARE) != @as(c_int, 0)) {
    return (txn.*.txn_flags & RBTXN_SKIPPED_PREPARE) != @as(c_int, 0);
}
pub inline fn rbtxn_is_toptxn(txn: anytype) @TypeOf(txn.*.toptxn == NULL) {
    return txn.*.toptxn == NULL;
}
pub inline fn rbtxn_is_subtxn(txn: anytype) @TypeOf(txn.*.toptxn != NULL) {
    return txn.*.toptxn != NULL;
}
pub inline fn rbtxn_get_toptxn(txn: anytype) @TypeOf(if (rbtxn_is_subtxn(txn)) txn.*.toptxn else txn) {
    return if (rbtxn_is_subtxn(txn)) txn.*.toptxn else txn;
}
pub const SLOT_H = "";
pub const CONDITION_VARIABLE_H = "";
pub const PROCLIST_TYPES_H = "";
pub const SPIN_H = "";
pub const S_LOCK_H = "";
pub const HAS_TEST_AND_SET = "";
pub inline fn TAS(lock: anytype) @TypeOf(tas(lock)) {
    return tas(lock);
}
pub inline fn TAS_SPIN(lock: anytype) @TypeOf(if (lock.*) @as(c_int, 1) else TAS(lock)) {
    return if (lock.*) @as(c_int, 1) else TAS(lock);
}
pub inline fn SPIN_DELAY() @TypeOf(spin_delay()) {
    return spin_delay();
}
pub inline fn S_LOCK_FREE(lock: anytype) @TypeOf(lock.* == @as(c_int, 0)) {
    return lock.* == @as(c_int, 0);
}
pub inline fn S_INIT_LOCK(lock: anytype) @TypeOf(S_UNLOCK(lock)) {
    return S_UNLOCK(lock);
}
pub const DEFAULT_SPINS_PER_DELAY = @as(c_int, 100);
pub inline fn SpinLockInit(lock: anytype) @TypeOf(S_INIT_LOCK(lock)) {
    return S_INIT_LOCK(lock);
}
pub inline fn SpinLockAcquire(lock: anytype) @TypeOf(S_LOCK(lock)) {
    return S_LOCK(lock);
}
pub inline fn SpinLockRelease(lock: anytype) @TypeOf(S_UNLOCK(lock)) {
    return S_UNLOCK(lock);
}
pub inline fn SpinLockFree(lock: anytype) @TypeOf(S_LOCK_FREE(lock)) {
    return S_LOCK_FREE(lock);
}
pub const CV_MINIMAL_SIZE = if (@import("std").zig.c_translation.sizeof(ConditionVariable) <= @as(c_int, 16)) @as(c_int, 16) else @as(c_int, 32);
pub const LWLOCK_H = "";
pub const ATOMICS_H = "";
pub const INSIDE_ATOMICS_H = "";
pub const __CLANG_LIMITS_H = "";
pub const _GCC_LIMITS_H_ = "";
pub const _LIBC_LIMITS_H_ = @as(c_int, 1);
pub const MB_LEN_MAX = @as(c_int, 16);
pub const LLONG_MIN = -LLONG_MAX - @as(c_int, 1);
pub const LLONG_MAX = __LONG_LONG_MAX__;
pub const ULLONG_MAX = (LLONG_MAX * @as(c_ulonglong, 2)) + @as(c_int, 1);
pub const _BITS_POSIX1_LIM_H = @as(c_int, 1);
pub const _POSIX_AIO_LISTIO_MAX = @as(c_int, 2);
pub const _POSIX_AIO_MAX = @as(c_int, 1);
pub const _POSIX_ARG_MAX = @as(c_int, 4096);
pub const _POSIX_CHILD_MAX = @as(c_int, 25);
pub const _POSIX_DELAYTIMER_MAX = @as(c_int, 32);
pub const _POSIX_HOST_NAME_MAX = @as(c_int, 255);
pub const _POSIX_LINK_MAX = @as(c_int, 8);
pub const _POSIX_LOGIN_NAME_MAX = @as(c_int, 9);
pub const _POSIX_MAX_CANON = @as(c_int, 255);
pub const _POSIX_MAX_INPUT = @as(c_int, 255);
pub const _POSIX_MQ_OPEN_MAX = @as(c_int, 8);
pub const _POSIX_MQ_PRIO_MAX = @as(c_int, 32);
pub const _POSIX_NAME_MAX = @as(c_int, 14);
pub const _POSIX_NGROUPS_MAX = @as(c_int, 8);
pub const _POSIX_OPEN_MAX = @as(c_int, 20);
pub const _POSIX_PATH_MAX = @as(c_int, 256);
pub const _POSIX_PIPE_BUF = @as(c_int, 512);
pub const _POSIX_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX_RTSIG_MAX = @as(c_int, 8);
pub const _POSIX_SEM_NSEMS_MAX = @as(c_int, 256);
pub const _POSIX_SEM_VALUE_MAX = @as(c_int, 32767);
pub const _POSIX_SIGQUEUE_MAX = @as(c_int, 32);
pub const _POSIX_SSIZE_MAX = @as(c_int, 32767);
pub const _POSIX_STREAM_MAX = @as(c_int, 8);
pub const _POSIX_SYMLINK_MAX = @as(c_int, 255);
pub const _POSIX_SYMLOOP_MAX = @as(c_int, 8);
pub const _POSIX_TIMER_MAX = @as(c_int, 32);
pub const _POSIX_TTY_NAME_MAX = @as(c_int, 9);
pub const _POSIX_TZNAME_MAX = @as(c_int, 6);
pub const _POSIX_CLOCKRES_MIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 20000000, .decimal);
pub const __undef_NR_OPEN = "";
pub const __undef_LINK_MAX = "";
pub const __undef_OPEN_MAX = "";
pub const __undef_ARG_MAX = "";
pub const _LINUX_LIMITS_H = "";
pub const NR_OPEN = @as(c_int, 1024);
pub const NGROUPS_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const ARG_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 131072, .decimal);
pub const LINK_MAX = @as(c_int, 127);
pub const MAX_CANON = @as(c_int, 255);
pub const MAX_INPUT = @as(c_int, 255);
pub const NAME_MAX = @as(c_int, 255);
pub const PATH_MAX = @as(c_int, 4096);
pub const PIPE_BUF = @as(c_int, 4096);
pub const XATTR_NAME_MAX = @as(c_int, 255);
pub const XATTR_SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const XATTR_LIST_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const RTSIG_MAX = @as(c_int, 32);
pub const _POSIX_THREAD_KEYS_MAX = @as(c_int, 128);
pub const PTHREAD_KEYS_MAX = @as(c_int, 1024);
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS = @as(c_int, 4);
pub const PTHREAD_DESTRUCTOR_ITERATIONS = _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
pub const _POSIX_THREAD_THREADS_MAX = @as(c_int, 64);
pub const AIO_PRIO_DELTA_MAX = @as(c_int, 20);
pub const PTHREAD_STACK_MIN = @as(c_int, 16384);
pub const DELAYTIMER_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const TTY_NAME_MAX = @as(c_int, 32);
pub const LOGIN_NAME_MAX = @as(c_int, 256);
pub const HOST_NAME_MAX = @as(c_int, 64);
pub const MQ_PRIO_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const SEM_VALUE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SSIZE_MAX = LONG_MAX;
pub const _BITS_POSIX2_LIM_H = @as(c_int, 1);
pub const _POSIX2_BC_BASE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_DIM_MAX = @as(c_int, 2048);
pub const _POSIX2_BC_SCALE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_STRING_MAX = @as(c_int, 1000);
pub const _POSIX2_COLL_WEIGHTS_MAX = @as(c_int, 2);
pub const _POSIX2_EXPR_NEST_MAX = @as(c_int, 32);
pub const _POSIX2_LINE_MAX = @as(c_int, 2048);
pub const _POSIX2_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX2_CHARCLASS_NAME_MAX = @as(c_int, 14);
pub const BC_BASE_MAX = _POSIX2_BC_BASE_MAX;
pub const BC_DIM_MAX = _POSIX2_BC_DIM_MAX;
pub const BC_SCALE_MAX = _POSIX2_BC_SCALE_MAX;
pub const BC_STRING_MAX = _POSIX2_BC_STRING_MAX;
pub const COLL_WEIGHTS_MAX = @as(c_int, 255);
pub const EXPR_NEST_MAX = _POSIX2_EXPR_NEST_MAX;
pub const LINE_MAX = _POSIX2_LINE_MAX;
pub const CHARCLASS_NAME_MAX = @as(c_int, 2048);
pub const RE_DUP_MAX = @as(c_int, 0x7fff);
pub const SCHAR_MAX = __SCHAR_MAX__;
pub const SHRT_MAX = __SHRT_MAX__;
pub const INT_MAX = __INT_MAX__;
pub const LONG_MAX = __LONG_MAX__;
pub const SCHAR_MIN = -__SCHAR_MAX__ - @as(c_int, 1);
pub const SHRT_MIN = -__SHRT_MAX__ - @as(c_int, 1);
pub const INT_MIN = -__INT_MAX__ - @as(c_int, 1);
pub const LONG_MIN = -__LONG_MAX__ - @as(c_long, 1);
pub const UCHAR_MAX = (__SCHAR_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const USHRT_MAX = (__SHRT_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const UINT_MAX = (__INT_MAX__ * @as(c_uint, 2)) + @as(c_uint, 1);
pub const ULONG_MAX = (__LONG_MAX__ * @as(c_ulong, 2)) + @as(c_ulong, 1);
pub const CHAR_BIT = __CHAR_BIT__;
pub const CHAR_MIN = SCHAR_MIN;
pub const CHAR_MAX = __SCHAR_MAX__;
pub inline fn pg_read_barrier_impl() @TypeOf(pg_compiler_barrier_impl()) {
    return pg_compiler_barrier_impl();
}
pub inline fn pg_write_barrier_impl() @TypeOf(pg_compiler_barrier_impl()) {
    return pg_compiler_barrier_impl();
}
pub const PG_HAVE_ATOMIC_FLAG_SUPPORT = "";
pub const PG_HAVE_ATOMIC_U32_SUPPORT = "";
pub const PG_HAVE_ATOMIC_U64_SUPPORT = "";
pub const PG_HAVE_SPIN_DELAY = "";
pub const PG_HAVE_ATOMIC_TEST_SET_FLAG = "";
pub const PG_HAVE_ATOMIC_CLEAR_FLAG = "";
pub const PG_HAVE_ATOMIC_COMPARE_EXCHANGE_U32 = "";
pub const PG_HAVE_ATOMIC_FETCH_ADD_U32 = "";
pub const PG_HAVE_ATOMIC_COMPARE_EXCHANGE_U64 = "";
pub const PG_HAVE_ATOMIC_FETCH_ADD_U64 = "";
pub const PG_HAVE_8BYTE_SINGLE_COPY_ATOMICITY = "";
pub const PG_HAVE_ATOMIC_UNLOCKED_TEST_FLAG = "";
pub const PG_HAVE_ATOMIC_INIT_FLAG = "";
pub const PG_HAVE_ATOMIC_FETCH_SUB_U32 = "";
pub const PG_HAVE_ATOMIC_FETCH_AND_U32 = "";
pub const PG_HAVE_ATOMIC_FETCH_OR_U32 = "";
pub const PG_HAVE_ATOMIC_FETCH_SUB_U64 = "";
pub const PG_HAVE_ATOMIC_FETCH_AND_U64 = "";
pub const PG_HAVE_ATOMIC_FETCH_OR_U64 = "";
pub const PG_HAVE_ATOMIC_READ_U32 = "";
pub const PG_HAVE_ATOMIC_WRITE_U32 = "";
pub const PG_HAVE_ATOMIC_UNLOCKED_WRITE_U32 = "";
pub const PG_HAVE_ATOMIC_INIT_U32 = "";
pub const PG_HAVE_ATOMIC_EXCHANGE_U32 = "";
pub const PG_HAVE_ATOMIC_ADD_FETCH_U32 = "";
pub const PG_HAVE_ATOMIC_SUB_FETCH_U32 = "";
pub const PG_HAVE_ATOMIC_EXCHANGE_U64 = "";
pub const PG_HAVE_ATOMIC_WRITE_U64 = "";
pub const PG_HAVE_ATOMIC_READ_U64 = "";
pub const PG_HAVE_ATOMIC_INIT_U64 = "";
pub const PG_HAVE_ATOMIC_ADD_FETCH_U64 = "";
pub const PG_HAVE_ATOMIC_SUB_FETCH_U64 = "";
pub inline fn pg_compiler_barrier() @TypeOf(pg_compiler_barrier_impl()) {
    return pg_compiler_barrier_impl();
}
pub inline fn pg_memory_barrier() @TypeOf(pg_memory_barrier_impl()) {
    return pg_memory_barrier_impl();
}
pub inline fn pg_read_barrier() @TypeOf(pg_read_barrier_impl()) {
    return pg_read_barrier_impl();
}
pub inline fn pg_write_barrier() @TypeOf(pg_write_barrier_impl()) {
    return pg_write_barrier_impl();
}
pub inline fn pg_spin_delay() @TypeOf(pg_spin_delay_impl()) {
    return pg_spin_delay_impl();
}
pub const LWLOCK_PADDED_SIZE = PG_CACHE_LINE_SIZE;
pub const ShmemIndexLock = &MainLWLockArray[@intCast(usize, @as(c_int, 1))].lock;
pub const OidGenLock = &MainLWLockArray[@intCast(usize, @as(c_int, 2))].lock;
pub const XidGenLock = &MainLWLockArray[@intCast(usize, @as(c_int, 3))].lock;
pub const ProcArrayLock = &MainLWLockArray[@intCast(usize, @as(c_int, 4))].lock;
pub const SInvalReadLock = &MainLWLockArray[@intCast(usize, @as(c_int, 5))].lock;
pub const SInvalWriteLock = &MainLWLockArray[@intCast(usize, @as(c_int, 6))].lock;
pub const WALBufMappingLock = &MainLWLockArray[@intCast(usize, @as(c_int, 7))].lock;
pub const WALWriteLock = &MainLWLockArray[@intCast(usize, @as(c_int, 8))].lock;
pub const ControlFileLock = &MainLWLockArray[@intCast(usize, @as(c_int, 9))].lock;
pub const XactSLRULock = &MainLWLockArray[@intCast(usize, @as(c_int, 11))].lock;
pub const SubtransSLRULock = &MainLWLockArray[@intCast(usize, @as(c_int, 12))].lock;
pub const MultiXactGenLock = &MainLWLockArray[@intCast(usize, @as(c_int, 13))].lock;
pub const MultiXactOffsetSLRULock = &MainLWLockArray[@intCast(usize, @as(c_int, 14))].lock;
pub const MultiXactMemberSLRULock = &MainLWLockArray[@intCast(usize, @as(c_int, 15))].lock;
pub const RelCacheInitLock = &MainLWLockArray[@intCast(usize, @as(c_int, 16))].lock;
pub const CheckpointerCommLock = &MainLWLockArray[@intCast(usize, @as(c_int, 17))].lock;
pub const TwoPhaseStateLock = &MainLWLockArray[@intCast(usize, @as(c_int, 18))].lock;
pub const TablespaceCreateLock = &MainLWLockArray[@intCast(usize, @as(c_int, 19))].lock;
pub const BtreeVacuumLock = &MainLWLockArray[@intCast(usize, @as(c_int, 20))].lock;
pub const AddinShmemInitLock = &MainLWLockArray[@intCast(usize, @as(c_int, 21))].lock;
pub const AutovacuumLock = &MainLWLockArray[@intCast(usize, @as(c_int, 22))].lock;
pub const AutovacuumScheduleLock = &MainLWLockArray[@intCast(usize, @as(c_int, 23))].lock;
pub const SyncScanLock = &MainLWLockArray[@intCast(usize, @as(c_int, 24))].lock;
pub const RelationMappingLock = &MainLWLockArray[@intCast(usize, @as(c_int, 25))].lock;
pub const NotifySLRULock = &MainLWLockArray[@intCast(usize, @as(c_int, 26))].lock;
pub const NotifyQueueLock = &MainLWLockArray[@intCast(usize, @as(c_int, 27))].lock;
pub const SerializableXactHashLock = &MainLWLockArray[@intCast(usize, @as(c_int, 28))].lock;
pub const SerializableFinishedListLock = &MainLWLockArray[@intCast(usize, @as(c_int, 29))].lock;
pub const SerializablePredicateListLock = &MainLWLockArray[@intCast(usize, @as(c_int, 30))].lock;
pub const SerialSLRULock = &MainLWLockArray[@intCast(usize, @as(c_int, 31))].lock;
pub const SyncRepLock = &MainLWLockArray[@intCast(usize, @as(c_int, 32))].lock;
pub const BackgroundWorkerLock = &MainLWLockArray[@intCast(usize, @as(c_int, 33))].lock;
pub const DynamicSharedMemoryControlLock = &MainLWLockArray[@intCast(usize, @as(c_int, 34))].lock;
pub const AutoFileLock = &MainLWLockArray[@intCast(usize, @as(c_int, 35))].lock;
pub const ReplicationSlotAllocationLock = &MainLWLockArray[@intCast(usize, @as(c_int, 36))].lock;
pub const ReplicationSlotControlLock = &MainLWLockArray[@intCast(usize, @as(c_int, 37))].lock;
pub const CommitTsSLRULock = &MainLWLockArray[@intCast(usize, @as(c_int, 38))].lock;
pub const CommitTsLock = &MainLWLockArray[@intCast(usize, @as(c_int, 39))].lock;
pub const ReplicationOriginLock = &MainLWLockArray[@intCast(usize, @as(c_int, 40))].lock;
pub const MultiXactTruncationLock = &MainLWLockArray[@intCast(usize, @as(c_int, 41))].lock;
pub const OldSnapshotTimeMapLock = &MainLWLockArray[@intCast(usize, @as(c_int, 42))].lock;
pub const LogicalRepWorkerLock = &MainLWLockArray[@intCast(usize, @as(c_int, 43))].lock;
pub const XactTruncationLock = &MainLWLockArray[@intCast(usize, @as(c_int, 44))].lock;
pub const WrapLimitsVacuumLock = &MainLWLockArray[@intCast(usize, @as(c_int, 46))].lock;
pub const NotifyQueueTailLock = &MainLWLockArray[@intCast(usize, @as(c_int, 47))].lock;
pub const NUM_INDIVIDUAL_LWLOCKS = @as(c_int, 48);
pub const NUM_BUFFER_PARTITIONS = @as(c_int, 128);
pub const LOG2_NUM_LOCK_PARTITIONS = @as(c_int, 4);
pub const NUM_LOCK_PARTITIONS = @as(c_int, 1) << LOG2_NUM_LOCK_PARTITIONS;
pub const LOG2_NUM_PREDICATELOCK_PARTITIONS = @as(c_int, 4);
pub const NUM_PREDICATELOCK_PARTITIONS = @as(c_int, 1) << LOG2_NUM_PREDICATELOCK_PARTITIONS;
pub const BUFFER_MAPPING_LWLOCK_OFFSET = NUM_INDIVIDUAL_LWLOCKS;
pub const LOCK_MANAGER_LWLOCK_OFFSET = BUFFER_MAPPING_LWLOCK_OFFSET + NUM_BUFFER_PARTITIONS;
pub const PREDICATELOCK_MANAGER_LWLOCK_OFFSET = LOCK_MANAGER_LWLOCK_OFFSET + NUM_LOCK_PARTITIONS;
pub const NUM_FIXED_LWLOCKS = PREDICATELOCK_MANAGER_LWLOCK_OFFSET + NUM_PREDICATELOCK_PARTITIONS;
pub const SHMEM_H = "";
pub const SHMEM_INDEX_KEYSIZE = @as(c_int, 48);
pub const SHMEM_INDEX_SIZE = @as(c_int, 64);
pub const _WALRECEIVER_H = "";
pub const _NETDB_H = @as(c_int, 1);
pub const _NETINET_IN_H = @as(c_int, 1);
pub const _SYS_SOCKET_H = @as(c_int, 1);
pub const __iovec_defined = @as(c_int, 1);
pub const __BITS_SOCKET_H = "";
pub const __socklen_t_defined = "";
pub const PF_UNSPEC = @as(c_int, 0);
pub const PF_LOCAL = @as(c_int, 1);
pub const PF_UNIX = PF_LOCAL;
pub const PF_FILE = PF_LOCAL;
pub const PF_INET = @as(c_int, 2);
pub const PF_AX25 = @as(c_int, 3);
pub const PF_IPX = @as(c_int, 4);
pub const PF_APPLETALK = @as(c_int, 5);
pub const PF_NETROM = @as(c_int, 6);
pub const PF_BRIDGE = @as(c_int, 7);
pub const PF_ATMPVC = @as(c_int, 8);
pub const PF_X25 = @as(c_int, 9);
pub const PF_INET6 = @as(c_int, 10);
pub const PF_ROSE = @as(c_int, 11);
pub const PF_DECnet = @as(c_int, 12);
pub const PF_NETBEUI = @as(c_int, 13);
pub const PF_SECURITY = @as(c_int, 14);
pub const PF_KEY = @as(c_int, 15);
pub const PF_NETLINK = @as(c_int, 16);
pub const PF_ROUTE = PF_NETLINK;
pub const PF_PACKET = @as(c_int, 17);
pub const PF_ASH = @as(c_int, 18);
pub const PF_ECONET = @as(c_int, 19);
pub const PF_ATMSVC = @as(c_int, 20);
pub const PF_RDS = @as(c_int, 21);
pub const PF_SNA = @as(c_int, 22);
pub const PF_IRDA = @as(c_int, 23);
pub const PF_PPPOX = @as(c_int, 24);
pub const PF_WANPIPE = @as(c_int, 25);
pub const PF_LLC = @as(c_int, 26);
pub const PF_IB = @as(c_int, 27);
pub const PF_MPLS = @as(c_int, 28);
pub const PF_CAN = @as(c_int, 29);
pub const PF_TIPC = @as(c_int, 30);
pub const PF_BLUETOOTH = @as(c_int, 31);
pub const PF_IUCV = @as(c_int, 32);
pub const PF_RXRPC = @as(c_int, 33);
pub const PF_ISDN = @as(c_int, 34);
pub const PF_PHONET = @as(c_int, 35);
pub const PF_IEEE802154 = @as(c_int, 36);
pub const PF_CAIF = @as(c_int, 37);
pub const PF_ALG = @as(c_int, 38);
pub const PF_NFC = @as(c_int, 39);
pub const PF_VSOCK = @as(c_int, 40);
pub const PF_KCM = @as(c_int, 41);
pub const PF_QIPCRTR = @as(c_int, 42);
pub const PF_SMC = @as(c_int, 43);
pub const PF_XDP = @as(c_int, 44);
pub const PF_MCTP = @as(c_int, 45);
pub const PF_MAX = @as(c_int, 46);
pub const AF_UNSPEC = PF_UNSPEC;
pub const AF_LOCAL = PF_LOCAL;
pub const AF_UNIX = PF_UNIX;
pub const AF_FILE = PF_FILE;
pub const AF_INET = PF_INET;
pub const AF_AX25 = PF_AX25;
pub const AF_IPX = PF_IPX;
pub const AF_APPLETALK = PF_APPLETALK;
pub const AF_NETROM = PF_NETROM;
pub const AF_BRIDGE = PF_BRIDGE;
pub const AF_ATMPVC = PF_ATMPVC;
pub const AF_X25 = PF_X25;
pub const AF_INET6 = PF_INET6;
pub const AF_ROSE = PF_ROSE;
pub const AF_DECnet = PF_DECnet;
pub const AF_NETBEUI = PF_NETBEUI;
pub const AF_SECURITY = PF_SECURITY;
pub const AF_KEY = PF_KEY;
pub const AF_NETLINK = PF_NETLINK;
pub const AF_ROUTE = PF_ROUTE;
pub const AF_PACKET = PF_PACKET;
pub const AF_ASH = PF_ASH;
pub const AF_ECONET = PF_ECONET;
pub const AF_ATMSVC = PF_ATMSVC;
pub const AF_RDS = PF_RDS;
pub const AF_SNA = PF_SNA;
pub const AF_IRDA = PF_IRDA;
pub const AF_PPPOX = PF_PPPOX;
pub const AF_WANPIPE = PF_WANPIPE;
pub const AF_LLC = PF_LLC;
pub const AF_IB = PF_IB;
pub const AF_MPLS = PF_MPLS;
pub const AF_CAN = PF_CAN;
pub const AF_TIPC = PF_TIPC;
pub const AF_BLUETOOTH = PF_BLUETOOTH;
pub const AF_IUCV = PF_IUCV;
pub const AF_RXRPC = PF_RXRPC;
pub const AF_ISDN = PF_ISDN;
pub const AF_PHONET = PF_PHONET;
pub const AF_IEEE802154 = PF_IEEE802154;
pub const AF_CAIF = PF_CAIF;
pub const AF_ALG = PF_ALG;
pub const AF_NFC = PF_NFC;
pub const AF_VSOCK = PF_VSOCK;
pub const AF_KCM = PF_KCM;
pub const AF_QIPCRTR = PF_QIPCRTR;
pub const AF_SMC = PF_SMC;
pub const AF_XDP = PF_XDP;
pub const AF_MCTP = PF_MCTP;
pub const AF_MAX = PF_MAX;
pub const SOL_RAW = @as(c_int, 255);
pub const SOL_DECNET = @as(c_int, 261);
pub const SOL_X25 = @as(c_int, 262);
pub const SOL_PACKET = @as(c_int, 263);
pub const SOL_ATM = @as(c_int, 264);
pub const SOL_AAL = @as(c_int, 265);
pub const SOL_IRDA = @as(c_int, 266);
pub const SOL_NETBEUI = @as(c_int, 267);
pub const SOL_LLC = @as(c_int, 268);
pub const SOL_DCCP = @as(c_int, 269);
pub const SOL_NETLINK = @as(c_int, 270);
pub const SOL_TIPC = @as(c_int, 271);
pub const SOL_RXRPC = @as(c_int, 272);
pub const SOL_PPPOL2TP = @as(c_int, 273);
pub const SOL_BLUETOOTH = @as(c_int, 274);
pub const SOL_PNPIPE = @as(c_int, 275);
pub const SOL_RDS = @as(c_int, 276);
pub const SOL_IUCV = @as(c_int, 277);
pub const SOL_CAIF = @as(c_int, 278);
pub const SOL_ALG = @as(c_int, 279);
pub const SOL_NFC = @as(c_int, 280);
pub const SOL_KCM = @as(c_int, 281);
pub const SOL_TLS = @as(c_int, 282);
pub const SOL_XDP = @as(c_int, 283);
pub const SOL_MPTCP = @as(c_int, 284);
pub const SOL_MCTP = @as(c_int, 285);
pub const SOL_SMC = @as(c_int, 286);
pub const SOMAXCONN = @as(c_int, 4096);
pub const _BITS_SOCKADDR_H = @as(c_int, 1);
pub const __SOCKADDR_COMMON_SIZE = @import("std").zig.c_translation.sizeof(c_ushort);
pub const _SS_SIZE = @as(c_int, 128);
pub const __ss_aligntype = c_ulong;
pub const _SS_PADSIZE = (_SS_SIZE - __SOCKADDR_COMMON_SIZE) - @import("std").zig.c_translation.sizeof(__ss_aligntype);
pub inline fn CMSG_DATA(cmsg: anytype) @TypeOf(cmsg.*.__cmsg_data) {
    return cmsg.*.__cmsg_data;
}
pub inline fn CMSG_NXTHDR(mhdr: anytype, cmsg: anytype) @TypeOf(__cmsg_nxthdr(mhdr, cmsg)) {
    return __cmsg_nxthdr(mhdr, cmsg);
}
pub inline fn CMSG_FIRSTHDR(mhdr: anytype) @TypeOf(if (@import("std").zig.c_translation.cast(usize, mhdr.*.msg_controllen) >= @import("std").zig.c_translation.sizeof(struct_cmsghdr)) @import("std").zig.c_translation.cast([*c]struct_cmsghdr, mhdr.*.msg_control) else @import("std").zig.c_translation.cast([*c]struct_cmsghdr, @as(c_int, 0))) {
    return if (@import("std").zig.c_translation.cast(usize, mhdr.*.msg_controllen) >= @import("std").zig.c_translation.sizeof(struct_cmsghdr)) @import("std").zig.c_translation.cast([*c]struct_cmsghdr, mhdr.*.msg_control) else @import("std").zig.c_translation.cast([*c]struct_cmsghdr, @as(c_int, 0));
}
pub inline fn CMSG_ALIGN(len: anytype) @TypeOf(((len + @import("std").zig.c_translation.sizeof(usize)) - @as(c_int, 1)) & @import("std").zig.c_translation.cast(usize, ~(@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) {
    return ((len + @import("std").zig.c_translation.sizeof(usize)) - @as(c_int, 1)) & @import("std").zig.c_translation.cast(usize, ~(@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)));
}
pub inline fn CMSG_SPACE(len: anytype) @TypeOf(CMSG_ALIGN(len) + CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr))) {
    return CMSG_ALIGN(len) + CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr));
}
pub inline fn CMSG_LEN(len: anytype) @TypeOf(CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr)) + len) {
    return CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr)) + len;
}
pub inline fn __CMSG_PADDING(len: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(usize) - (len & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1))) {
    return (@import("std").zig.c_translation.sizeof(usize) - (len & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1));
}
pub const __ASM_GENERIC_SOCKET_H = "";
pub const _LINUX_POSIX_TYPES_H = "";
pub const _LINUX_STDDEF_H = "";
pub const _ASM_X86_POSIX_TYPES_64_H = "";
pub const __ASM_GENERIC_POSIX_TYPES_H = "";
pub const __ASM_X86_BITSPERLONG_H = "";
pub const __BITS_PER_LONG = @as(c_int, 64);
pub const __ASM_GENERIC_BITS_PER_LONG = "";
pub const __ASM_GENERIC_SOCKIOS_H = "";
pub const FIOSETOWN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8901, .hexadecimal);
pub const SIOCSPGRP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8902, .hexadecimal);
pub const FIOGETOWN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8903, .hexadecimal);
pub const SIOCGPGRP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8904, .hexadecimal);
pub const SIOCATMARK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8905, .hexadecimal);
pub const SIOCGSTAMP_OLD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8906, .hexadecimal);
pub const SIOCGSTAMPNS_OLD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8907, .hexadecimal);
pub const SOL_SOCKET = @as(c_int, 1);
pub const SO_DEBUG = @as(c_int, 1);
pub const SO_REUSEADDR = @as(c_int, 2);
pub const SO_TYPE = @as(c_int, 3);
pub const SO_ERROR = @as(c_int, 4);
pub const SO_DONTROUTE = @as(c_int, 5);
pub const SO_BROADCAST = @as(c_int, 6);
pub const SO_SNDBUF = @as(c_int, 7);
pub const SO_RCVBUF = @as(c_int, 8);
pub const SO_SNDBUFFORCE = @as(c_int, 32);
pub const SO_RCVBUFFORCE = @as(c_int, 33);
pub const SO_KEEPALIVE = @as(c_int, 9);
pub const SO_OOBINLINE = @as(c_int, 10);
pub const SO_NO_CHECK = @as(c_int, 11);
pub const SO_PRIORITY = @as(c_int, 12);
pub const SO_LINGER = @as(c_int, 13);
pub const SO_BSDCOMPAT = @as(c_int, 14);
pub const SO_REUSEPORT = @as(c_int, 15);
pub const SO_PASSCRED = @as(c_int, 16);
pub const SO_PEERCRED = @as(c_int, 17);
pub const SO_RCVLOWAT = @as(c_int, 18);
pub const SO_SNDLOWAT = @as(c_int, 19);
pub const SO_RCVTIMEO_OLD = @as(c_int, 20);
pub const SO_SNDTIMEO_OLD = @as(c_int, 21);
pub const SO_SECURITY_AUTHENTICATION = @as(c_int, 22);
pub const SO_SECURITY_ENCRYPTION_TRANSPORT = @as(c_int, 23);
pub const SO_SECURITY_ENCRYPTION_NETWORK = @as(c_int, 24);
pub const SO_BINDTODEVICE = @as(c_int, 25);
pub const SO_ATTACH_FILTER = @as(c_int, 26);
pub const SO_DETACH_FILTER = @as(c_int, 27);
pub const SO_GET_FILTER = SO_ATTACH_FILTER;
pub const SO_PEERNAME = @as(c_int, 28);
pub const SO_ACCEPTCONN = @as(c_int, 30);
pub const SO_PEERSEC = @as(c_int, 31);
pub const SO_PASSSEC = @as(c_int, 34);
pub const SO_MARK = @as(c_int, 36);
pub const SO_PROTOCOL = @as(c_int, 38);
pub const SO_DOMAIN = @as(c_int, 39);
pub const SO_RXQ_OVFL = @as(c_int, 40);
pub const SO_WIFI_STATUS = @as(c_int, 41);
pub const SCM_WIFI_STATUS = SO_WIFI_STATUS;
pub const SO_PEEK_OFF = @as(c_int, 42);
pub const SO_NOFCS = @as(c_int, 43);
pub const SO_LOCK_FILTER = @as(c_int, 44);
pub const SO_SELECT_ERR_QUEUE = @as(c_int, 45);
pub const SO_BUSY_POLL = @as(c_int, 46);
pub const SO_MAX_PACING_RATE = @as(c_int, 47);
pub const SO_BPF_EXTENSIONS = @as(c_int, 48);
pub const SO_INCOMING_CPU = @as(c_int, 49);
pub const SO_ATTACH_BPF = @as(c_int, 50);
pub const SO_DETACH_BPF = SO_DETACH_FILTER;
pub const SO_ATTACH_REUSEPORT_CBPF = @as(c_int, 51);
pub const SO_ATTACH_REUSEPORT_EBPF = @as(c_int, 52);
pub const SO_CNX_ADVICE = @as(c_int, 53);
pub const SCM_TIMESTAMPING_OPT_STATS = @as(c_int, 54);
pub const SO_MEMINFO = @as(c_int, 55);
pub const SO_INCOMING_NAPI_ID = @as(c_int, 56);
pub const SO_COOKIE = @as(c_int, 57);
pub const SCM_TIMESTAMPING_PKTINFO = @as(c_int, 58);
pub const SO_PEERGROUPS = @as(c_int, 59);
pub const SO_ZEROCOPY = @as(c_int, 60);
pub const SO_TXTIME = @as(c_int, 61);
pub const SCM_TXTIME = SO_TXTIME;
pub const SO_BINDTOIFINDEX = @as(c_int, 62);
pub const SO_TIMESTAMP_OLD = @as(c_int, 29);
pub const SO_TIMESTAMPNS_OLD = @as(c_int, 35);
pub const SO_TIMESTAMPING_OLD = @as(c_int, 37);
pub const SO_TIMESTAMP_NEW = @as(c_int, 63);
pub const SO_TIMESTAMPNS_NEW = @as(c_int, 64);
pub const SO_TIMESTAMPING_NEW = @as(c_int, 65);
pub const SO_RCVTIMEO_NEW = @as(c_int, 66);
pub const SO_SNDTIMEO_NEW = @as(c_int, 67);
pub const SO_DETACH_REUSEPORT_BPF = @as(c_int, 68);
pub const SO_PREFER_BUSY_POLL = @as(c_int, 69);
pub const SO_BUSY_POLL_BUDGET = @as(c_int, 70);
pub const SO_NETNS_COOKIE = @as(c_int, 71);
pub const SO_BUF_LOCK = @as(c_int, 72);
pub const SO_RESERVE_MEM = @as(c_int, 73);
pub const SO_TXREHASH = @as(c_int, 74);
pub const SO_RCVMARK = @as(c_int, 75);
pub const SO_TIMESTAMP = SO_TIMESTAMP_OLD;
pub const SO_TIMESTAMPNS = SO_TIMESTAMPNS_OLD;
pub const SO_TIMESTAMPING = SO_TIMESTAMPING_OLD;
pub const SO_RCVTIMEO = SO_RCVTIMEO_OLD;
pub const SO_SNDTIMEO = SO_SNDTIMEO_OLD;
pub const SCM_TIMESTAMP = SO_TIMESTAMP;
pub const SCM_TIMESTAMPNS = SO_TIMESTAMPNS;
pub const SCM_TIMESTAMPING = SO_TIMESTAMPING;
pub const __osockaddr_defined = @as(c_int, 1);
pub const __USE_KERNEL_IPV6_DEFS = @as(c_int, 0);
pub const IP_OPTIONS = @as(c_int, 4);
pub const IP_HDRINCL = @as(c_int, 3);
pub const IP_TOS = @as(c_int, 1);
pub const IP_TTL = @as(c_int, 2);
pub const IP_RECVOPTS = @as(c_int, 6);
pub const IP_RECVRETOPTS = IP_RETOPTS;
pub const IP_RETOPTS = @as(c_int, 7);
pub const IP_MULTICAST_IF = @as(c_int, 32);
pub const IP_MULTICAST_TTL = @as(c_int, 33);
pub const IP_MULTICAST_LOOP = @as(c_int, 34);
pub const IP_ADD_MEMBERSHIP = @as(c_int, 35);
pub const IP_DROP_MEMBERSHIP = @as(c_int, 36);
pub const IP_UNBLOCK_SOURCE = @as(c_int, 37);
pub const IP_BLOCK_SOURCE = @as(c_int, 38);
pub const IP_ADD_SOURCE_MEMBERSHIP = @as(c_int, 39);
pub const IP_DROP_SOURCE_MEMBERSHIP = @as(c_int, 40);
pub const IP_MSFILTER = @as(c_int, 41);
pub const MCAST_JOIN_GROUP = @as(c_int, 42);
pub const MCAST_BLOCK_SOURCE = @as(c_int, 43);
pub const MCAST_UNBLOCK_SOURCE = @as(c_int, 44);
pub const MCAST_LEAVE_GROUP = @as(c_int, 45);
pub const MCAST_JOIN_SOURCE_GROUP = @as(c_int, 46);
pub const MCAST_LEAVE_SOURCE_GROUP = @as(c_int, 47);
pub const MCAST_MSFILTER = @as(c_int, 48);
pub const IP_MULTICAST_ALL = @as(c_int, 49);
pub const IP_UNICAST_IF = @as(c_int, 50);
pub const MCAST_EXCLUDE = @as(c_int, 0);
pub const MCAST_INCLUDE = @as(c_int, 1);
pub const IP_ROUTER_ALERT = @as(c_int, 5);
pub const IP_PKTINFO = @as(c_int, 8);
pub const IP_PKTOPTIONS = @as(c_int, 9);
pub const IP_PMTUDISC = @as(c_int, 10);
pub const IP_MTU_DISCOVER = @as(c_int, 10);
pub const IP_RECVERR = @as(c_int, 11);
pub const IP_RECVTTL = @as(c_int, 12);
pub const IP_RECVTOS = @as(c_int, 13);
pub const IP_MTU = @as(c_int, 14);
pub const IP_FREEBIND = @as(c_int, 15);
pub const IP_IPSEC_POLICY = @as(c_int, 16);
pub const IP_XFRM_POLICY = @as(c_int, 17);
pub const IP_PASSSEC = @as(c_int, 18);
pub const IP_TRANSPARENT = @as(c_int, 19);
pub const IP_ORIGDSTADDR = @as(c_int, 20);
pub const IP_RECVORIGDSTADDR = IP_ORIGDSTADDR;
pub const IP_MINTTL = @as(c_int, 21);
pub const IP_NODEFRAG = @as(c_int, 22);
pub const IP_CHECKSUM = @as(c_int, 23);
pub const IP_BIND_ADDRESS_NO_PORT = @as(c_int, 24);
pub const IP_RECVFRAGSIZE = @as(c_int, 25);
pub const IP_RECVERR_RFC4884 = @as(c_int, 26);
pub const IP_PMTUDISC_DONT = @as(c_int, 0);
pub const IP_PMTUDISC_WANT = @as(c_int, 1);
pub const IP_PMTUDISC_DO = @as(c_int, 2);
pub const IP_PMTUDISC_PROBE = @as(c_int, 3);
pub const IP_PMTUDISC_INTERFACE = @as(c_int, 4);
pub const IP_PMTUDISC_OMIT = @as(c_int, 5);
pub const SOL_IP = @as(c_int, 0);
pub const IP_DEFAULT_MULTICAST_TTL = @as(c_int, 1);
pub const IP_DEFAULT_MULTICAST_LOOP = @as(c_int, 1);
pub const IP_MAX_MEMBERSHIPS = @as(c_int, 20);
pub const IPV6_ADDRFORM = @as(c_int, 1);
pub const IPV6_2292PKTINFO = @as(c_int, 2);
pub const IPV6_2292HOPOPTS = @as(c_int, 3);
pub const IPV6_2292DSTOPTS = @as(c_int, 4);
pub const IPV6_2292RTHDR = @as(c_int, 5);
pub const IPV6_2292PKTOPTIONS = @as(c_int, 6);
pub const IPV6_CHECKSUM = @as(c_int, 7);
pub const IPV6_2292HOPLIMIT = @as(c_int, 8);
pub const IPV6_NEXTHOP = @as(c_int, 9);
pub const IPV6_AUTHHDR = @as(c_int, 10);
pub const IPV6_UNICAST_HOPS = @as(c_int, 16);
pub const IPV6_MULTICAST_IF = @as(c_int, 17);
pub const IPV6_MULTICAST_HOPS = @as(c_int, 18);
pub const IPV6_MULTICAST_LOOP = @as(c_int, 19);
pub const IPV6_JOIN_GROUP = @as(c_int, 20);
pub const IPV6_LEAVE_GROUP = @as(c_int, 21);
pub const IPV6_ROUTER_ALERT = @as(c_int, 22);
pub const IPV6_MTU_DISCOVER = @as(c_int, 23);
pub const IPV6_MTU = @as(c_int, 24);
pub const IPV6_RECVERR = @as(c_int, 25);
pub const IPV6_V6ONLY = @as(c_int, 26);
pub const IPV6_JOIN_ANYCAST = @as(c_int, 27);
pub const IPV6_LEAVE_ANYCAST = @as(c_int, 28);
pub const IPV6_MULTICAST_ALL = @as(c_int, 29);
pub const IPV6_ROUTER_ALERT_ISOLATE = @as(c_int, 30);
pub const IPV6_RECVERR_RFC4884 = @as(c_int, 31);
pub const IPV6_IPSEC_POLICY = @as(c_int, 34);
pub const IPV6_XFRM_POLICY = @as(c_int, 35);
pub const IPV6_HDRINCL = @as(c_int, 36);
pub const IPV6_RECVPKTINFO = @as(c_int, 49);
pub const IPV6_PKTINFO = @as(c_int, 50);
pub const IPV6_RECVHOPLIMIT = @as(c_int, 51);
pub const IPV6_HOPLIMIT = @as(c_int, 52);
pub const IPV6_RECVHOPOPTS = @as(c_int, 53);
pub const IPV6_HOPOPTS = @as(c_int, 54);
pub const IPV6_RTHDRDSTOPTS = @as(c_int, 55);
pub const IPV6_RECVRTHDR = @as(c_int, 56);
pub const IPV6_RTHDR = @as(c_int, 57);
pub const IPV6_RECVDSTOPTS = @as(c_int, 58);
pub const IPV6_DSTOPTS = @as(c_int, 59);
pub const IPV6_RECVPATHMTU = @as(c_int, 60);
pub const IPV6_PATHMTU = @as(c_int, 61);
pub const IPV6_DONTFRAG = @as(c_int, 62);
pub const IPV6_RECVTCLASS = @as(c_int, 66);
pub const IPV6_TCLASS = @as(c_int, 67);
pub const IPV6_AUTOFLOWLABEL = @as(c_int, 70);
pub const IPV6_ADDR_PREFERENCES = @as(c_int, 72);
pub const IPV6_MINHOPCOUNT = @as(c_int, 73);
pub const IPV6_ORIGDSTADDR = @as(c_int, 74);
pub const IPV6_RECVORIGDSTADDR = IPV6_ORIGDSTADDR;
pub const IPV6_TRANSPARENT = @as(c_int, 75);
pub const IPV6_UNICAST_IF = @as(c_int, 76);
pub const IPV6_RECVFRAGSIZE = @as(c_int, 77);
pub const IPV6_FREEBIND = @as(c_int, 78);
pub const IPV6_ADD_MEMBERSHIP = IPV6_JOIN_GROUP;
pub const IPV6_DROP_MEMBERSHIP = IPV6_LEAVE_GROUP;
pub const IPV6_RXHOPOPTS = IPV6_HOPOPTS;
pub const IPV6_RXDSTOPTS = IPV6_DSTOPTS;
pub const IPV6_PMTUDISC_DONT = @as(c_int, 0);
pub const IPV6_PMTUDISC_WANT = @as(c_int, 1);
pub const IPV6_PMTUDISC_DO = @as(c_int, 2);
pub const IPV6_PMTUDISC_PROBE = @as(c_int, 3);
pub const IPV6_PMTUDISC_INTERFACE = @as(c_int, 4);
pub const IPV6_PMTUDISC_OMIT = @as(c_int, 5);
pub const SOL_IPV6 = @as(c_int, 41);
pub const SOL_ICMPV6 = @as(c_int, 58);
pub const IPV6_RTHDR_LOOSE = @as(c_int, 0);
pub const IPV6_RTHDR_STRICT = @as(c_int, 1);
pub const IPV6_RTHDR_TYPE_0 = @as(c_int, 0);
pub inline fn IN_CLASSA(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal)) == @as(c_int, 0)) {
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal)) == @as(c_int, 0);
}
pub const IN_CLASSA_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff000000, .hexadecimal);
pub const IN_CLASSA_NSHIFT = @as(c_int, 24);
pub const IN_CLASSA_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hexadecimal) & ~IN_CLASSA_NET;
pub const IN_CLASSA_MAX = @as(c_int, 128);
pub inline fn IN_CLASSB(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal)) {
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hexadecimal);
}
pub const IN_CLASSB_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff0000, .hexadecimal);
pub const IN_CLASSB_NSHIFT = @as(c_int, 16);
pub const IN_CLASSB_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hexadecimal) & ~IN_CLASSB_NET;
pub const IN_CLASSB_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub inline fn IN_CLASSC(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hexadecimal)) {
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hexadecimal);
}
pub const IN_CLASSC_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffff00, .hexadecimal);
pub const IN_CLASSC_NSHIFT = @as(c_int, 8);
pub const IN_CLASSC_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hexadecimal) & ~IN_CLASSC_NET;
pub inline fn IN_CLASSD(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal)) {
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal);
}
pub inline fn IN_MULTICAST(a: anytype) @TypeOf(IN_CLASSD(a)) {
    return IN_CLASSD(a);
}
pub inline fn IN_EXPERIMENTAL(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal)) {
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal);
}
pub inline fn IN_BADCLASS(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hexadecimal)) {
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hexadecimal)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hexadecimal);
}
pub const INADDR_ANY = @import("std").zig.c_translation.cast(in_addr_t, @as(c_int, 0x00000000));
pub const INADDR_BROADCAST = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hexadecimal));
pub const INADDR_NONE = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hexadecimal));
pub const INADDR_DUMMY = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000008, .hexadecimal));
pub const IN_LOOPBACKNET = @as(c_int, 127);
pub const INADDR_LOOPBACK = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7f000001, .hexadecimal));
pub const INADDR_UNSPEC_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hexadecimal));
pub const INADDR_ALLHOSTS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000001, .hexadecimal));
pub const INADDR_ALLRTRS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000002, .hexadecimal));
pub const INADDR_ALLSNOOPERS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe000006a, .hexadecimal));
pub const INADDR_MAX_LOCAL_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe00000ff, .hexadecimal));
pub const INET_ADDRSTRLEN = @as(c_int, 16);
pub const INET6_ADDRSTRLEN = @as(c_int, 46);
pub inline fn IP_MSFILTER_SIZE(numsrc: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(struct_ip_msfilter) - @import("std").zig.c_translation.sizeof(struct_in_addr)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_in_addr))) {
    return (@import("std").zig.c_translation.sizeof(struct_ip_msfilter) - @import("std").zig.c_translation.sizeof(struct_in_addr)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_in_addr));
}
pub inline fn GROUP_FILTER_SIZE(numsrc: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(struct_group_filter) - @import("std").zig.c_translation.sizeof(struct_sockaddr_storage)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_sockaddr_storage))) {
    return (@import("std").zig.c_translation.sizeof(struct_group_filter) - @import("std").zig.c_translation.sizeof(struct_sockaddr_storage)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_sockaddr_storage));
}
pub const _RPC_NETDB_H = @as(c_int, 1);
pub const _PATH_HEQUIV = "/etc/hosts.equiv";
pub const _PATH_HOSTS = "/etc/hosts";
pub const _PATH_NETWORKS = "/etc/networks";
pub const _PATH_NSSWITCH_CONF = "/etc/nsswitch.conf";
pub const _PATH_PROTOCOLS = "/etc/protocols";
pub const _PATH_SERVICES = "/etc/services";
pub const h_errno = __h_errno_location().*;
pub const HOST_NOT_FOUND = @as(c_int, 1);
pub const TRY_AGAIN = @as(c_int, 2);
pub const NO_RECOVERY = @as(c_int, 3);
pub const NO_DATA = @as(c_int, 4);
pub const NETDB_INTERNAL = -@as(c_int, 1);
pub const NETDB_SUCCESS = @as(c_int, 0);
pub const NO_ADDRESS = NO_DATA;
pub const AI_PASSIVE = @as(c_int, 0x0001);
pub const AI_CANONNAME = @as(c_int, 0x0002);
pub const AI_NUMERICHOST = @as(c_int, 0x0004);
pub const AI_V4MAPPED = @as(c_int, 0x0008);
pub const AI_ALL = @as(c_int, 0x0010);
pub const AI_ADDRCONFIG = @as(c_int, 0x0020);
pub const AI_NUMERICSERV = @as(c_int, 0x0400);
pub const EAI_BADFLAGS = -@as(c_int, 1);
pub const EAI_NONAME = -@as(c_int, 2);
pub const EAI_AGAIN = -@as(c_int, 3);
pub const EAI_FAIL = -@as(c_int, 4);
pub const EAI_FAMILY = -@as(c_int, 6);
pub const EAI_SOCKTYPE = -@as(c_int, 7);
pub const EAI_SERVICE = -@as(c_int, 8);
pub const EAI_MEMORY = -@as(c_int, 10);
pub const EAI_SYSTEM = -@as(c_int, 11);
pub const EAI_OVERFLOW = -@as(c_int, 12);
pub const NI_MAXHOST = @as(c_int, 1025);
pub const NI_MAXSERV = @as(c_int, 32);
pub const NI_NUMERICHOST = @as(c_int, 1);
pub const NI_NUMERICSERV = @as(c_int, 2);
pub const NI_NOFQDN = @as(c_int, 4);
pub const NI_NAMEREQD = @as(c_int, 8);
pub const NI_DGRAM = @as(c_int, 16);
pub const LOGICAL_PROTO_H = "";
pub const XACT_H = "";
pub const GIDSIZE = @as(c_int, 200);
pub const XACT_READ_UNCOMMITTED = @as(c_int, 0);
pub const XACT_READ_COMMITTED = @as(c_int, 1);
pub const XACT_REPEATABLE_READ = @as(c_int, 2);
pub const XACT_SERIALIZABLE = @as(c_int, 3);
pub inline fn IsolationUsesXactSnapshot() @TypeOf(XactIsoLevel >= XACT_REPEATABLE_READ) {
    return XactIsoLevel >= XACT_REPEATABLE_READ;
}
pub inline fn IsolationIsSerializable() @TypeOf(XactIsoLevel == XACT_SERIALIZABLE) {
    return XactIsoLevel == XACT_SERIALIZABLE;
}
pub const SYNCHRONOUS_COMMIT_ON = SYNCHRONOUS_COMMIT_REMOTE_FLUSH;
pub const XACT_FLAGS_ACCESSEDTEMPNAMESPACE = @as(c_uint, 1) << @as(c_int, 0);
pub const XACT_FLAGS_ACQUIREDACCESSEXCLUSIVELOCK = @as(c_uint, 1) << @as(c_int, 1);
pub const XACT_FLAGS_NEEDIMMEDIATECOMMIT = @as(c_uint, 1) << @as(c_int, 2);
pub const XACT_FLAGS_PIPELINING = @as(c_uint, 1) << @as(c_int, 3);
pub const XLOG_XACT_COMMIT = @as(c_int, 0x00);
pub const XLOG_XACT_PREPARE = @as(c_int, 0x10);
pub const XLOG_XACT_ABORT = @as(c_int, 0x20);
pub const XLOG_XACT_COMMIT_PREPARED = @as(c_int, 0x30);
pub const XLOG_XACT_ABORT_PREPARED = @as(c_int, 0x40);
pub const XLOG_XACT_ASSIGNMENT = @as(c_int, 0x50);
pub const XLOG_XACT_INVALIDATIONS = @as(c_int, 0x60);
pub const XLOG_XACT_OPMASK = @as(c_int, 0x70);
pub const XLOG_XACT_HAS_INFO = @as(c_int, 0x80);
pub const XACT_XINFO_HAS_DBINFO = @as(c_uint, 1) << @as(c_int, 0);
pub const XACT_XINFO_HAS_SUBXACTS = @as(c_uint, 1) << @as(c_int, 1);
pub const XACT_XINFO_HAS_RELFILELOCATORS = @as(c_uint, 1) << @as(c_int, 2);
pub const XACT_XINFO_HAS_INVALS = @as(c_uint, 1) << @as(c_int, 3);
pub const XACT_XINFO_HAS_TWOPHASE = @as(c_uint, 1) << @as(c_int, 4);
pub const XACT_XINFO_HAS_ORIGIN = @as(c_uint, 1) << @as(c_int, 5);
pub const XACT_XINFO_HAS_AE_LOCKS = @as(c_uint, 1) << @as(c_int, 6);
pub const XACT_XINFO_HAS_GID = @as(c_uint, 1) << @as(c_int, 7);
pub const XACT_XINFO_HAS_DROPPED_STATS = @as(c_uint, 1) << @as(c_int, 8);
pub const XACT_COMPLETION_APPLY_FEEDBACK = @as(c_uint, 1) << @as(c_int, 29);
pub const XACT_COMPLETION_UPDATE_RELCACHE_FILE = @as(c_uint, 1) << @as(c_int, 30);
pub const XACT_COMPLETION_FORCE_SYNC_COMMIT = @as(c_uint, 1) << @as(c_int, 31);
pub inline fn XactCompletionApplyFeedback(xinfo: anytype) @TypeOf((xinfo & XACT_COMPLETION_APPLY_FEEDBACK) != @as(c_int, 0)) {
    return (xinfo & XACT_COMPLETION_APPLY_FEEDBACK) != @as(c_int, 0);
}
pub inline fn XactCompletionRelcacheInitFileInval(xinfo: anytype) @TypeOf((xinfo & XACT_COMPLETION_UPDATE_RELCACHE_FILE) != @as(c_int, 0)) {
    return (xinfo & XACT_COMPLETION_UPDATE_RELCACHE_FILE) != @as(c_int, 0);
}
pub inline fn XactCompletionForceSyncCommit(xinfo: anytype) @TypeOf((xinfo & XACT_COMPLETION_FORCE_SYNC_COMMIT) != @as(c_int, 0)) {
    return (xinfo & XACT_COMPLETION_FORCE_SYNC_COMMIT) != @as(c_int, 0);
}
pub const MinSizeOfXactAbort = @import("std").zig.c_translation.sizeof(xl_xact_abort);
pub const TUPTABLE_H = "";
pub const SYSATTR_H = "";
pub const SelfItemPointerAttributeNumber = -@as(c_int, 1);
pub const MinTransactionIdAttributeNumber = -@as(c_int, 2);
pub const MinCommandIdAttributeNumber = -@as(c_int, 3);
pub const MaxTransactionIdAttributeNumber = -@as(c_int, 4);
pub const MaxCommandIdAttributeNumber = -@as(c_int, 5);
pub const TableOidAttributeNumber = -@as(c_int, 6);
pub const FirstLowInvalidHeapAttributeNumber = -@as(c_int, 7);
pub const TTS_FLAG_EMPTY = @as(c_int, 1) << @as(c_int, 1);
pub inline fn TTS_EMPTY(slot: anytype) @TypeOf((slot.*.tts_flags & TTS_FLAG_EMPTY) != @as(c_int, 0)) {
    return (slot.*.tts_flags & TTS_FLAG_EMPTY) != @as(c_int, 0);
}
pub const TTS_FLAG_SHOULDFREE = @as(c_int, 1) << @as(c_int, 2);
pub inline fn TTS_SHOULDFREE(slot: anytype) @TypeOf((slot.*.tts_flags & TTS_FLAG_SHOULDFREE) != @as(c_int, 0)) {
    return (slot.*.tts_flags & TTS_FLAG_SHOULDFREE) != @as(c_int, 0);
}
pub const TTS_FLAG_SLOW = @as(c_int, 1) << @as(c_int, 3);
pub inline fn TTS_SLOW(slot: anytype) @TypeOf((slot.*.tts_flags & TTS_FLAG_SLOW) != @as(c_int, 0)) {
    return (slot.*.tts_flags & TTS_FLAG_SLOW) != @as(c_int, 0);
}
pub const TTS_FLAG_FIXED = @as(c_int, 1) << @as(c_int, 4);
pub inline fn TTS_FIXED(slot: anytype) @TypeOf((slot.*.tts_flags & TTS_FLAG_FIXED) != @as(c_int, 0)) {
    return (slot.*.tts_flags & TTS_FLAG_FIXED) != @as(c_int, 0);
}
pub const FIELDNO_TUPLETABLESLOT_FLAGS = @as(c_int, 1);
pub const FIELDNO_TUPLETABLESLOT_NVALID = @as(c_int, 2);
pub const FIELDNO_TUPLETABLESLOT_TUPLEDESCRIPTOR = @as(c_int, 4);
pub const FIELDNO_TUPLETABLESLOT_VALUES = @as(c_int, 5);
pub const FIELDNO_TUPLETABLESLOT_ISNULL = @as(c_int, 6);
pub inline fn TTS_IS_VIRTUAL(slot: anytype) @TypeOf(slot.*.tts_ops == (&TTSOpsVirtual)) {
    return slot.*.tts_ops == (&TTSOpsVirtual);
}
pub inline fn TTS_IS_HEAPTUPLE(slot: anytype) @TypeOf(slot.*.tts_ops == (&TTSOpsHeapTuple)) {
    return slot.*.tts_ops == (&TTSOpsHeapTuple);
}
pub inline fn TTS_IS_MINIMALTUPLE(slot: anytype) @TypeOf(slot.*.tts_ops == (&TTSOpsMinimalTuple)) {
    return slot.*.tts_ops == (&TTSOpsMinimalTuple);
}
pub inline fn TTS_IS_BUFFERTUPLE(slot: anytype) @TypeOf(slot.*.tts_ops == (&TTSOpsBufferHeapTuple)) {
    return slot.*.tts_ops == (&TTSOpsBufferHeapTuple);
}
pub const FIELDNO_HEAPTUPLETABLESLOT_TUPLE = @as(c_int, 1);
pub const FIELDNO_HEAPTUPLETABLESLOT_OFF = @as(c_int, 2);
pub const FIELDNO_MINIMALTUPLETABLESLOT_TUPLE = @as(c_int, 1);
pub const FIELDNO_MINIMALTUPLETABLESLOT_OFF = @as(c_int, 4);
pub inline fn TupIsNull(slot: anytype) @TypeOf((slot == NULL) or (TTS_EMPTY(slot) != 0)) {
    return (slot == NULL) or (TTS_EMPTY(slot) != 0);
}
pub const REL_H = "";
pub const CATALOG_H = "";
pub const PG_CLASS_H = "";
pub const PG_CLASS_D_H = "";
pub const RelationRelationId = @as(c_int, 1259);
pub const RelationRelation_Rowtype_Id = @as(c_int, 83);
pub const ClassOidIndexId = @as(c_int, 2662);
pub const ClassNameNspIndexId = @as(c_int, 2663);
pub const ClassTblspcRelfilenodeIndexId = @as(c_int, 3455);
pub const Anum_pg_class_oid = @as(c_int, 1);
pub const Anum_pg_class_relname = @as(c_int, 2);
pub const Anum_pg_class_relnamespace = @as(c_int, 3);
pub const Anum_pg_class_reltype = @as(c_int, 4);
pub const Anum_pg_class_reloftype = @as(c_int, 5);
pub const Anum_pg_class_relowner = @as(c_int, 6);
pub const Anum_pg_class_relam = @as(c_int, 7);
pub const Anum_pg_class_relfilenode = @as(c_int, 8);
pub const Anum_pg_class_reltablespace = @as(c_int, 9);
pub const Anum_pg_class_relpages = @as(c_int, 10);
pub const Anum_pg_class_reltuples = @as(c_int, 11);
pub const Anum_pg_class_relallvisible = @as(c_int, 12);
pub const Anum_pg_class_reltoastrelid = @as(c_int, 13);
pub const Anum_pg_class_relhasindex = @as(c_int, 14);
pub const Anum_pg_class_relisshared = @as(c_int, 15);
pub const Anum_pg_class_relpersistence = @as(c_int, 16);
pub const Anum_pg_class_relkind = @as(c_int, 17);
pub const Anum_pg_class_relnatts = @as(c_int, 18);
pub const Anum_pg_class_relchecks = @as(c_int, 19);
pub const Anum_pg_class_relhasrules = @as(c_int, 20);
pub const Anum_pg_class_relhastriggers = @as(c_int, 21);
pub const Anum_pg_class_relhassubclass = @as(c_int, 22);
pub const Anum_pg_class_relrowsecurity = @as(c_int, 23);
pub const Anum_pg_class_relforcerowsecurity = @as(c_int, 24);
pub const Anum_pg_class_relispopulated = @as(c_int, 25);
pub const Anum_pg_class_relreplident = @as(c_int, 26);
pub const Anum_pg_class_relispartition = @as(c_int, 27);
pub const Anum_pg_class_relrewrite = @as(c_int, 28);
pub const Anum_pg_class_relfrozenxid = @as(c_int, 29);
pub const Anum_pg_class_relminmxid = @as(c_int, 30);
pub const Anum_pg_class_relacl = @as(c_int, 31);
pub const Anum_pg_class_reloptions = @as(c_int, 32);
pub const Anum_pg_class_relpartbound = @as(c_int, 33);
pub const Natts_pg_class = @as(c_int, 33);
pub const RELKIND_RELATION = 'r';
pub const RELKIND_INDEX = 'i';
pub const RELKIND_SEQUENCE = 'S';
pub const RELKIND_TOASTVALUE = 't';
pub const RELKIND_VIEW = 'v';
pub const RELKIND_MATVIEW = 'm';
pub const RELKIND_COMPOSITE_TYPE = 'c';
pub const RELKIND_FOREIGN_TABLE = 'f';
pub const RELKIND_PARTITIONED_TABLE = 'p';
pub const RELKIND_PARTITIONED_INDEX = 'I';
pub const RELPERSISTENCE_PERMANENT = 'p';
pub const RELPERSISTENCE_UNLOGGED = 'u';
pub const RELPERSISTENCE_TEMP = 't';
pub const REPLICA_IDENTITY_DEFAULT = 'd';
pub const REPLICA_IDENTITY_NOTHING = 'n';
pub const REPLICA_IDENTITY_FULL = 'f';
pub const REPLICA_IDENTITY_INDEX = 'i';
pub inline fn RELKIND_HAS_STORAGE(relkind: anytype) @TypeOf(((((relkind == RELKIND_RELATION) or (relkind == RELKIND_INDEX)) or (relkind == RELKIND_SEQUENCE)) or (relkind == RELKIND_TOASTVALUE)) or (relkind == RELKIND_MATVIEW)) {
    return ((((relkind == RELKIND_RELATION) or (relkind == RELKIND_INDEX)) or (relkind == RELKIND_SEQUENCE)) or (relkind == RELKIND_TOASTVALUE)) or (relkind == RELKIND_MATVIEW);
}
pub inline fn RELKIND_HAS_PARTITIONS(relkind: anytype) @TypeOf((relkind == RELKIND_PARTITIONED_TABLE) or (relkind == RELKIND_PARTITIONED_INDEX)) {
    return (relkind == RELKIND_PARTITIONED_TABLE) or (relkind == RELKIND_PARTITIONED_INDEX);
}
pub inline fn RELKIND_HAS_TABLESPACE(relkind: anytype) @TypeOf(((RELKIND_HAS_STORAGE(relkind) != 0) or (RELKIND_HAS_PARTITIONS(relkind) != 0)) and (relkind != RELKIND_SEQUENCE)) {
    return ((RELKIND_HAS_STORAGE(relkind) != 0) or (RELKIND_HAS_PARTITIONS(relkind) != 0)) and (relkind != RELKIND_SEQUENCE);
}
pub inline fn RELKIND_HAS_TABLE_AM(relkind: anytype) @TypeOf(((relkind == RELKIND_RELATION) or (relkind == RELKIND_TOASTVALUE)) or (relkind == RELKIND_MATVIEW)) {
    return ((relkind == RELKIND_RELATION) or (relkind == RELKIND_TOASTVALUE)) or (relkind == RELKIND_MATVIEW);
}
pub const PG_INDEX_H = "";
pub const PG_INDEX_D_H = "";
pub const IndexRelationId = @as(c_int, 2610);
pub const IndexIndrelidIndexId = @as(c_int, 2678);
pub const IndexRelidIndexId = @as(c_int, 2679);
pub const Anum_pg_index_indexrelid = @as(c_int, 1);
pub const Anum_pg_index_indrelid = @as(c_int, 2);
pub const Anum_pg_index_indnatts = @as(c_int, 3);
pub const Anum_pg_index_indnkeyatts = @as(c_int, 4);
pub const Anum_pg_index_indisunique = @as(c_int, 5);
pub const Anum_pg_index_indnullsnotdistinct = @as(c_int, 6);
pub const Anum_pg_index_indisprimary = @as(c_int, 7);
pub const Anum_pg_index_indisexclusion = @as(c_int, 8);
pub const Anum_pg_index_indimmediate = @as(c_int, 9);
pub const Anum_pg_index_indisclustered = @as(c_int, 10);
pub const Anum_pg_index_indisvalid = @as(c_int, 11);
pub const Anum_pg_index_indcheckxmin = @as(c_int, 12);
pub const Anum_pg_index_indisready = @as(c_int, 13);
pub const Anum_pg_index_indislive = @as(c_int, 14);
pub const Anum_pg_index_indisreplident = @as(c_int, 15);
pub const Anum_pg_index_indkey = @as(c_int, 16);
pub const Anum_pg_index_indcollation = @as(c_int, 17);
pub const Anum_pg_index_indclass = @as(c_int, 18);
pub const Anum_pg_index_indoption = @as(c_int, 19);
pub const Anum_pg_index_indexprs = @as(c_int, 20);
pub const Anum_pg_index_indpred = @as(c_int, 21);
pub const Natts_pg_index = @as(c_int, 21);
pub const INDOPTION_DESC = @as(c_int, 0x0001);
pub const INDOPTION_NULLS_FIRST = @as(c_int, 0x0002);
pub const PG_PUBLICATION_H = "";
pub const PG_PUBLICATION_D_H = "";
pub const PublicationRelationId = @as(c_int, 6104);
pub const PublicationObjectIndexId = @as(c_int, 6110);
pub const PublicationNameIndexId = @as(c_int, 6111);
pub const Anum_pg_publication_oid = @as(c_int, 1);
pub const Anum_pg_publication_pubname = @as(c_int, 2);
pub const Anum_pg_publication_pubowner = @as(c_int, 3);
pub const Anum_pg_publication_puballtables = @as(c_int, 4);
pub const Anum_pg_publication_pubinsert = @as(c_int, 5);
pub const Anum_pg_publication_pubupdate = @as(c_int, 6);
pub const Anum_pg_publication_pubdelete = @as(c_int, 7);
pub const Anum_pg_publication_pubtruncate = @as(c_int, 8);
pub const Anum_pg_publication_pubviaroot = @as(c_int, 9);
pub const Natts_pg_publication = @as(c_int, 9);
pub const PRS2LOCK_H = "";
pub const SMGR_H = "";
pub inline fn SmgrIsTemp(smgr: anytype) @TypeOf(RelFileLocatorBackendIsTemp(smgr.*.smgr_rlocator)) {
    return RelFileLocatorBackendIsTemp(smgr.*.smgr_rlocator);
}
pub const RELTRIGGER_H = "";
pub const HEAP_MIN_FILLFACTOR = @as(c_int, 10);
pub const HEAP_DEFAULT_FILLFACTOR = @as(c_int, 100);
pub inline fn RelationGetToastTupleTarget(relation: anytype, defaulttarg: anytype) @TypeOf(if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]StdRdOptions, relation.*.rd_options).*.toast_tuple_target else defaulttarg) {
    return if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]StdRdOptions, relation.*.rd_options).*.toast_tuple_target else defaulttarg;
}
pub inline fn RelationGetFillFactor(relation: anytype, defaultff: anytype) @TypeOf(if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]StdRdOptions, relation.*.rd_options).*.fillfactor else defaultff) {
    return if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]StdRdOptions, relation.*.rd_options).*.fillfactor else defaultff;
}
pub inline fn RelationGetTargetPageUsage(relation: anytype, defaultff: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(BLCKSZ * RelationGetFillFactor(relation, defaultff), @as(c_int, 100))) {
    return @import("std").zig.c_translation.MacroArithmetic.div(BLCKSZ * RelationGetFillFactor(relation, defaultff), @as(c_int, 100));
}
pub inline fn RelationGetTargetPageFreeSpace(relation: anytype, defaultff: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(BLCKSZ * (@as(c_int, 100) - RelationGetFillFactor(relation, defaultff)), @as(c_int, 100))) {
    return @import("std").zig.c_translation.MacroArithmetic.div(BLCKSZ * (@as(c_int, 100) - RelationGetFillFactor(relation, defaultff)), @as(c_int, 100));
}
pub inline fn RelationIsUsedAsCatalogTable(relation: anytype) @TypeOf(if ((relation.*.rd_options != 0) and ((relation.*.rd_rel.*.relkind == RELKIND_RELATION) or (relation.*.rd_rel.*.relkind == RELKIND_MATVIEW))) @import("std").zig.c_translation.cast([*c]StdRdOptions, relation.*.rd_options).*.user_catalog_table else @"false") {
    return if ((relation.*.rd_options != 0) and ((relation.*.rd_rel.*.relkind == RELKIND_RELATION) or (relation.*.rd_rel.*.relkind == RELKIND_MATVIEW))) @import("std").zig.c_translation.cast([*c]StdRdOptions, relation.*.rd_options).*.user_catalog_table else @"false";
}
pub inline fn RelationGetParallelWorkers(relation: anytype, defaultpw: anytype) @TypeOf(if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]StdRdOptions, relation.*.rd_options).*.parallel_workers else defaultpw) {
    return if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]StdRdOptions, relation.*.rd_options).*.parallel_workers else defaultpw;
}
pub inline fn RelationIsSecurityView(relation: anytype) @TypeOf(if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.security_barrier else @"false") {
    return blk_1: {
        _ = AssertMacro(relation.*.rd_rel.*.relkind == RELKIND_VIEW);
        break :blk_1 if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.security_barrier else @"false";
    };
}
pub inline fn RelationHasSecurityInvoker(relation: anytype) @TypeOf(if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.security_invoker else @"false") {
    return blk_1: {
        _ = AssertMacro(relation.*.rd_rel.*.relkind == RELKIND_VIEW);
        break :blk_1 if (relation.*.rd_options) @import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.security_invoker else @"false";
    };
}
pub inline fn RelationHasCheckOption(relation: anytype) @TypeOf((relation.*.rd_options != 0) and (@import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.check_option != VIEW_OPTION_CHECK_OPTION_NOT_SET)) {
    return blk_1: {
        _ = AssertMacro(relation.*.rd_rel.*.relkind == RELKIND_VIEW);
        break :blk_1 (relation.*.rd_options != 0) and (@import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.check_option != VIEW_OPTION_CHECK_OPTION_NOT_SET);
    };
}
pub inline fn RelationHasLocalCheckOption(relation: anytype) @TypeOf((relation.*.rd_options != 0) and (@import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.check_option == VIEW_OPTION_CHECK_OPTION_LOCAL)) {
    return blk_1: {
        _ = AssertMacro(relation.*.rd_rel.*.relkind == RELKIND_VIEW);
        break :blk_1 (relation.*.rd_options != 0) and (@import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.check_option == VIEW_OPTION_CHECK_OPTION_LOCAL);
    };
}
pub inline fn RelationHasCascadedCheckOption(relation: anytype) @TypeOf((relation.*.rd_options != 0) and (@import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.check_option == VIEW_OPTION_CHECK_OPTION_CASCADED)) {
    return blk_1: {
        _ = AssertMacro(relation.*.rd_rel.*.relkind == RELKIND_VIEW);
        break :blk_1 (relation.*.rd_options != 0) and (@import("std").zig.c_translation.cast([*c]ViewOptions, relation.*.rd_options).*.check_option == VIEW_OPTION_CHECK_OPTION_CASCADED);
    };
}
pub inline fn RelationIsValid(relation: anytype) @TypeOf(PointerIsValid(relation)) {
    return PointerIsValid(relation);
}
pub const InvalidRelation = @import("std").zig.c_translation.cast(Relation, NULL);
pub inline fn RelationHasReferenceCountZero(relation: anytype) @TypeOf(@"bool"(relation.*.rd_refcnt == @as(c_int, 0))) {
    return @"bool"(relation.*.rd_refcnt == @as(c_int, 0));
}
pub inline fn RelationGetForm(relation: anytype) @TypeOf(relation.*.rd_rel) {
    return relation.*.rd_rel;
}
pub inline fn RelationGetRelid(relation: anytype) @TypeOf(relation.*.rd_id) {
    return relation.*.rd_id;
}
pub inline fn RelationGetNumberOfAttributes(relation: anytype) @TypeOf(relation.*.rd_rel.*.relnatts) {
    return relation.*.rd_rel.*.relnatts;
}
pub inline fn IndexRelationGetNumberOfAttributes(relation: anytype) @TypeOf(relation.*.rd_index.*.indnatts) {
    return relation.*.rd_index.*.indnatts;
}
pub inline fn IndexRelationGetNumberOfKeyAttributes(relation: anytype) @TypeOf(relation.*.rd_index.*.indnkeyatts) {
    return relation.*.rd_index.*.indnkeyatts;
}
pub inline fn RelationGetDescr(relation: anytype) @TypeOf(relation.*.rd_att) {
    return relation.*.rd_att;
}
pub inline fn RelationGetRelationName(relation: anytype) @TypeOf(NameStr(relation.*.rd_rel.*.relname)) {
    return NameStr(relation.*.rd_rel.*.relname);
}
pub inline fn RelationGetNamespace(relation: anytype) @TypeOf(relation.*.rd_rel.*.relnamespace) {
    return relation.*.rd_rel.*.relnamespace;
}
pub inline fn RelationIsMapped(relation: anytype) @TypeOf((RELKIND_HAS_STORAGE(relation.*.rd_rel.*.relkind) != 0) and (relation.*.rd_rel.*.relfilenode == InvalidRelFileNumber)) {
    return (RELKIND_HAS_STORAGE(relation.*.rd_rel.*.relkind) != 0) and (relation.*.rd_rel.*.relfilenode == InvalidRelFileNumber);
}
pub inline fn RelationGetTargetBlock(relation: anytype) @TypeOf(if (relation.*.rd_smgr != NULL) relation.*.rd_smgr.*.smgr_targblock else InvalidBlockNumber) {
    return if (relation.*.rd_smgr != NULL) relation.*.rd_smgr.*.smgr_targblock else InvalidBlockNumber;
}
pub inline fn RelationIsPermanent(relation: anytype) @TypeOf(relation.*.rd_rel.*.relpersistence == RELPERSISTENCE_PERMANENT) {
    return relation.*.rd_rel.*.relpersistence == RELPERSISTENCE_PERMANENT;
}
pub inline fn RelationNeedsWAL(relation: anytype) @TypeOf((RelationIsPermanent(relation) != 0) and ((XLogIsNeeded() != 0) or ((relation.*.rd_createSubid == InvalidSubTransactionId) and (relation.*.rd_firstRelfilelocatorSubid == InvalidSubTransactionId)))) {
    return (RelationIsPermanent(relation) != 0) and ((XLogIsNeeded() != 0) or ((relation.*.rd_createSubid == InvalidSubTransactionId) and (relation.*.rd_firstRelfilelocatorSubid == InvalidSubTransactionId)));
}
pub inline fn RelationUsesLocalBuffers(relation: anytype) @TypeOf(relation.*.rd_rel.*.relpersistence == RELPERSISTENCE_TEMP) {
    return relation.*.rd_rel.*.relpersistence == RELPERSISTENCE_TEMP;
}
pub inline fn RELATION_IS_LOCAL(relation: anytype) @TypeOf((relation.*.rd_islocaltemp != 0) or (relation.*.rd_createSubid != InvalidSubTransactionId)) {
    return (relation.*.rd_islocaltemp != 0) or (relation.*.rd_createSubid != InvalidSubTransactionId);
}
pub inline fn RELATION_IS_OTHER_TEMP(relation: anytype) @TypeOf((relation.*.rd_rel.*.relpersistence == RELPERSISTENCE_TEMP) and !(relation.*.rd_islocaltemp != 0)) {
    return (relation.*.rd_rel.*.relpersistence == RELPERSISTENCE_TEMP) and !(relation.*.rd_islocaltemp != 0);
}
pub inline fn RelationIsScannable(relation: anytype) @TypeOf(relation.*.rd_rel.*.relispopulated) {
    return relation.*.rd_rel.*.relispopulated;
}
pub inline fn RelationIsPopulated(relation: anytype) @TypeOf(relation.*.rd_rel.*.relispopulated) {
    return relation.*.rd_rel.*.relispopulated;
}
pub inline fn RelationIsAccessibleInLogicalDecoding(relation: anytype) @TypeOf(((XLogLogicalInfoActive() != 0) and (RelationNeedsWAL(relation) != 0)) and ((IsCatalogRelation(relation) != 0) or (RelationIsUsedAsCatalogTable(relation) != 0))) {
    return ((XLogLogicalInfoActive() != 0) and (RelationNeedsWAL(relation) != 0)) and ((IsCatalogRelation(relation) != 0) or (RelationIsUsedAsCatalogTable(relation) != 0));
}
pub inline fn RelationIsLogicallyLogged(relation: anytype) @TypeOf((((XLogLogicalInfoActive() != 0) and (RelationNeedsWAL(relation) != 0)) and (relation.*.rd_rel.*.relkind != RELKIND_FOREIGN_TABLE)) and !(IsCatalogRelation(relation) != 0)) {
    return (((XLogLogicalInfoActive() != 0) and (RelationNeedsWAL(relation) != 0)) and (relation.*.rd_rel.*.relkind != RELKIND_FOREIGN_TABLE)) and !(IsCatalogRelation(relation) != 0);
}
pub const LOGICALREP_PROTO_MIN_VERSION_NUM = @as(c_int, 1);
pub const LOGICALREP_PROTO_VERSION_NUM = @as(c_int, 1);
pub const LOGICALREP_PROTO_STREAM_VERSION_NUM = @as(c_int, 2);
pub const LOGICALREP_PROTO_TWOPHASE_VERSION_NUM = @as(c_int, 3);
pub const LOGICALREP_PROTO_STREAM_PARALLEL_VERSION_NUM = @as(c_int, 4);
pub const LOGICALREP_PROTO_MAX_VERSION_NUM = LOGICALREP_PROTO_STREAM_PARALLEL_VERSION_NUM;
pub const LOGICALREP_COLUMN_NULL = 'n';
pub const LOGICALREP_COLUMN_UNCHANGED = 'u';
pub const LOGICALREP_COLUMN_TEXT = 't';
pub const LOGICALREP_COLUMN_BINARY = 'b';
pub const _WALSENDER_H = "";
pub const LATCH_H = "";
pub const WL_LATCH_SET = @as(c_int, 1) << @as(c_int, 0);
pub const WL_SOCKET_READABLE = @as(c_int, 1) << @as(c_int, 1);
pub const WL_SOCKET_WRITEABLE = @as(c_int, 1) << @as(c_int, 2);
pub const WL_TIMEOUT = @as(c_int, 1) << @as(c_int, 3);
pub const WL_POSTMASTER_DEATH = @as(c_int, 1) << @as(c_int, 4);
pub const WL_EXIT_ON_PM_DEATH = @as(c_int, 1) << @as(c_int, 5);
pub const WL_SOCKET_CONNECTED = WL_SOCKET_WRITEABLE;
pub const WL_SOCKET_CLOSED = @as(c_int, 1) << @as(c_int, 7);
pub const WL_SOCKET_ACCEPT = WL_SOCKET_READABLE;
pub const WL_SOCKET_MASK = (((WL_SOCKET_READABLE | WL_SOCKET_WRITEABLE) | WL_SOCKET_CONNECTED) | WL_SOCKET_ACCEPT) | WL_SOCKET_CLOSED;
pub const TUPLESTORE_H = "";
pub inline fn tuplestore_donestoring(state: anytype) anyopaque {
    _ = @TypeOf(state);
    return @import("std").zig.c_translation.cast(anyopaque, @as(c_int, 0));
}
pub const MAXCONNINFO = @as(c_int, 1024);
pub inline fn AllowCascadeReplication() @TypeOf((EnableHotStandby != 0) and (max_wal_senders > @as(c_int, 0))) {
    return (EnableHotStandby != 0) and (max_wal_senders > @as(c_int, 0));
}
pub inline fn walrcv_connect(conninfo: anytype, logical: anytype, must_use_password: anytype, appname: anytype, err: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_connect(conninfo, logical, must_use_password, appname, err)) {
    return WalReceiverFunctions.*.walrcv_connect(conninfo, logical, must_use_password, appname, err);
}
pub inline fn walrcv_check_conninfo(conninfo: anytype, must_use_password: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_check_conninfo(conninfo, must_use_password)) {
    return WalReceiverFunctions.*.walrcv_check_conninfo(conninfo, must_use_password);
}
pub inline fn walrcv_get_conninfo(conn: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_get_conninfo(conn)) {
    return WalReceiverFunctions.*.walrcv_get_conninfo(conn);
}
pub inline fn walrcv_get_senderinfo(conn: anytype, sender_host: anytype, sender_port: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_get_senderinfo(conn, sender_host, sender_port)) {
    return WalReceiverFunctions.*.walrcv_get_senderinfo(conn, sender_host, sender_port);
}
pub inline fn walrcv_identify_system(conn: anytype, primary_tli: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_identify_system(conn, primary_tli)) {
    return WalReceiverFunctions.*.walrcv_identify_system(conn, primary_tli);
}
pub inline fn walrcv_server_version(conn: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_server_version(conn)) {
    return WalReceiverFunctions.*.walrcv_server_version(conn);
}
pub inline fn walrcv_readtimelinehistoryfile(conn: anytype, tli: anytype, filename: anytype, content: anytype, size: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_readtimelinehistoryfile(conn, tli, filename, content, size)) {
    return WalReceiverFunctions.*.walrcv_readtimelinehistoryfile(conn, tli, filename, content, size);
}
pub inline fn walrcv_startstreaming(conn: anytype, options: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_startstreaming(conn, options)) {
    return WalReceiverFunctions.*.walrcv_startstreaming(conn, options);
}
pub inline fn walrcv_endstreaming(conn: anytype, next_tli: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_endstreaming(conn, next_tli)) {
    return WalReceiverFunctions.*.walrcv_endstreaming(conn, next_tli);
}
pub inline fn walrcv_receive(conn: anytype, buffer: anytype, wait_fd: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_receive(conn, buffer, wait_fd)) {
    return WalReceiverFunctions.*.walrcv_receive(conn, buffer, wait_fd);
}
pub inline fn walrcv_send(conn: anytype, buffer: anytype, nbytes: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_send(conn, buffer, nbytes)) {
    return WalReceiverFunctions.*.walrcv_send(conn, buffer, nbytes);
}
pub inline fn walrcv_create_slot(conn: anytype, slotname: anytype, temporary: anytype, two_phase: anytype, snapshot_action: anytype, lsn: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_create_slot(conn, slotname, temporary, two_phase, snapshot_action, lsn)) {
    return WalReceiverFunctions.*.walrcv_create_slot(conn, slotname, temporary, two_phase, snapshot_action, lsn);
}
pub inline fn walrcv_get_backend_pid(conn: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_get_backend_pid(conn)) {
    return WalReceiverFunctions.*.walrcv_get_backend_pid(conn);
}
pub inline fn walrcv_exec(conn: anytype, exec: anytype, nRetTypes: anytype, retTypes: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_exec(conn, exec, nRetTypes, retTypes)) {
    return WalReceiverFunctions.*.walrcv_exec(conn, exec, nRetTypes, retTypes);
}
pub inline fn walrcv_disconnect(conn: anytype) @TypeOf(WalReceiverFunctions.*.walrcv_disconnect(conn)) {
    return WalReceiverFunctions.*.walrcv_disconnect(conn);
}
pub inline fn SlotIsPhysical(slot: anytype) @TypeOf(slot.*.data.database == InvalidOid) {
    return slot.*.data.database == InvalidOid;
}
pub inline fn SlotIsLogical(slot: anytype) @TypeOf(slot.*.data.database != InvalidOid) {
    return slot.*.data.database != InvalidOid;
}
pub const PG_ORIGIN_H = "";
pub const PG_REPLICATION_ORIGIN_H = "";
pub const PG_REPLICATION_ORIGIN_D_H = "";
pub const ReplicationOriginRelationId = @as(c_int, 6000);
pub const PgReplicationOriginToastTable = @as(c_int, 4181);
pub const PgReplicationOriginToastIndex = @as(c_int, 4182);
pub const ReplicationOriginIdentIndex = @as(c_int, 6001);
pub const ReplicationOriginNameIndex = @as(c_int, 6002);
pub const Anum_pg_replication_origin_roident = @as(c_int, 1);
pub const Anum_pg_replication_origin_roname = @as(c_int, 2);
pub const Natts_pg_replication_origin = @as(c_int, 2);
pub const XLOG_REPLORIGIN_SET = @as(c_int, 0x00);
pub const XLOG_REPLORIGIN_DROP = @as(c_int, 0x10);
pub const InvalidRepOriginId = @as(c_int, 0);
pub const DoNotReplicateId = PG_UINT16_MAX;
pub const BUILTINS_H = "";
pub const FMGRPROTOS_H = "";
pub const MAXINT8LEN = @as(c_int, 20);
pub inline fn CStringGetTextDatum(s: anytype) @TypeOf(PointerGetDatum(cstring_to_text(s))) {
    return PointerGetDatum(cstring_to_text(s));
}
pub inline fn TextDatumGetCString(d: anytype) @TypeOf(text_to_cstring(@import("std").zig.c_translation.cast([*c]text, DatumGetPointer(d)))) {
    return text_to_cstring(@import("std").zig.c_translation.cast([*c]text, DatumGetPointer(d)));
}
pub const FORMAT_TYPE_TYPEMOD_GIVEN = @as(c_int, 0x01);
pub const FORMAT_TYPE_ALLOW_INVALID = @as(c_int, 0x02);
pub const FORMAT_TYPE_FORCE_QUALIFY = @as(c_int, 0x04);
pub const FORMAT_TYPE_INVALID_AS_NULL = @as(c_int, 0x08);
pub const LSYSCACHE_H = "";
pub const ATTSTATSSLOT_VALUES = @as(c_int, 0x01);
pub const ATTSTATSSLOT_NUMBERS = @as(c_int, 0x02);
pub inline fn type_is_array(typid: anytype) @TypeOf(get_element_type(typid) != InvalidOid) {
    return get_element_type(typid) != InvalidOid;
}
pub inline fn type_is_array_domain(typid: anytype) @TypeOf(get_base_element_type(typid) != InvalidOid) {
    return get_base_element_type(typid) != InvalidOid;
}
pub inline fn TypeIsToastable(typid: anytype) @TypeOf(get_typstorage(typid) != TYPSTORAGE_PLAIN) {
    return get_typstorage(typid) != TYPSTORAGE_PLAIN;
}
pub const MEMUTILS_H = "";
pub const MEMNODES_H = "";
pub const MaxAllocSize = @import("std").zig.c_translation.cast(Size, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x3fffffff, .hexadecimal));
pub inline fn AllocSizeIsValid(size: anytype) @TypeOf(@import("std").zig.c_translation.cast(Size, size) <= MaxAllocSize) {
    return @import("std").zig.c_translation.cast(Size, size) <= MaxAllocSize;
}
pub const MaxAllocHugeSize = @import("std").zig.c_translation.MacroArithmetic.div(SIZE_MAX, @as(c_int, 2));
pub const InvalidAllocSize = SIZE_MAX;
pub inline fn AllocHugeSizeIsValid(size: anytype) @TypeOf(@import("std").zig.c_translation.cast(Size, size) <= MaxAllocHugeSize) {
    return @import("std").zig.c_translation.cast(Size, size) <= MaxAllocHugeSize;
}
pub inline fn MemoryContextResetAndDeleteChildren(ctx: anytype) @TypeOf(MemoryContextReset(ctx)) {
    return MemoryContextReset(ctx);
}
pub inline fn MemoryContextCopyAndSetIdentifier(cxt: anytype, id: anytype) @TypeOf(MemoryContextSetIdentifier(cxt, MemoryContextStrdup(cxt, id))) {
    return MemoryContextSetIdentifier(cxt, MemoryContextStrdup(cxt, id));
}
pub const ALLOCSET_DEFAULT_MINSIZE = @as(c_int, 0);
pub const ALLOCSET_DEFAULT_INITSIZE = @as(c_int, 8) * @as(c_int, 1024);
pub const ALLOCSET_DEFAULT_MAXSIZE = (@as(c_int, 8) * @as(c_int, 1024)) * @as(c_int, 1024);
pub const ALLOCSET_DEFAULT_SIZES = blk: {
    _ = @TypeOf(ALLOCSET_DEFAULT_MINSIZE);
    _ = @TypeOf(ALLOCSET_DEFAULT_INITSIZE);
    break :blk ALLOCSET_DEFAULT_MAXSIZE;
};
pub const ALLOCSET_SMALL_MINSIZE = @as(c_int, 0);
pub const ALLOCSET_SMALL_INITSIZE = @as(c_int, 1) * @as(c_int, 1024);
pub const ALLOCSET_SMALL_MAXSIZE = @as(c_int, 8) * @as(c_int, 1024);
pub const ALLOCSET_SMALL_SIZES = blk: {
    _ = @TypeOf(ALLOCSET_SMALL_MINSIZE);
    _ = @TypeOf(ALLOCSET_SMALL_INITSIZE);
    break :blk ALLOCSET_SMALL_MAXSIZE;
};
pub const ALLOCSET_START_SMALL_SIZES = blk: {
    _ = @TypeOf(ALLOCSET_SMALL_MINSIZE);
    _ = @TypeOf(ALLOCSET_SMALL_INITSIZE);
    break :blk ALLOCSET_DEFAULT_MAXSIZE;
};
pub const ALLOCSET_SEPARATE_THRESHOLD = @as(c_int, 8192);
pub const SLAB_DEFAULT_BLOCK_SIZE = @as(c_int, 8) * @as(c_int, 1024);
pub const SLAB_LARGE_BLOCK_SIZE = (@as(c_int, 8) * @as(c_int, 1024)) * @as(c_int, 1024);
pub const __va_list_tag = struct___va_list_tag;
pub const _G_fpos_t = struct__G_fpos_t;
pub const _G_fpos64_t = struct__G_fpos64_t;
pub const _IO_marker = struct__IO_marker;
pub const _IO_codecvt = struct__IO_codecvt;
pub const _IO_wide_data = struct__IO_wide_data;
pub const _IO_FILE = struct__IO_FILE;
pub const timeval = struct_timeval;
pub const timespec = struct_timespec;
pub const __pthread_internal_list = struct___pthread_internal_list;
pub const __pthread_internal_slist = struct___pthread_internal_slist;
pub const __pthread_mutex_s = struct___pthread_mutex_s;
pub const __pthread_rwlock_arch_t = struct___pthread_rwlock_arch_t;
pub const __pthread_cond_s = struct___pthread_cond_s;
pub const random_data = struct_random_data;
pub const drand48_data = struct_drand48_data;
pub const __locale_data = struct___locale_data;
pub const __locale_struct = struct___locale_struct;
pub const lconv = struct_lconv;
pub const varlena = struct_varlena;
pub const nameData = struct_nameData;
pub const __jmp_buf_tag = struct___jmp_buf_tag;
pub const PartitionBoundInfoData = struct_PartitionBoundInfoData;
pub const PartitionKeyData = struct_PartitionKeyData;
pub const PartitionDescData = struct_PartitionDescData;
pub const PartitionDirectoryData = struct_PartitionDirectoryData;
pub const ValUnion = union_ValUnion;
pub const AttrMissing = struct_AttrMissing;
pub const _MdfdVec = struct__MdfdVec;
pub const RowSecurityDesc = struct_RowSecurityDesc;
pub const TableAmRoutine = struct_TableAmRoutine;
pub const IndexAmRoutine = struct_IndexAmRoutine;
pub const FdwRoutine = struct_FdwRoutine;
pub const PgStat_TableStatus = struct_PgStat_TableStatus;
pub const ArrayType = struct_ArrayType;
pub const flock = struct_flock;
pub const stat = struct_stat;
pub const pg_tm = struct_pg_tm;
pub const pg_itm = struct_pg_itm;
pub const pg_itm_in = struct_pg_itm_in;
pub const XLogRecData = struct_XLogRecData;
pub const BufferAccessStrategyData = struct_BufferAccessStrategyData;
pub const sigval = union_sigval;
pub const sigevent = struct_sigevent;
pub const _fpx_sw_bytes = struct__fpx_sw_bytes;
pub const _fpreg = struct__fpreg;
pub const _fpxreg = struct__fpxreg;
pub const _xmmreg = struct__xmmreg;
pub const _fpstate = struct__fpstate;
pub const sigcontext = struct_sigcontext;
pub const _xsave_hdr = struct__xsave_hdr;
pub const _ymmh_state = struct__ymmh_state;
pub const _xstate = struct__xstate;
pub const _libc_fpxreg = struct__libc_fpxreg;
pub const _libc_xmmreg = struct__libc_xmmreg;
pub const _libc_fpstate = struct__libc_fpstate;
pub const GlobalVisState = struct_GlobalVisState;
pub const SnapBuild = struct_SnapBuild;
pub const PGPROC = struct_PGPROC;
pub const iovec = struct_iovec;
pub const __socket_type = enum___socket_type;
pub const sockaddr = struct_sockaddr;
pub const sockaddr_storage = struct_sockaddr_storage;
pub const msghdr = struct_msghdr;
pub const cmsghdr = struct_cmsghdr;
pub const linger = struct_linger;
pub const osockaddr = struct_osockaddr;
pub const in_addr = struct_in_addr;
pub const ip_opts = struct_ip_opts;
pub const in_pktinfo = struct_in_pktinfo;
pub const in6_addr = struct_in6_addr;
pub const sockaddr_in = struct_sockaddr_in;
pub const sockaddr_in6 = struct_sockaddr_in6;
pub const ip_mreq = struct_ip_mreq;
pub const ip_mreqn = struct_ip_mreqn;
pub const ip_mreq_source = struct_ip_mreq_source;
pub const ipv6_mreq = struct_ipv6_mreq;
pub const group_req = struct_group_req;
pub const group_source_req = struct_group_source_req;
pub const ip_msfilter = struct_ip_msfilter;
pub const group_filter = struct_group_filter;
pub const rpcent = struct_rpcent;
pub const netent = struct_netent;
pub const hostent = struct_hostent;
pub const servent = struct_servent;
pub const protoent = struct_protoent;
pub const addrinfo = struct_addrinfo;
pub const SubscriptRoutines = struct_SubscriptRoutines;
